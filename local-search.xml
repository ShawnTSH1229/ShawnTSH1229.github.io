<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Bindless Vulkan Ray Tracing In Cry Engine</title>
    <link href="/2024/06/30/Bindless-Vulkan-Ray-Tracing-In-Cry-Engine/"/>
    <url>/2024/06/30/Bindless-Vulkan-Ray-Tracing-In-Cry-Engine/</url>
    
    <content type="html"><![CDATA[<h1 id="Acceleration-Structure-Construction"><a href="#Acceleration-Structure-Construction" class="headerlink" title="Acceleration Structure Construction"></a>Acceleration Structure Construction</h1><p>Both DXR and Vulkan RayTracing use bounding volume hierarchies (BVH) as acceleration structure, which is also commonly used for offline ray tracing. BVH is an object partition data structure. It has more advantages than space partition (BSP-Tree,Octree,etc). One advantage of BVH is that the scene can be rebuilt easily for dynamic objects: just recompute the leaf node based on the current geometry. Additionally, the two-level acceleration structure employed in the current raytracing API can optimize rigid body animation further: only update the transform matrix without the expensive bottom-level acceleration structure update. Another advantage of BVH is that the maximum size used is known, as the number of leaves is limited</p><h2 id="Two-Level-Acceleration-Structure"><a href="#Two-Level-Acceleration-Structure" class="headerlink" title="Two-Level Acceleration Structure"></a>Two-Level Acceleration Structure</h2><p>Vulkan uses a two-level acceleration structure to accelerate scene transversal and ray intersections. The bottom-level acceleration structure (BLAS) contains a set of geometries. In the Vulkan API, we can set two types of geometries: triangles or procedural. The former type contains a set of triangles, that is, actual vertex data and index data. Additionally, the BLAS with triangle geometry type contains AABB to encapsulate the geometry after it has been built. For the later geometry type, we should specify AABBs and the associated intersection function such as the ray-sphere test function. In practice, we prefer using triangle geometry, since both triangles and AABBs are hardware accelerated, but the procedural type involves additional user defined intersection functions in a shader, which is slower</p><p>The top-level acceleration structure (TLAS) consists of instances that reference the BLAS. And each instance contains a transform. We can only update the instance transform of TLAS for rigid-body animation</p><h2 id="Top-level-Acceleration-Structure-Construction"><a href="#Top-level-Acceleration-Structure-Construction" class="headerlink" title="Top-level Acceleration Structure Construction"></a>Top-level Acceleration Structure Construction</h2><h3 id="The-Trade-Offs-of-Acceleration-Structure-Building"><a href="#The-Trade-Offs-of-Acceleration-Structure-Building" class="headerlink" title="The Trade-Offs of Acceleration Structure Building"></a>The Trade-Offs of Acceleration Structure Building</h3><p>The driver is responsible for scheduling construction tasks after requesting the acceleration structure building. And the highly parallel work (calculate AABB, sort, etc) can accelerated by GPU. In addition, AS management (build&#x2F;updata) can be moved to an async compute queue, which could completely hide the cost in many cases. AS management is essentialy software-based work, which allows the driver to optimize its construction algorithm continuously.</p><p>Vulkan exposed three build options to AS management:<br>For the PREFER_FAST_TRACE bit, the driver should choose the algorithm with better runtime transversal efficiency.<br>For the PREFER_FAST_BUILD bit, the driver should choose the algorithm with a faster construction rate.<br>For the default option, driver should choose a compromise solution with a balance between trace and build speed.<br>Generally, we employ PREFER_FAST_BUILD for BLAS, as well as PREFER_FAST_TRACE for TLAS.</p><p>Ray tracing has more geometries in GPU memory than traditional rasterization methods. Vulkan has provided additional options for compacting the acceleration structure. Generally, we only compact BLAS, since it has more geometry data than TLAS</p><p>What is the algorithm implemented in the driver behind the AS build options? There are three algorithms corresponding to PREFER_FAST_TRACE, PREFER_FAST_BUILD and the default option.</p><p>The first algorithm is called LBVH (Linear BVH). It uses linear ordering derived from spatial Morton codes to build hierarchies extremely quickly and with high parallel scalability.</p><p align="center">    <img src="/resource/vkraytracing/image/LBVH.png" width="50%" height="50%"></p><p>LBVH is a simple split method and can’t guarantee the BVH build quality. SAH is a more commonly used algorithm. It’s a heuristic algorithm. It splits the scene meshes based on surface area. However, SAH needs to iterate all scene meshes during construction and take a lot of time during BVH construction.</p><p>Binning-SAH is an optimized version of the SAH algorithm. The idea is to divide the node bounding box equally in a certain dimension K (such as 32), and then take the (K-1) equal points as the segmentation boundary (divide the triangles on both sides into two child nodes) to calculate (K-1) costs, and take the segment with the smallest cost. When splitting BVH nodes in complex scenarios, K is much smaller than N. Of course, the final partition might just be a suboptimal solution.</p><p align="center">    <img src="/resource/vkraytracing/image/Bin-SAH.png" width="50%" height="50%"></p><p>When there are unevenly sized triangles in the scene, the bounding boxes of the two child nodes after Binning SAH segmentation may overlap. This causes it to cost across both child nodes.</p><p>Spatial-split SAH is an algorithm to further improve the quality of binning SAH by eliminating the overlap problem, the idea being to allow the same triangle to enter two child nodes. For each node, Binning SAH is first used to find the optimal segmentation. If there is no overlap of bounding boxes between the two child nodes separated by Binning SAH, then the segmentation ends. </p><p align="center">    <img src="/resource/vkraytracing/image/SplitSAH.png" width="50%" height="50%"></p><p>Otherwise, perform spatial-split, and the splitting step is as follows: split the node bounding box into K equal parts in a certain dimension. At (K-1) dividing points, any triangle is divided into the left node as long as some of the bounding box is on the left side of the dividing point. The right node as long as some is on the right side of the dividing point. Calculate the above (K-1) costs and take the partition with the smallest cost. If the cost is smaller than that of Binning SAH, then the Spatial-Split result is adopted.</p><h3 id="AMD-TLAS-Rebraid"><a href="#AMD-TLAS-Rebraid" class="headerlink" title="AMD TLAS Rebraid"></a>AMD TLAS Rebraid</h3><p>In AMD’s implementation, if the TLAS is built without the AllowUpdate flag, AMD GPURT will perform rebraid to improve the TLAS construction quality.</p><p>From AMD GPURT source code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> ((Util::<span class="hljs-built_in">TestAnyFlagSet</span>(m_buildArgs.inputs.flags, AccelStructBuildFlagAllowUpdate) == <span class="hljs-literal">false</span>) &amp;&amp;<br>    m_buildConfig.topLevelBuild)<br>&#123;<br>    <span class="hljs-keyword">if</span> (m_buildConfig.rebraidType == RebraidType::V1)<br>    &#123;<br>        <span class="hljs-comment">// inputs &gt; maxTopDownBuildInstances turn off rebraid</span><br>        <span class="hljs-keyword">if</span> (m_buildConfig.topDownBuild == <span class="hljs-literal">false</span>)<br>        &#123;<br>            m_buildConfig.rebraidType = RebraidType::Off;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        m_buildConfig.rebraidType = m_buildConfig.rebraidType;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    m_buildConfig.rebraidType = RebraidType::Off;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>two objects (green and blue), each with their own BVH; with their topologies (top), and their spatial extents (bottom). As the objects spatially overlap and the top-level BVH (brown) has to treat them as monolithic entities a significant BVH node overlap in the spatial domain occurs, leading to low traversal performance. (b) Our method allows the top-level BVH to look into the object BVHs, and to “open up” object nodes where appropriate. This allows the top-level BVH to create new top-level nodes (brown) that address individual subtrees in the object BVHs, resulting in improved BVH quality<br>——from Improved Two-Level BVHs using Partial Re-Braiding</p></blockquote><p align="center">    <img src="/resource/vkraytracing/image/redraid.png" width="60%" height="60%"></p><p>The core idea of rebraid is to:<br>1.start with object BVHs in the same way a traditional twolevel BVH would;<br>2.find a suitable “cut” through each object’s BVH such that the resulting set of BVH subtrees has low(er) overlap;<br>3.build a top-level BVH over those resulting subtrees.</p><h2 id="Bottom-level-Acceleration-Structure-Construction"><a href="#Bottom-level-Acceleration-Structure-Construction" class="headerlink" title="Bottom-level Acceleration Structure Construction"></a>Bottom-level Acceleration Structure Construction</h2><p>Bottom-level acceleration structure construction is divided into three steps: construct the create information, create the acceleration structure and build the acceleration structure.</p><h3 id="Construct-the-create-information"><a href="#Construct-the-create-information" class="headerlink" title="Construct the create information"></a>Construct the create information</h3><p>In order to create an acceleration structure, we must obtain the size information of the acceleration structure by calling vkGetAccelerationStructureBuildSizesKHR, and then create the acceleration structure buffer with the calculated size. Next, call vkCreateAccelerationStructureKHR with the structure creation information, and store the result in accelerationStructureHandle. It is also necessary to obtain the device address of accelerationStructureHandle. This parameter is required in the next TLAS construction.</p><p>It should be noted that a new flag (USAGE_ACCELERATION_STRUCTURE) should be added to the creation of the acceleration structure buffer. It corresponds to XXX_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR in my implementation, which indicates this buffer is suitable for use as a read-only input to an acceleration structure build.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m_sSizeInfo = <span class="hljs-built_in">GetDeviceObjectFactory</span>().<span class="hljs-built_in">GetRayTracingBottomLevelASSize</span>(rtBottomLevelCreateInfo);<br><br>m_accelerationStructureBuffer.<span class="hljs-built_in">Create</span>(<span class="hljs-number">1u</span>, <span class="hljs-built_in">static_cast</span>&lt;uint32&gt;(m_sSizeInfo.m_nAccelerationStructureSize), DXGI_FORMAT_UNKNOWN, CDeviceObjectFactory::USAGE_ACCELERATION_STRUCTURE, <span class="hljs-literal">nullptr</span>);<br><br>VkAccelerationStructureCreateInfoKHR accelerationStructureCreateInfo = &#123; VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR &#125;;<br>accelerationStructureCreateInfo.buffer = m_accelerationStructureBuffer.<span class="hljs-built_in">GetDevBuffer</span>()-&gt;<span class="hljs-built_in">GetBuffer</span>()-&gt;<span class="hljs-built_in">GetHandle</span>();<br>accelerationStructureCreateInfo.offset = <span class="hljs-number">0</span>;<br>accelerationStructureCreateInfo.size = m_sSizeInfo.m_nAccelerationStructureSize;<br>accelerationStructureCreateInfo.type = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;<br><br>Extensions::KHR_acceleration_structure::<span class="hljs-built_in">vkCreateAccelerationStructureKHR</span>(m_pDevice-&gt;<span class="hljs-built_in">GetVkDevice</span>(), &amp;accelerationStructureCreateInfo, <span class="hljs-literal">nullptr</span>, &amp;accelerationStructureHandle);<br><br>VkAccelerationStructureDeviceAddressInfoKHR deviceAddressInfo = &#123; VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR &#125;;<br>deviceAddressInfo.accelerationStructure = accelerationStructureHandle;<br>accelerationStructureDeviceAddress = Extensions::KHR_acceleration_structure::<span class="hljs-built_in">vkGetAccelerationStructureDeviceAddressKHR</span>(m_pDevice-&gt;<span class="hljs-built_in">GetVkDevice</span>(), &amp;deviceAddressInfo);<br></code></pre></td></tr></table></figure><p>One of the advantages of BVH over space partitioning is that the structure size is known. Once the required data (vertex&#x2F;index buffer, format, stride, etc) is ready, we can query the size of bottom-level acceleration structure information. The shape and type of the acceleration structure to be created is described in the VkAccelerationStructureBuildGeometryInfoKHR structure. This is the same structure that will later be used for the actual build, but the acceleration structure parameters and geometry data pointers do not need to be fully populated at this point (although they can be), just the acceleration structure type, and the geometry types, counts, and maximum sizes. These sizes are valid for any sufficiently similar acceleration structure.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">GetBottomLevelAccelerationStructureBuildInfo</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> VkDevice* pVkDevice,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> std::vector&lt;SRayTracingGeometryTriangle&gt;&amp; rtGeometryTriangles,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> SRayTracingBottomLevelASCreateInfo::STriangleIndexInfo&amp; sSTriangleIndexInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">EBuildAccelerationStructureFlag eBuildFlag,</span></span><br><span class="hljs-params"><span class="hljs-function">EBuildAccelerationStructureMode eBuildMode,</span></span><br><span class="hljs-params"><span class="hljs-function">SVulkanRayTracingBLASBuildInfo&amp; outvkRtBLASBuildInfo)</span></span><br><span class="hljs-function"></span>&#123;<br>std::vector&lt;uint32&gt; maxPrimitiveCounts;<br><span class="hljs-keyword">for</span> (uint32 index = <span class="hljs-number">0</span>; index &lt; rtGeometryTriangles.<span class="hljs-built_in">size</span>(); index++)<br>&#123;<br><span class="hljs-type">const</span> SRayTracingGeometryTriangle&amp; rayTracingGeometryTriangle = rtGeometryTriangles[index];<br>VkDeviceAddress vertexDeviceAddress = <span class="hljs-built_in">InputStreamGetBufferDeviceAddress</span>(xxxxxx);<br><br>VkAccelerationStructureGeometryKHR accelerationStructureGeometry = &#123; VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR &#125;;<br>......<br>accelerationStructureGeometry.geometryType = VK_GEOMETRY_TYPE_TRIANGLES_KHR;<br>accelerationStructureGeometry.geometry.triangles = xxx;<br>outvkRtBLASBuildInfo.m_vkRtGeometryTrianglesInfo.<span class="hljs-built_in">push_back</span>(accelerationStructureGeometry);<br><br>VkAccelerationStructureBuildRangeInfoKHR RangeInfo = &#123;&#125;;<br>outvkRtBLASBuildInfo.m_vkAsBuildRangeInfo.<span class="hljs-built_in">push_back</span>(RangeInfo);<br><br>maxPrimitiveCounts.<span class="hljs-built_in">push_back</span>(rayTracingGeometryTriangle.m_sTriangVertexleInfo.m_nMaxVertex);<br>&#125;<br><br>outvkRtBLASBuildInfo.m_vkAsBuildGeometryInfo.type = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;<br>......<br>outvkRtBLASBuildInfo.m_vkAsBuildGeometryInfo.pGeometries = outvkRtBLASBuildInfo.m_vkRtGeometryTrianglesInfo.<span class="hljs-built_in">data</span>();<br>Extensions::KHR_acceleration_structure::<span class="hljs-built_in">vkGetAccelerationStructureBuildSizesKHR</span>(*pVkDevice, VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR, &amp;outvkRtBLASBuildInfo.m_vkAsBuildGeometryInfo, maxPrimitiveCounts.<span class="hljs-built_in">data</span>(), &amp;outvkRtBLASBuildInfo.m_vkAsBuildSizeInfo);<br>&#125;<br></code></pre></td></tr></table></figure><p>GetBottomLevelAccelerationStructureBuildInfo is a shared function between creating and building BLAS, which is the same as VkAccelerationStructureBuildGeometryInfoKHR. From this function, we can obtain the size for Create BLAS and the build information for Build BLAS.</p><h3 id="Build-BLAS"><a href="#Build-BLAS" class="headerlink" title="Build BLAS"></a>Build BLAS</h3><p>We construct the acceleration structure in batch mode by gathering all of the BLAS of each geometry and composing them into an array.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;CRayTracingBottomLevelAccelerationStructurePtr&gt; rtBottomLevelASPtrs;<br><span class="hljs-keyword">for</span> (uint32 index = <span class="hljs-number">0</span>; index &lt; m_nObjectNum; index++)<br>&#123;<br>rtBottomLevelASPtrs.<span class="hljs-built_in">push_back</span>(m_objectGeometry[index]-&gt;m_pRtBottomLevelAS);<br>&#125;<br><br>pCommandInterface-&gt;<span class="hljs-built_in">BuildRayTracingBottomLevelASs</span>(rtBottomLevelASPtrs);<br></code></pre></td></tr></table></figure><p>In acceleration structure building, scratch buffers are required, but they are not used in ray tracing because acceleration structure buffers require more information, such as AABBs. These extra data are generated in VKCMDBuildAccelerationStructuresKHR. Therefore, the scratch buffer keeps temporary data, which can be released after building.Each BLAS in a batch can share a single scratch buffer, whose size is the total size of all the BLAS.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint64 nTotalScratchBufferSize = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; blas : rtBottomLevelASPtrs)<br>&#123;<br>nTotalScratchBufferSize += blas-&gt;m_sSizeInfo.m_nBuildScratchSize;<br>&#125;<br><br>CGpuBuffer scratchBuffer;<br>scratchBuffer.<span class="hljs-built_in">Create</span>(<span class="hljs-number">1u</span>, <span class="hljs-built_in">static_cast</span>&lt;uint32&gt;(nTotalScratchBufferSize), DXGI_FORMAT_UNKNOWN, CDeviceObjectFactory::USAGE_STRUCTURED | CDeviceObjectFactory::BIND_UNORDERED_ACCESS, <span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure><p>Lastly, obtain the acceleration structure building geometry information, specify the scratch buffer device address, and build the acceleration structure in batches.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;SVulkanRayTracingBLASBuildInfo&gt; tempBuildInfos;<br>std::vector&lt;VkAccelerationStructureBuildGeometryInfoKHR&gt; buildGeometryInfos;<br>std::vector&lt;VkAccelerationStructureBuildRangeInfoKHR*&gt; buildRangeInfos;<br><br>uint64 nScratchBufferOffset = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; blas : rtBottomLevelASPtrs)<br>&#123;<br>tempBuildInfos.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">SVulkanRayTracingBLASBuildInfo</span>());<br>SVulkanRayTracingBLASBuildInfo&amp; vkRtBLASBuildInfo = tempBuildInfos[tempBuildInfos.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br><br><span class="hljs-built_in">GetBottomLevelAccelerationStructureBuildInfo</span>(xxxxxx, vkRtBLASBuildInfo);<br><br>VkBufferDeviceAddressInfo bufferDeviceAddressInfo = &#123; VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO &#125;;<br>bufferDeviceAddressInfo.buffer = scratchBuffer.<span class="hljs-built_in">GetDevBuffer</span>()-&gt;<span class="hljs-built_in">GetBuffer</span>()-&gt;<span class="hljs-built_in">GetHandle</span>();<br>VkDeviceAddress scratchBufferAddress = <span class="hljs-built_in">vkGetBufferDeviceAddress</span>(<span class="hljs-built_in">GetDevice</span>()-&gt;<span class="hljs-built_in">GetVkDevice</span>(), &amp;bufferDeviceAddressInfo) + nScratchBufferOffset;<br>nScratchBufferOffset += blas-&gt;m_sSizeInfo.m_nBuildScratchSize;<br><br>CVulkanRayTracingBottomLevelAccelerationStructure* vkRtBLAS = <span class="hljs-built_in">static_cast</span>&lt;CVulkanRayTracingBottomLevelAccelerationStructure*&gt;(blas.<span class="hljs-built_in">get</span>());<br>vkRtBLASBuildInfo.m_vkAsBuildGeometryInfo.dstAccelerationStructure = vkRtBLAS-&gt;accelerationStructureHandle;<br>vkRtBLASBuildInfo.m_vkAsBuildGeometryInfo.srcAccelerationStructure = <span class="hljs-literal">nullptr</span>;<br>vkRtBLASBuildInfo.m_vkAsBuildGeometryInfo.scratchData.deviceAddress = scratchBufferAddress;<br><br>buildGeometryInfos.<span class="hljs-built_in">push_back</span>(vkRtBLASBuildInfo.m_vkAsBuildGeometryInfo);<br>buildRangeInfos.<span class="hljs-built_in">push_back</span>(vkRtBLASBuildInfo.m_vkAsBuildRangeInfo.<span class="hljs-built_in">data</span>());<br>&#125;<br><br>VkCommandBuffer cmdBuffer = <span class="hljs-built_in">GetVKCommandList</span>()-&gt;<span class="hljs-built_in">GetVkCommandList</span>();<br>Extensions::KHR_acceleration_structure::<span class="hljs-built_in">vkCmdBuildAccelerationStructuresKHR</span>(cmdBuffer, rtBottomLevelASPtrs.<span class="hljs-built_in">size</span>(), buildGeometryInfos.<span class="hljs-built_in">data</span>(), buildRangeInfos.<span class="hljs-built_in">data</span>());<br></code></pre></td></tr></table></figure><h1 id="Ray-Tracing-Shader-Cross-Compile"><a href="#Ray-Tracing-Shader-Cross-Compile" class="headerlink" title="Ray Tracing Shader Cross Compile"></a>Ray Tracing Shader Cross Compile</h1><p>Add vulkan ray tracing shader support for cry engine.</p><h2 id="Add-Token"><a href="#Add-Token" class="headerlink" title="Add Token"></a>Add Token</h2><p>Cry Engine will initialize all shaders in the ‘mfInitShadersList’ function during Engine initialization. We need to add the tokens related to the ray tracing that are not supported by the Cry Engine parser. In Cry Engine, the token is parsed in the ‘m_Bin.GetBinShader-&gt;SaveBinShader’  function. To invoke this breakpoint, you need to delete the shader cache located in <code>user\shaders\cache\vulkan</code>. The core of this function is the following three steps:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint32 dwToken = CParserBin::<span class="hljs-built_in">NextToken</span>(buf, com, bKey);<br>dwToken = Parser.<span class="hljs-built_in">NewUserToken</span>(dwToken, com, <span class="hljs-literal">false</span>);<br>pBin-&gt;m_Tokens.<span class="hljs-built_in">push_back</span>(dwToken);<br></code></pre></td></tr></table></figure><p>The <code>NextToken</code> function parses the tokens that exist in the g_KeyTokens table. The <code>NewUserToken</code> function inserts the unknown token into the token table. The value of these unknown tokens is generated by CRC.<br>Following are the tokens used in the vulkan ray tracing shader:</p><p align="center">    <img src="/resource/vkraytracing/image/tokens_added.png" width="75%" height="75%"></p><p><code>RaytracingAccelerationStructure</code>: used for acceleration structure.<br><code>[shader(&quot;raygeneration&quot;)]</code>: used for shader type determination.</p><p>Tokens related to shader techniques: Shader technique is unique to Cry Engine. It is similar to the PSO, which indicates the shaders and the render state (depth state, blend state, etc).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">technique XXX<br>&#123;<br>  pass XXX<br>  &#123;<br>    VertexShader = <span class="hljs-built_in">XX_VS</span>();<br>    PixelShader = <span class="hljs-built_in">XX_PS</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Cry Engine only supports one shader entry for each shader type for each pass. For example, a pass may have two entries (camera close hit and shader close hit shader) for close hit shader type. We need to support multi-entry shader type.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">technique RayTracingTest<br>&#123;<br>  pass p0<br>  &#123;<br>    RayGenShaders = &#123;<span class="hljs-built_in">RayGenMain</span>()&#125;;<br>    HitGroupShaders = &#123;<span class="hljs-built_in">ClostHitMain</span>()&#125;;<br>    MissShaders = &#123;<span class="hljs-built_in">MissMain</span>()&#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h2><p>Cry Engine parses the dummy shader first and skips all tokens except those related to the “technique”. During this process, Cry Engine enumerates all the shaders in the public techniques.Following are the tokens used in the dummy shader parser:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">FX_TOKEN</span>(RaytracingAccelerationStructure)<br><span class="hljs-built_in">FX_TOKEN</span>(shader)<br><span class="hljs-built_in">FX_TOKEN</span>(raygeneration)<br><span class="hljs-built_in">FX_TOKEN</span>(closesthit)<br><span class="hljs-built_in">FX_TOKEN</span>(miss)<br><span class="hljs-built_in">FX_TOKEN</span>(RayGenShaders)<br><span class="hljs-built_in">FX_TOKEN</span>(HitGroupShaders)<br><span class="hljs-built_in">FX_TOKEN</span>(MissShaders)<br><span class="hljs-built_in">FX_TOKEN</span>(vk)<br><span class="hljs-built_in">FX_TOKEN</span>(binding)<br></code></pre></td></tr></table></figure><p>Parse’s core function is <code>ParseObject</code>, which consists mainly of two steps. The first step is <code>GetNextToken</code>, where the next token is obtained. In addition, the more important part of Parse is to parse code fragments, such as preprocessed fragments or function code fragments. It also stores the function name, which is used to find the shader name later when parsing tech. In after parsing the code fragment, can be in ParseObject parse all code snippets of all statements, the Token is divided into the Name&#x2F;Assign&#x2F;Value&#x2F;Data&#x2F;Annotations type, These sub-SParserFrame in turn form a large ParserFrame based on, for example, semicolons, meaning that a code fragment contains multiple parse fragments, a <code>CF</code> (Code Fragment) may be a function, and a <code>PF</code> (Parse Fragment) may be an assignment or declaration statement.</p><p>And then re-initialize. The <code>mfLoadDefaultSystemShaders</code> function loads shader: <code>sLoadShader (&quot; RayTracingTestShader &quot;s shRayTracingTest)</code>; And through the <code>RT_ParseShaderCShaderManBin::ParseBinFX</code> parsed Tokens, such as <code>texture</code>, <code>float</code>, <code>struct</code>, can parse and load or create a shader.</p><p>When parsing technique, CE does not support ray tracing shader. We added support for ray tracing shader in the <code>ParseBinFX_Technique_Pass_LoadShaders_RayTracing</code> function:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TArray&lt;uint32&gt; <span class="hljs-title">SHData</span><span class="hljs-params">(<span class="hljs-number">0</span>, SHDataBuffer.Size())</span></span>;<br>SHData.<span class="hljs-built_in">Copy</span>(SHDataBuffer.<span class="hljs-built_in">GetElements</span>(), SHDataBuffer.<span class="hljs-built_in">size</span>());<br><br>CHWShader* pSH = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">bool</span> bValidShader = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">if</span> (bRes &amp;&amp; (!CParserBin::m_bParseFX || !SHData.<span class="hljs-built_in">empty</span>() || szName[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;$&#x27;</span>))<br>&#123;<br><span class="hljs-type">char</span> str[<span class="hljs-number">1024</span>];<br><span class="hljs-built_in">cry_sprintf</span>(str, <span class="hljs-string">&quot;%s@%s&quot;</span>, Parser.m_pCurShader-&gt;m_NameShader.<span class="hljs-built_in">c_str</span>(), szName);<br>pSH = CHWShader::<span class="hljs-built_in">mfForName</span>(str, Parser.m_pCurShader-&gt;m_NameFile, Parser.m_pCurShader-&gt;m_CRC32, szName, eSHClass, SHData, Parser.m_TokenTable, dwSHType, Parser.m_pCurShader, nGenMask, Parser.m_pCurShader-&gt;m_nMaskGenFX);<br>&#125;<br><span class="hljs-keyword">if</span> (pSH)<br>&#123;<br>bValidShader = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">if</span> (CParserBin::<span class="hljs-built_in">PlatformSupportsRayTracingShaders</span>() &amp;&amp; eSHClass == eHWSC_RayGen)<br>pPass-&gt;m_RGShaders.<span class="hljs-built_in">push_back</span>(pSH);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (CParserBin::<span class="hljs-built_in">PlatformSupportsRayTracingShaders</span>() &amp;&amp; eSHClass == eHWSC_HitGroup)<br>pPass-&gt;m_HGShaders.<span class="hljs-built_in">push_back</span>(pSH);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (CParserBin::<span class="hljs-built_in">PlatformSupportsRayTracingShaders</span>() &amp;&amp; eSHClass == eHWSC_RayMiss)<br>pPass-&gt;m_RMShaders.<span class="hljs-built_in">push_back</span>(pSH);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">CryLog</span>(<span class="hljs-string">&quot;Unsupported/unrecognised shader: %s[%d]&quot;</span>, pSH-&gt;m_Name.<span class="hljs-built_in">c_str</span>(), eSHClass);<br>&#125;<br></code></pre></td></tr></table></figure><p>We added support for shader types with multi shader entry:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">technique BindlessRayTracingTestTech<br>&#123;<br>  pass p0<br>  &#123;<br>    <span class="hljs-comment">// other ray tracing shaders</span><br>    MissShaders = &#123;<span class="hljs-built_in">MissMain</span>(),<span class="hljs-built_in">ShadowMiassMain</span>()&#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The shader entries are split by the comma token:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (pTokens[nCur] == eT_comma)<br>&#123;<br>nCur++;<br>&#125;<br></code></pre></td></tr></table></figure><p>CE technique supports only one shader, while the ray tracing shader consists of a series of shader tables. We need to add the parse and loading functions of shader tables specifically. We specify that all shaders of the same class in raytracing are placed in an array by {}, and then begin parsing shader binding table by <code>&#123;</code> token. At the same time, <code>SShaderPass</code> is extended to support multiple stores for each shader</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SShaderPass</span><br>&#123;<br>  CHWShader*  m_VShader;        <span class="hljs-comment">// Pointer to the vertex shader for the current pass</span><br>  <span class="hljs-comment">//...... Other shader s</span><br><br>  std::vector&lt;CHWShader*&gt; m_RGShaders; <span class="hljs-comment">// Pointers to ray gen shader</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Stored in an array after the <code>CHWShader</code> is parsed and created:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pPass-&gt;m_RGShaders.<span class="hljs-built_in">push_back</span>(pSH);<br></code></pre></td></tr></table></figure><h2 id="Cross-Compile"><a href="#Cross-Compile" class="headerlink" title="Cross Compile"></a>Cross Compile</h2><p>The next step is to create the shader (while creating the PSO), first get the shader from technique, and then check whether the shader is active based on the shader information. If it is not in the active state (CHWShader_D3D::mfActivate), <code>mfCompileHLSL</code> is called to trigger shader compilation. For debugging purposes, We’ve turned off asynchronous shader compiling for CE: <code>CV_r_shadersasynccompiling</code></p><p>Ray tracing shader target is different from common shaders:</p><blockquote><p>These shaders are functions compiled into a library, with target model lib_6_3, and identified by an attribute [shader(“shadertype”)] on the shader function</p></blockquote><p>Set target to <code>lib 6_3</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">case</span> eHWSC_RayGen:<br><span class="hljs-keyword">case</span> eHWSC_RayMiss:<br><span class="hljs-keyword">case</span> eHWSC_HitGroup:<br><span class="hljs-keyword">if</span> (CParserBin::<span class="hljs-built_in">PlatformSupportsRayTracingShaders</span>())<br>&#123;<br>szProfile = <span class="hljs-string">&quot;lib_6_3&quot;</span>;<br>&#125;<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>What’s more, the DXC version of CE is older, and we need to upgrade it to the new version. In addition, you need to upgrade the version of spirv cross, otherwise shader reflection process will crash.</p><p>In addition, we need to revamp the reflection part of CE-spirv to support spirv’s reflection. Once we have the compiled data we need to create vulkan raytracing shader in <code>mfUploadHW</code> function.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">BwAAAGxpYl82XzMACgAAAFJheUdlbk1haW4AAAEDHA0AAEBAHA0AAEBBHA0AAMBAAAAAAAAAAAA=</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FBasicRayData</span><br>&#123;<br>  float3 Origin;<br>  uint Mask;<br>  float3 Direction;<br>  <span class="hljs-type">float</span> TFar;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FDefaultPayload</span><br>&#123;<br>  <span class="hljs-type">float</span> HitT;<br>  uint PrimitiveIndex;<br>  uint InstanceIndex;<br>  float2 Barycentrics;<br>  uint InstanceID;<br>&#125;;<br>RaytracingAccelerationStructure TLAS:<span class="hljs-built_in">register</span>(t0);<br>StructuredBuffer&lt;FBasicRayData&gt;Rays:<span class="hljs-built_in">register</span>(t1);<br>RWStructuredBuffer&lt;uint&gt;OcclusionOutput:<span class="hljs-built_in">register</span>(u0);<br>[<span class="hljs-built_in">shader</span>(<span class="hljs-string">&quot;raygeneration&quot;</span>)]<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RayGenMain</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">const</span> uint RayIndex=<span class="hljs-built_in">DispatchRaysIndex</span>().x;<br>  FBasicRayData InputRay=Rays[RayIndex];<br>  RayDesc Ray;<br>  Ray.Origin=InputRay.Origin;<br>  Ray.Direction=InputRay.Direction;<br>  Ray.TMin=<span class="hljs-number">0.0f</span>;<br>  Ray.TMax=InputRay.TFar;<br>  uint RayFlags=<span class="hljs-number">0</span>|RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH|RAY_FLAG_FORCE_OPAQUE|RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;<br>  <span class="hljs-type">const</span> uint InstanceInclusionMask=<span class="hljs-number">0x01</span>;<br>  FDefaultPayload Payload=(FDefaultPayload)<span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">TraceRay</span>(TLAS,RayFlags,InstanceInclusionMask,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,Ray,Payload);<br>  OcclusionOutput[RayIndex]=(Payload.HitT&gt;<span class="hljs-number">0</span>)?~<span class="hljs-number">0</span>:<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>The above is the input of the hlsl shader after parsing.  After compiling by DXC, we get the SPV result. We went through the spirv-cross to convert it to GLSL, and found that a conversion error occurred. After mapping, register t0 and u0 in HLSL have the same binding point:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">layout</span>(set = <span class="hljs-number">0</span>, binding = <span class="hljs-number">0</span>, std430) buffer type_RWStructuredBuffer_uint<br>&#123;<br>    uint _m0[];<br>&#125; OcclusionOutput;<br><br><span class="hljs-built_in">layout</span>(set = <span class="hljs-number">0</span>, binding = <span class="hljs-number">0</span>) uniform accelerationStructureEXT TLAS;<br></code></pre></td></tr></table></figure><p>Here’s why the problem occurs:</p><p align="center">    <img src="/resource/vkraytracing/image/confict.png" width="85%" height="85%"></p><p>We solved the problem with <a href="https://developer.nvidia.com/blog/bringing-hlsl-ray-tracing-to-vulkan/"><u><strong>[this blog]</strong></u></a>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[[vk::<span class="hljs-built_in">binding</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)]] RaytracingAccelerationStructure topLevelAS;<br></code></pre></td></tr></table></figure><p>It also needs  to tweak the parse section of the code to skip <code>[[vk::xxx]]</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (nToken == eT_br_sq_1)<br>&#123;<br><span class="hljs-keyword">if</span> (m_CurFrame.m_nCurToken + <span class="hljs-number">1</span> &lt;= m_CurFrame.m_nLastToken)<br>&#123;<br><span class="hljs-keyword">if</span> (pTokens[m_CurFrame.m_nCurToken + <span class="hljs-number">1</span>] == eT_br_sq_1)<br>&#123;<br>int32 nLast1 = m_CurFrame.m_nCurToken + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (nLast1 &lt;= m_CurFrame.m_nLastToken &amp;&amp; pTokens[nLast1] != eT_br_sq_2)<br>&#123;<br>nLast1++;<br>&#125;<br>nLast1++;<br><span class="hljs-keyword">if</span> (nLast1 &lt;= m_CurFrame.m_nLastToken &amp;&amp; pTokens[nLast1] == eT_br_sq_2)<br>&#123;<br>SCodeFragment Fr;<br>Fr.m_eType = eFT_StorageClass;<br>Fr.m_nFirstToken = m_CurFrame.m_nCurToken;<br>m_CurFrame.m_nCurToken = nLast1 + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (pTokens[m_CurFrame.m_nCurToken] != eT_semicolumn)<br>&#123;<br><span class="hljs-keyword">if</span> (m_CurFrame.m_nCurToken + <span class="hljs-number">1</span> == nTokensSize)<br><span class="hljs-keyword">break</span>;<br>m_CurFrame.m_nCurToken++;<br>&#125;<br>Fr.m_nLastToken = m_CurFrame.m_nCurToken++;<br>Fr.m_dwName = pTokens[Fr.m_nLastToken - <span class="hljs-number">1</span>];<br>m_CodeFragments.<span class="hljs-built_in">push_back</span>(Fr);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Ray-Tracing-Pipeline"><a href="#Ray-Tracing-Pipeline" class="headerlink" title="Ray Tracing Pipeline"></a>Ray Tracing Pipeline</h1><p>Cry Engine has three render passes: <code>CComputeRenderPass</code>, <code>CPrimitiveRenderPass</code> and <code>CSceneRenderPass</code>. We added a fourth render pass: ‘CrayTracingRenderPass’.</p><h2 id="Compile-RenderPass"><a href="#Compile-RenderPass" class="headerlink" title="Compile RenderPass"></a>Compile RenderPass</h2><p>When the PSO or other resources are dirty, Cry Engine rebuilds the resource in the <code>Compile</code> function. We create the PSO and shader binding table in the <code>Compile</code> function.</p><h2 id="Resource-Set"><a href="#Resource-Set" class="headerlink" title="Resource Set"></a>Resource Set</h2><p>In the cry engine, the slot information is specified in the resource set step. For example, <code>SetTexture</code> with slot 2 corresponds to <code>t2</code> in HLSL.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CRayTracingRenderPass::SetBuffer</span><span class="hljs-params">(uint32 slot, CGpuBuffer* pBuffer)</span></span><br><span class="hljs-function"></span>&#123;<br>m_resourceDesc.<span class="hljs-built_in">SetBuffer</span>(slot, pBuffer, EDefaultResourceViews::Default, EShaderStage_RayTracing);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SResourceBindPoint</code> stores slot index, slot type and shader stages. These data are stored in <code>uint8</code> format and packed into a <code>uint32</code> variable thar will be used in state cache. <code>SResourceBinding</code> stores the resource and its view.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> CDeviceResourceSetDesc::EDirtyFlags <span class="hljs-title">CDeviceResourceSetDesc::SetBuffer</span><span class="hljs-params">(<span class="hljs-type">int</span> shaderSlot, CGpuBuffer* pBuffer, ResourceViewHandle hView, ::EShaderStage shaderStages)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">SResourceBinding <span class="hljs-title">resource</span><span class="hljs-params">(pBuffer, hView)</span></span>;<br><span class="hljs-function">SResourceBindPoint <span class="hljs-title">bindPoint</span><span class="hljs-params">(resource, shaderSlot, shaderStages)</span></span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">UpdateResource</span>&lt;SResourceBinding::EResourceType::Buffer&gt;(bindPoint, resource);<br>&#125;<br></code></pre></td></tr></table></figure><p>When the resource layout is dirty, the layout needs to be rebuilt.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (dirtyMask &amp; (eDirty_Technique | eDirty_ResourceLayout))<br>&#123;<br><span class="hljs-type">int</span> bindSlot = <span class="hljs-number">0</span>;<br>SDeviceResourceLayoutDesc resourceLayoutDesc;<br>resourceLayoutDesc.m_needBindlessLayout = m_needBindless;<br>resourceLayoutDesc.<span class="hljs-built_in">SetResourceSet</span>(bindSlot++, m_resourceDesc);<br>m_pResourceLayout = <span class="hljs-built_in">GetDeviceObjectFactory</span>().<span class="hljs-built_in">CreateResourceLayout</span>(resourceLayoutDesc);<br><br><span class="hljs-keyword">if</span> (!m_pResourceLayout)<br><span class="hljs-keyword">return</span> (EDirtyFlags)(m_dirtyMask |= revertMask);<br>&#125;<br></code></pre></td></tr></table></figure><p>Cry engine stores layout information into the cache through <code>mfInsertNewCombination</code> and decodes it during engine initialization. We extended ‘mfInitShadersCache’ and <code>GetEncodedResourceLayoutSize</code> in order to support ray tracing layout encoding.</p><p>During the engine initializes the layout, the cry engine decodes the binding information of the descriptor set through <code>EncodeDescriptorSet</code>. It includes the binding type and binding stage. This is used to map the DX binding to the Vulkan binding in the latter shader compiling process. We extended <code>GetShaderStageFlags</code> to support ray tracing. Cry engine uses the 6 bits of the uint8 to store the shader stage, which is not enough for ray tracing shader. We extended it to <code>uint32</code> format to support RayGen&#x2F;Miss&#x2F;Hit shader stages.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint8* stagesByte = (uint8*)(&amp;stages);<br><span class="hljs-keyword">for</span> (uint32 index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">4</span>; index++)<br>&#123;<br>result.<span class="hljs-built_in">push_back</span>(stagesByte[index]);<br>&#125;<br></code></pre></td></tr></table></figure><p>We need to pass in this hash in the shader compiling function <code>GetRayTracingShaderInstanceInfo</code> so that we can look up the layout later.</p><p>Add acceleration descriptor and descriptor pool support:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">poolSizes[<span class="hljs-number">8</span>].type = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR;<br>poolSizes[<span class="hljs-number">8</span>].descriptorCount = accelerationStructureCount;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">uint8</span>(bindPoint.flags &amp; SResourceBindPoint::EFlags::IsAccelerationStructured))<br>&#123;<br><span class="hljs-keyword">return</span> VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="PSO-Creation"><a href="#PSO-Creation" class="headerlink" title="PSO Creation"></a>PSO Creation</h2><p>New structures related to PSO creation:<br>1.<code>CDeviceRayTracingPSODesc</code>: Contains construction information.<br>2.<code>CDeviceRayTracingPSO</code>: Stores ray tracing PSO.<br>3.<code>m_RayTracingPsoCache</code>: Pipeline state cache.</p><p>Obtain and process the shader from the shader cache during PSO creation. It contains the following steps:<br>1.Get entry function name</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">entryPointName.<span class="hljs-built_in">push_back</span>(rayGenInfo.pHwShader-&gt;m_EntryFunc);<br></code></pre></td></tr></table></figure><p>2.Get the Vulkan shader module and create a shader stage. All stages are stored in a std::vector of VkPipelineShaderStageCreateInfo objects. At this step, indices within this vector will be used as unique identifiers for the shaders.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">shaderStage.<span class="hljs-keyword">module</span> = <span class="hljs-built_in">reinterpret_cast</span>&lt;NCryVulkan::CShader*&gt;(rayGenInfo.pDeviceShader)-&gt;<span class="hljs-built_in">GetVulkanShader</span>();<br>shaderStage.stage = VK_SHADER_STAGE_RAYGEN_BIT_KHR;<br>shaderStage.pName = entryPointName.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">data</span>();<br>shaderStages.<span class="hljs-built_in">push_back</span>(shaderStage);<br></code></pre></td></tr></table></figure><p>3.Create the shader group. Shader groups specify the shader stage index. Ray generation and miss shaders are called <code>general</code> shaders. In this case the type is <code>VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR</code>, and only the generalShader member of the structure is filled</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">VkRayTracingShaderGroupCreateInfoKHR shaderGroup = &#123; VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR &#125;;<br>shaderGroup.type = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;<br>shaderGroup.generalShader = shaderStages.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//store general shader index</span><br>shaderGroup.closestHitShader = VK_SHADER_UNUSED_KHR;<br>shaderGroup.anyHitShader = VK_SHADER_UNUSED_KHR;<br>shaderGroup.intersectionShader = VK_SHADER_UNUSED_KHR;<br>shaderGroups.<span class="hljs-built_in">push_back</span>(shaderGroup);<br></code></pre></td></tr></table></figure><h2 id="Shader-Binding-Table"><a href="#Shader-Binding-Table" class="headerlink" title="Shader Binding Table"></a>Shader Binding Table</h2><p>A shader binding table is a resource which establishes the relationship between the ray tracing pipeline and the acceleration structures that were built for the ray tracing pipeline. It indicates the shaders that operate on each geometry in an acceleration structure. In addition, it contains the resources accessed by each shader, including indices of textures, buffer device addresses, and constants. The application allocates and manages shader binding tables as VkBuffer objects</p><p>Each entry in the shader binding table consists of shaderGroupHandleSize bytes of data, either as queried by vkGetRayTracingShaderGroupHandlesKHR to refer to those specified shaders, or all zeros to refer to a zero shader group.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint32 nHandleDataSize = nHandleCount * nHandleSize;<br>std::vector&lt;uint8&gt; handleData;<br>handleData.<span class="hljs-built_in">resize</span>(nHandleDataSize);<br><br><span class="hljs-built_in">CRY_VERIFY</span>(Extensions::KHR_ray_tracing_pipeline::<span class="hljs-built_in">vkGetRayTracingShaderGroupHandlesKHR</span>(<span class="hljs-built_in">GetDevice</span>()-&gt;<span class="hljs-built_in">GetVkDevice</span>(), m_pipeline,<span class="hljs-number">0</span>, nHandleCount, nHandleDataSize, handleData.<span class="hljs-built_in">data</span>()) == VK_SUCCESS);<br></code></pre></td></tr></table></figure><p>The SBT is a collection of up to four arrays containing the handles of the shader groups used in the ray tracing pipeline, one array for each of the ray generation, miss, hit and callable (not used here) shader groups</p><p align="center">    <img src="/resource/vkraytracing/image/sbt_0.png" width="60%" height="60%"></p><p>We will ensure that all starting groups start with an address aligned to shaderGroupBaseAlignment and that each entry in the group is aligned to shaderGroupHandleAlignment bytes. All group entries are aligned with shaderGroupHandleAlignment.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m_sRayTracingSBT.m_rayGenRegion.stride = <span class="hljs-built_in">alignedValue</span>(nHandleAlign, nBaseAlign);<br>m_sRayTracingSBT.m_rayGenRegion.size = m_sRayTracingSBT.m_rayGenRegion.stride;<span class="hljs-comment">// The size member of pRayGenShaderBindingTable must be equal to its stride member</span><br><br>m_sRayTracingSBT.m_rayMissRegion.stride = nHandleAlign;<br>m_sRayTracingSBT.m_rayMissRegion.size = <span class="hljs-built_in">alignedValue</span>(nRayMissCount * nHandleAlign, nBaseAlign);<br><br>m_sRayTracingSBT.m_hitGroupRegion.stride = nHandleAlign;<br>m_sRayTracingSBT.m_hitGroupRegion.size = <span class="hljs-built_in">alignedValue</span>(nHitGroupCount * nHandleAlign, nBaseAlign);<br><br>m_sRayTracingSBT.m_callAbleRegion.stride = nHandleAlign;<br>m_sRayTracingSBT.m_callAbleRegion.size = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>In the next section, we store the device address of each shader group.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m_sRayTracingSBT.m_rayGenRegion.deviceAddress = sbtAddress;<br>m_sRayTracingSBT.m_rayMissRegion.deviceAddress = sbtAddress + m_sRayTracingSBT.m_rayGenRegion.size;<br>m_sRayTracingSBT.m_hitGroupRegion.deviceAddress = sbtAddress + m_sRayTracingSBT.m_rayGenRegion.size + m_sRayTracingSBT.m_rayMissRegion.size;<br>m_sRayTracingSBT.m_callAbleRegion.deviceAddress = sbtAddress + m_sRayTracingSBT.m_rayGenRegion.size + m_sRayTracingSBT.m_rayMissRegion.size + m_sRayTracingSBT.m_hitGroupRegion.size;<br></code></pre></td></tr></table></figure><p>The shader binding tables to use in a ray tracing pipeline are passed to the vkCmdTraceRaysNV, vkCmdTraceRaysKHR, or vkCmdTraceRaysIndirectKHR commands. Shader binding tables are read-only in shaders that are executing on the ray tracing pipeline.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Extensions::KHR_ray_tracing_pipeline::<span class="hljs-built_in">vkCmdTraceRaysKHR</span>(<span class="hljs-built_in">GetVKCommandList</span>()-&gt;<span class="hljs-built_in">GetVkCommandList</span>(), <br>&amp;pVkPipeline-&gt;m_sRayTracingSBT.m_rayGenRegion, <br>&amp;pVkPipeline-&gt;m_sRayTracingSBT.m_rayMissRegion, <br>&amp;pVkPipeline-&gt;m_sRayTracingSBT.m_hitGroupRegion, <br>&amp;pVkPipeline-&gt;m_sRayTracingSBT.m_callAbleRegion,<br>width, height, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h1 id="Bindless-Ray-Tracing"><a href="#Bindless-Ray-Tracing" class="headerlink" title="Bindless Ray Tracing"></a>Bindless Ray Tracing</h1><blockquote><p>The limited nature of the binding slots meant that programs could typically only bind the exact set of resources that would be accessed by a particular shader program, which would often have to be done before every draw or dispatch. The CPU-driven nature of binding demanded that a shader’s required resources had to be statically known after compilation, which naturally led to inherent restrictions on the complexity of a shader program.</p></blockquote><blockquote><p>As ray tracing on the GPU started to gain traction, the classic binding model reached its breaking point. Ray tracing tends to be an inherently global process: one shader program might launch rays that could potentially interact with every material in the scene. This is largely incompatible with the notion of having the CPU bind a fxed set of resources prior to dispatch.</p></blockquote><blockquote><p>Fortunately, newer GPUs and APIs no longer suffer from the same limitations. Bindless techniques effectively provide shader programs with full global access to the full set of textures and buffers that are present on the GPU. Instead of requiring the CPU to bind a view for each individual resource, shaders can instead access an individual resource using a simple 32-bit index that can be freely embedded in user-defned data structures.<br>—— From Ray Tracing Gems:USING BINDLESS RESOURCES WITH DIRECTX RAYTRACING</p></blockquote><p>Create a descriptor pool to store the descriptors. The size of the bindless descriptor pool is as large as possible to ensure that we can store all the descriptors used in ray training. When creating the Descriptor Pool, we need to add the flag <code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT</code> to ensure descriptor sets allocated from this pool can include bindings with the <code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code> bit set</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CDeviceBindlessDescriptorManager_Vulkan::CreateBindlessDescriptorPool</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// allocate descriptor pool</span><br><span class="hljs-type">const</span> uint32 setCount = <span class="hljs-number">65535</span>;<br><span class="hljs-type">const</span> uint32 sampledImageCount = <span class="hljs-number">32</span> * <span class="hljs-number">65536</span>;<br><span class="hljs-type">const</span> uint32 storageImageCount = <span class="hljs-number">1</span> * <span class="hljs-number">65536</span>;<br><span class="hljs-type">const</span> uint32 uniformBufferCount = <span class="hljs-number">1</span> * <span class="hljs-number">65536</span>;<br><span class="hljs-type">const</span> uint32 uniformBufferDynamicCount = <span class="hljs-number">4</span> * <span class="hljs-number">65536</span>;<br><span class="hljs-type">const</span> uint32 storageBufferCount = <span class="hljs-number">1</span> * <span class="hljs-number">65536</span>;<br><span class="hljs-type">const</span> uint32 uniformTexelBufferCount = <span class="hljs-number">8192</span>;<br><span class="hljs-type">const</span> uint32 storageTexelBufferCount = <span class="hljs-number">8192</span>;<br><span class="hljs-type">const</span> uint32 samplerCount = <span class="hljs-number">2</span> * <span class="hljs-number">65536</span>;<br><span class="hljs-type">const</span> uint32 accelerationStructureCount = <span class="hljs-number">32</span> * <span class="hljs-number">1024</span>;<br><br>VkDescriptorPoolSize poolSizes[<span class="hljs-number">9</span>];<br><br>poolSizes[<span class="hljs-number">0</span>].type = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE;<br>poolSizes[<span class="hljs-number">0</span>].descriptorCount = sampledImageCount;<br><br>poolSizes[<span class="hljs-number">1</span>].type = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;<br>poolSizes[<span class="hljs-number">1</span>].descriptorCount = storageImageCount;<br><br>poolSizes[<span class="hljs-number">2</span>].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;<br>poolSizes[<span class="hljs-number">2</span>].descriptorCount = uniformBufferCount;<br><br>poolSizes[<span class="hljs-number">3</span>].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC;<br>poolSizes[<span class="hljs-number">3</span>].descriptorCount = uniformBufferDynamicCount;<br><br>poolSizes[<span class="hljs-number">4</span>].type = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;<br>poolSizes[<span class="hljs-number">4</span>].descriptorCount = storageBufferCount;<br><br>poolSizes[<span class="hljs-number">5</span>].type = VK_DESCRIPTOR_TYPE_SAMPLER;<br>poolSizes[<span class="hljs-number">5</span>].descriptorCount = samplerCount;<br><br>poolSizes[<span class="hljs-number">6</span>].type = VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER;<br>poolSizes[<span class="hljs-number">6</span>].descriptorCount = uniformTexelBufferCount;<br><br>poolSizes[<span class="hljs-number">7</span>].type = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;<br>poolSizes[<span class="hljs-number">7</span>].descriptorCount = storageTexelBufferCount;<br><br>poolSizes[<span class="hljs-number">8</span>].type = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR;<br>poolSizes[<span class="hljs-number">8</span>].descriptorCount = accelerationStructureCount;<br><br>VkDescriptorPoolCreateInfo descriptorPoolCreateInfo = &#123;&#125;;<br>descriptorPoolCreateInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;<br>descriptorPoolCreateInfo.pNext = <span class="hljs-literal">nullptr</span>;<br><br>descriptorPoolCreateInfo.flags = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT;<span class="hljs-comment">//TanGram:BINDLESS</span><br><br>descriptorPoolCreateInfo.maxSets = setCount;<br>descriptorPoolCreateInfo.poolSizeCount = <span class="hljs-built_in">CRY_ARRAY_COUNT</span>(poolSizes);<br>descriptorPoolCreateInfo.pPoolSizes = poolSizes;<br><br><span class="hljs-built_in">CRY_ASSERT</span>(<span class="hljs-built_in">vkCreateDescriptorPool</span>(<span class="hljs-built_in">GetDevice</span>()-&gt;<span class="hljs-built_in">GetVkDevice</span>(), &amp;descriptorPoolCreateInfo, <span class="hljs-literal">nullptr</span>, &amp;m_bindlessDescriptorPool) == VK_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><p>Create the Descriptor Set Layout with at least the flags <code>VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT</code> and <code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT</code>. </p><p>Descriptor binding flag <code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code>: This flag indicates that if we update descriptor after it is bound (i.e using <code>vkBindDescriptorSets</code>), the command submission will use the most recently updated version of the descriptor set and most importantly, the update will NOT invalidate the command buffer. </p><p>Descriptor binding flag <code>VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT</code>: This flag indicates that descriptor set does not need to have valid descriptors in them as long as the invalid descriptors are not accessed during shader execution.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">VkDescriptorSetLayoutBindingFlagsCreateInfo descriptorSetLayoutBindingFlagsCreateInfo;<br>descriptorSetLayoutBindingFlagsCreateInfo = &#123; VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO &#125;;<br>descriptorSetLayoutBindingFlagsCreateInfo.bindingCount = EBindlessDescriptorBindingType::e_bdbtNum;<br>descriptorSetLayoutBindingFlagsCreateInfo.pBindingFlags = bindingFlags.<span class="hljs-built_in">data</span>();<br><br>VkDescriptorSetLayoutCreateInfo descriptorSetLayoutCreateInfo = &#123; VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO &#125;;<br>descriptorSetLayoutCreateInfo.pBindings = descriptorSetLayoutBindings.<span class="hljs-built_in">data</span>();<br>descriptorSetLayoutCreateInfo.bindingCount = EBindlessDescriptorBindingType::e_bdbtNum;<br>descriptorSetLayoutCreateInfo.flags = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT;<br><span class="hljs-comment">//descriptorSetLayoutCreateInfo.flags = 0;</span><br>descriptorSetLayoutCreateInfo.pNext = &amp;descriptorSetLayoutBindingFlagsCreateInfo;<br><br><span class="hljs-built_in">CRY_ASSERT</span>(<span class="hljs-built_in">vkCreateDescriptorSetLayout</span>(<span class="hljs-built_in">GetDevice</span>()-&gt;<span class="hljs-built_in">GetVkDevice</span>(), &amp;descriptorSetLayoutCreateInfo, <span class="hljs-literal">nullptr</span>, &amp;m_bindlessDescriptorSetLayout) == VK_SUCCESS);<br></code></pre></td></tr></table></figure><p>Then, create the actual descriptor set from the bindless pool:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">VkDescriptorSetAllocateInfo descriptorSetAllocateInfo&#123; VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO &#125;;<br>descriptorSetAllocateInfo.descriptorPool = m_bindlessDescriptorPool;<br>descriptorSetAllocateInfo.descriptorSetCount = <span class="hljs-number">1</span>;<br>descriptorSetAllocateInfo.pSetLayouts = &amp;m_bindlessDescriptorSetLayout;<br><br>VkDescriptorSetVariableDescriptorCountAllocateInfoEXT descriptorSetVariableDescriptorCountAllocateInfoEXT;<br>descriptorSetVariableDescriptorCountAllocateInfoEXT = &#123; VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT &#125;;<br>uint32 maxAllocatableCount = bindlessDescriptorCounrPerType - <span class="hljs-number">1</span>;<br>descriptorSetVariableDescriptorCountAllocateInfoEXT.descriptorSetCount = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// This number is the max allocatable count</span><br>descriptorSetVariableDescriptorCountAllocateInfoEXT.pDescriptorCounts = &amp;maxAllocatableCount;<br>descriptorSetAllocateInfo.pNext = &amp;descriptorSetVariableDescriptorCountAllocateInfoEXT;<br><br><span class="hljs-built_in">CRY_ASSERT</span>(<span class="hljs-built_in">vkAllocateDescriptorSets</span>(<span class="hljs-built_in">GetDevice</span>()-&gt;<span class="hljs-built_in">GetVkDevice</span>(), &amp;descriptorSetAllocateInfo, &amp;m_bindlessDescriptorSet) == VK_SUCCESS);<br></code></pre></td></tr></table></figure><p>If we want to use a buffer as a bindless resource, we need to obtain the bindless index from the free list array managed by ourselves. We also need to update the descriptors in the global descriptor pool.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">uint32 <span class="hljs-title">CDeviceObjectFactory::SetBindlessStorageBufferImpl</span><span class="hljs-params">(<span class="hljs-type">const</span> CDeviceInputStream* DeviceStreaming, uint32 bindingIndex)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">CRY_ASSERT</span>(bindingIndex &gt;= <span class="hljs-number">2</span> &amp;&amp; bindingIndex &lt;= <span class="hljs-number">5</span>);<br><br>CDeviceBindlessDescriptorManager_Vulkan* pDeviceBindlessDescriptorManager = <span class="hljs-built_in">static_cast</span>&lt;CDeviceBindlessDescriptorManager_Vulkan*&gt;(m_pDeviceBindlessDescriptorManager);<br><br><span class="hljs-type">buffer_size_t</span> offset;<br>CBufferResource* <span class="hljs-type">const</span> pActualBuffer = gcpRendD3D.m_DevBufMan.<span class="hljs-built_in">GetD3D</span>(((SStreamInfo*)DeviceStreaming)-&gt;hStream, &amp;offset);<br>VkBuffer buffer = pActualBuffer-&gt;<span class="hljs-built_in">GetHandle</span>();<br><br>SBufferBindingState&amp; storageufferBindingState = pDeviceBindlessDescriptorManager-&gt;m_BufferBindingState[bindingIndex];<br><br>uint32 currentFreeIndex = storageufferBindingState.m_currentFreeIndex;<br>storageufferBindingState.m_currentFreeIndex = storageufferBindingState.m_freeIndexArray[storageufferBindingState.m_currentFreeIndex];<br><br>uint32 bufferSize = storageufferBindingState.m_buffers.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span> (currentFreeIndex &gt;= bufferSize)<br>&#123;<br>storageufferBindingState.m_buffers.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">alignedValue</span>(currentFreeIndex + <span class="hljs-number">1</span>, <span class="hljs-number">1024</span>));<br>storageufferBindingState.m_bufferInfos.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">alignedValue</span>(currentFreeIndex + <span class="hljs-number">1</span>, <span class="hljs-number">1024</span>));<br>&#125;<br>storageufferBindingState.m_buffers[currentFreeIndex] = buffer;<br><br><br>VkDescriptorBufferInfo descriptorBufferInfo;<br><span class="hljs-comment">//range is the size in bytes that is used for this descriptor update, or VK_WHOLE_SIZE to use the range from offset to the end of the buffer.</span><br>descriptorBufferInfo.range = VK_WHOLE_SIZE;<br>descriptorBufferInfo.buffer = storageufferBindingState.m_buffers[currentFreeIndex];<br>descriptorBufferInfo.offset = offset;<br>storageufferBindingState.m_bufferInfos[currentFreeIndex] = descriptorBufferInfo;<br><br>VkWriteDescriptorSet writeDescriptorSet = &#123; VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET &#125;;<br>writeDescriptorSet.dstSet = pDeviceBindlessDescriptorManager-&gt;m_bindlessDescriptorSet;<br>writeDescriptorSet.dstBinding = bindingIndex;<br>writeDescriptorSet.dstArrayElement = currentFreeIndex;<br>writeDescriptorSet.descriptorType = <span class="hljs-built_in">ConvertToDescriptorType</span>(bindingIndex);<br>writeDescriptorSet.pBufferInfo = &amp;storageufferBindingState.m_bufferInfos[currentFreeIndex];<br>writeDescriptorSet.descriptorCount = <span class="hljs-number">1</span>;<br><br>pDeviceBindlessDescriptorManager-&gt;m_descriptorSetWrites.<span class="hljs-built_in">emplace_back</span>(writeDescriptorSet);<br>pDeviceBindlessDescriptorManager-&gt;m_isUpdateDescriptor = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">return</span> currentFreeIndex;<br>&#125;<br></code></pre></td></tr></table></figure><p>Bind the bindless descriptor set during ray tracing dispatch if we use bindless descriptor set.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (pVkLayout-&gt;m_needBindless)<br>&#123;<br><span class="hljs-built_in">vkCmdBindDescriptorSets</span>(<br><span class="hljs-built_in">GetVKCommandList</span>()-&gt;<span class="hljs-built_in">GetVkCommandList</span>(),<br>VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR,<br>pVkLayout-&gt;<span class="hljs-built_in">GetVkPipelineLayout</span>(),<br><span class="hljs-number">1</span>, <span class="hljs-comment">/*<span class="hljs-doctag">TODO:</span>FixMe*/</span><br><span class="hljs-number">1</span>,<br>&amp;pDeviceBindlessDescriptorManager-&gt;m_bindlessDescriptorSet, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>result in cry engine:</p><p align="center">    <img src="/resource/vkraytracing/image/result.png" width="75%" height="75%"></p><p><a href="https://github.com/ShawnTSH1229/VkRtInCryEngine"><u><strong>Bindless Vulkan RayTracing In Cry Engine Source Code</strong></u></a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ASTC Compression Accleration Using CUDA</title>
    <link href="/2024/06/18/ASTC-Compression-Using-CUDA/"/>
    <url>/2024/06/18/ASTC-Compression-Using-CUDA/</url>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>ASTC is a fixed-rate, lossy texture compression system that is designed to offer an unusual degree of flexibility and to support a very wide range of use cases, while providing better image quality than most formats in common use today.</p><p>However, ASTC need to search a lot of candidate block modes to find the best format. It takes a lot of time to compress the texture in practice. Since the texture block compression is not relevant to each other at all, we can compress the texture parallelly with GPU.</p><p>In our project, we compress the texture with Cuda. The compression algorithm is based on the arm astc-enc implementation. It’s a CPU-based compression program. We port arm-astc to GPU and make full use of the cuda to acclerate the texture compression.</p><p>A naive implementation of GPU ASTC compression is compressing the ASTC texture block per thread, that is, task parallel compression. Since the block compression task is heavy and uses many registers, the number of active warps is low, which causes low occupancy. To make full use of the GPU, we use data parallel to compress the ASTC block per CUDA block. It splits the “for loop” task into each thread and shares the data between lanes by warp shuffle as possible as we can.</p><p>The astc-enc implementation has a large number of intermediate buffers during candidate block mode searching, which has little performance impact on CPU-based implementations, but has a significant impact on GPU-based implementations. We have optimized this algorithm by in-place update, which removes the intermediate buffer.</p><h1 id="CPU-Based-Implementation"><a href="#CPU-Based-Implementation" class="headerlink" title="CPU Based Implementation"></a>CPU Based Implementation</h1><h2 id="Bounded-Integer-Sequence-Encoding"><a href="#Bounded-Integer-Sequence-Encoding" class="headerlink" title="Bounded Integer Sequence Encoding"></a>Bounded Integer Sequence Encoding</h2><p>ASTC uses BISE to encode color end points and color weights. We introduce BISE first since it is the basis of the ASTC compression algorithm.</p><p>Both the weight data and the endpoint color data are variable width, and are specified using a sequence of integer values. The range of each value in a sequence (e.g. a color weight) is constrained.</p><p>Since it is often the case that the most efficient range for these values is not a power of two, each value sequence is encoded using a technique known as “integer sequence encoding”. This allows efficient, hardware-friendly packing and unpacking of values with non-power-of-two ranges.</p><p>In a sequence, each value has an identical range. The range is specified in one of the following forms:</p><p align="center">    <img src="/resource/cuda_astc/image/range_form.png" width="50%" height="50%"></p><p>There are 21 quant methods in ASTC, including 6 quints quant forms, 7 trits quant forms and 8 bits quant forms.</p><p align="center">    <img src="/resource/cuda_astc/image/range_table.png" width="40%" height="40%"></p><p>For example, assume we have 3 integer values: 30, 50 and 70. The minimum range of quant formats among these values is Quant_80. The binary formats of these values are: 001 1110(30), 011 0010(50) and 100 0110(70). The total bits size before quantization is 21 &#x3D; 7 * 3.</p><p>The binary format of value 80 is 101 0000. We split it into two parts, the higher parts 101 and lower parts 0000. The possible values of the higher parts are from 000 to 101, whose total number is 5, so Quant 80 is a quints form.</p><p>The higher parts of 30, 50 and 70 are [001, 011, 100]. In the Quant 80 method, the total possible number is 5, so the number of possible combinations of [001, 011, 100] is 5x5x5 &#x3D; 125. We can precompute these possible values into a table and use the 7 bit value to index the table. The result is a 2 bit saving for these integers.</p><p>Higher parts [001, 011, 100] equal to [1,3,4]. Using index [1][3][4] to search the below quints table, we get the compressed value:11, which is 1011 in binary format. The compressed result is [000 1011](higher parts),[1110],[0010],[0110](lower parts) with size 19.</p><p align="center">    <img src="/resource/cuda_astc/image/quints_table.png" width="60%" height="60%"></p><h2 id="Generate-Block-Mode"><a href="#Generate-Block-Mode" class="headerlink" title="Generate Block Mode"></a>Generate Block Mode</h2><p>ASTC uses 10 bits to store block modes, which means it has 2^11(2048) kind of possible choices. Given an ASTC compression format, some block modes may be invalid. For example, ASTC 4x4 compression format will never use a block mode with 6x6 texel weights. So we search for valid block modes and store the results in a global block mode table. In order to reduce the computation cost of block mode search, arm-astc reordered the block modes so that the better block mode has a higher priority.</p><p>Search block mode from 000000000(0) to 1111111111(2048).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2048</span>; i++)<br>&#123;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The Block Mode field specifies the width, height and depth of the grid of weights, what range of values they use, and whether dual weight planes are present.</p><p>For 2D blocks, the Block Mode field is laid out as follows:</p><p align="center">    <img src="/resource/cuda_astc/image/block_mode.png" width="65%" height="65%"></p><p>The <strong>D</strong> bit is set to indicate dual-plane mode.</p><p>The <strong>A&#x2F;B</strong> bits indicate the block weight size.</p><p>The weight ranges are encoded using a 3 bit value <strong>R(R0,R1 and R2)</strong>, which is interpreted together with a precision bit <strong>H</strong>, as follows:</p><p align="center">    <img src="/resource/cuda_astc/image/weight_range.png" width="65%" height="65%"></p><p>Decode the R,H,D, weight sizes x and y from the bits.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">uint8_t</span> R0 = (block_mode &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">1</span>;<br><span class="hljs-type">uint8_t</span> H = (block_mode &gt;&gt; <span class="hljs-number">9</span>) &amp; <span class="hljs-number">1</span>;<br><span class="hljs-type">uint8_t</span> D = (block_mode &gt;&gt; <span class="hljs-number">10</span>) &amp; <span class="hljs-number">1</span>;<br><span class="hljs-type">uint8_t</span> A = (block_mode &gt;&gt; <span class="hljs-number">5</span>) &amp; <span class="hljs-number">0x3</span>;<br><br>x_weights = xxxxxx;<br>y_weights = xxxxxx;<br></code></pre></td></tr></table></figure><p>Skip the block mode if the qunat weight size is larger than the compression block size.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!valid || (x_weights &gt; x_texels) || (y_weights &gt; y_texels))<br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>valid block mode:</p><p align="center">    <img src="/resource/cuda_astc/image/valid_block_mode.png" width="65%" height="65%"></p><h2 id="Compute-Ideal-Color-And-Weights"><a href="#Compute-Ideal-Color-And-Weights" class="headerlink" title="Compute Ideal Color And Weights"></a>Compute Ideal Color And Weights</h2><h3 id="Color-Encoding"><a href="#Color-Encoding" class="headerlink" title="Color Encoding"></a>Color Encoding</h3><p>Each compressed block stores the end-point colors for a gradient, and an interpolation weight for each texel which defines the texel’s location along that gradient. During decompression the color value for each texel is generated by interpolating between the two end-point colors, based on the per-texel weight.</p><p>We sum up the relative colors in the positive R, G, and B directions and calculate the sum of direction lengths.</p><p align="center">    <img src="/resource/cuda_astc/image/color_gradient.png" width="65%" height="65%"></p><h3 id="Endpoints-Computation"><a href="#Endpoints-Computation" class="headerlink" title="Endpoints Computation"></a>Endpoints Computation</h3><p>Compute the mean color value and the main color direction first. There are many main direction calculation method. We use max accumulation pixel direction as the main direction, which is the same as the arm-astc implementation. We sum up the relative colors in the positive R, G, and B directions and calculate the sum of direction lengths.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">float4 <span class="hljs-title">sum_xp</span><span class="hljs-params">(<span class="hljs-number">0.0</span>)</span></span>;<br><span class="hljs-function">float4 <span class="hljs-title">sum_yp</span><span class="hljs-params">(<span class="hljs-number">0.0</span>)</span></span>;<br><span class="hljs-function">float4 <span class="hljs-title">sum_zp</span><span class="hljs-params">(<span class="hljs-number">0.0</span>)</span></span>;<br><span class="hljs-function">float4 <span class="hljs-title">sum_wp</span><span class="hljs-params">(<span class="hljs-number">0.0</span>)</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; blk.texel_count; i++)<br>&#123;<br>float4 texel_datum = <span class="hljs-built_in">make_float4</span>(blk.data_r[i], blk.data_g[i], blk.data_b[i], blk.data_a[i]);<br>texel_datum = texel_datum - blk.data_mean;<br><br>sum_xp += (texel_datum.x &gt; <span class="hljs-number">0</span>) ? texel_datum : <span class="hljs-built_in">make_float4</span>(<span class="hljs-number">0</span>);<br>sum_yp += (texel_datum.y &gt; <span class="hljs-number">0</span>) ? texel_datum : <span class="hljs-built_in">make_float4</span>(<span class="hljs-number">0</span>);<br>sum_zp += (texel_datum.z &gt; <span class="hljs-number">0</span>) ? texel_datum : <span class="hljs-built_in">make_float4</span>(<span class="hljs-number">0</span>);<br>sum_wp += (texel_datum.w &gt; <span class="hljs-number">0</span>) ? texel_datum : <span class="hljs-built_in">make_float4</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">float</span> prod_xp = <span class="hljs-built_in">dot</span>(sum_xp, sum_xp);<br><span class="hljs-type">float</span> prod_yp = <span class="hljs-built_in">dot</span>(sum_yp, sum_yp);<br><span class="hljs-type">float</span> prod_zp = <span class="hljs-built_in">dot</span>(sum_zp, sum_zp);<br><span class="hljs-type">float</span> prod_wp = <span class="hljs-built_in">dot</span>(sum_wp, sum_wp);<br></code></pre></td></tr></table></figure><p>Use the maximum sum direction as the main direction</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float4 best_vector = sum_xp;<br><span class="hljs-type">float</span> best_sum = prod_xp;<br><br><span class="hljs-keyword">if</span> (prod_yp &gt; best_sum)<br>&#123;<br>best_vector = sum_yp;<br>best_sum = prod_yp;<br>&#125;<br><br><span class="hljs-keyword">if</span> (prod_zp &gt; best_sum)<br>&#123;<br>best_vector = sum_zp;<br>best_sum = prod_zp;<br>&#125;<br><br><span class="hljs-keyword">if</span> (prod_wp &gt; best_sum)<br>&#123;<br>best_vector = sum_wp;<br>best_sum = prod_wp;<br>&#125;<br><br>dir = best_vector;<br></code></pre></td></tr></table></figure><h3 id="Interpolation-Weight-Computation"><a href="#Interpolation-Weight-Computation" class="headerlink" title="Interpolation Weight Computation"></a>Interpolation Weight Computation</h3><p>Project the color into the main direction for each texel and find the minimum and maximum projected value by the way.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">line4 line&#123; blk.data_mean, length_dir &lt; <span class="hljs-number">1e-10</span> ? <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">make_float4</span>(<span class="hljs-number">1.0</span>)) : <span class="hljs-built_in">normalize</span>(dir) &#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; blk.texel_count; j++)<br>&#123;<br><span class="hljs-function">float4 <span class="hljs-title">point</span><span class="hljs-params">(blk.data_r[j], blk.data_g[j], blk.data_b[j], blk.data_a[j])</span></span>;<br><span class="hljs-type">float</span> param = <span class="hljs-built_in">dot</span>(point - line.a, line.b);<br><br>ei.weights[j] = param;<br><br>lowparam = <span class="hljs-built_in">fmin</span>(param, lowparam);<br>highparam = <span class="hljs-built_in">fmax</span>(param, highparam);<br>&#125;<br></code></pre></td></tr></table></figure><p>Calculate the end points based on the min&#x2F;max projected color.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ei.ep.endpt0 = line.a + line.b * lowparam;<br>ei.ep.endpt1 = line.a + line.b * highparam;<br></code></pre></td></tr></table></figure><p>Normalize the weight range into 0 to 1:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> length = highparam - lowparam;<br><span class="hljs-type">float</span> scale = <span class="hljs-number">1.0f</span> / length;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; blk.texel_count; j++)<br>&#123;<br><span class="hljs-type">float</span> idx = (ei.weights[j] - lowparam) * scale;<br>idx = <span class="hljs-built_in">clamp</span>(idx, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>ei.weights[j] = idx;<br>&#125;<br></code></pre></td></tr></table></figure><p>before color projection:</p><p align="center">    <img src="/resource/cuda_astc/image/before_color_projection.png" width="30%" height="30%"></p><p>after color projection:</p><p align="center">    <img src="/resource/cuda_astc/image/after_color_projection.png" width="30%" height="30%"></p><h2 id="Compute-Weight-Quant-Error"><a href="#Compute-Weight-Quant-Error" class="headerlink" title="Compute Weight Quant Error"></a>Compute Weight Quant Error</h2><p>Compute the quant errors for each candidate block mode. Get the Quant method from the block mode and quantize the weights. After that, unquant the result by look up the precomputed quant map table. It should be noticed that the maximum color weight Quant method is Quant 32 and the maximum color end points Quant method is Quant 256.</p><p align="center">    <img src="/resource/cuda_astc/image/weight_quant_error.png" width="60%" height="60%"></p><p>Accumulate the weight quantization error for the texel weights in the block.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> error_summa = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bsd.texel_count; i++)<br>&#123;<br><span class="hljs-comment">// Load the weight set directly, without interpolation</span><br><span class="hljs-type">float</span> current_values = weight_quant_uvalue[i];<br><br><span class="hljs-comment">// Compute the error between the computed value and the ideal weight</span><br><span class="hljs-type">float</span> actual_values = eai.weights[i];<br><span class="hljs-type">float</span> diff = current_values - actual_values;<br><br><span class="hljs-type">float</span> error = diff * diff;<br>error_summa += error;<br>&#125;<br><span class="hljs-keyword">return</span> error_summa;<br></code></pre></td></tr></table></figure><p>weights quant error result:</p><p align="center">    <img src="/resource/cuda_astc/image/weight_quant_error_result.png" width="60%" height="60%"></p><h2 id="Compute-Endpoint-Quant-Error"><a href="#Compute-Endpoint-Quant-Error" class="headerlink" title="Compute Endpoint Quant Error"></a>Compute Endpoint Quant Error</h2><p>The next step is to search for the best K candidate end point format as we have the quant error of each block mode.</p><h3 id="CEM"><a href="#CEM" class="headerlink" title="CEM"></a>CEM</h3><p>CEM is the color endpoint mode field, which determines how the Color Endpoint Data is encoded. Here is the CEM layout for single-partition block layout:</p><p align="center">    <img src="/resource/cuda_astc/image/cem_layout.png" width="60%" height="60%"></p><p>In single-partition mode, the Color Endpoint Mode (CEM) field stores one of 16 possible values. Each of these specifies how many raw data values are encoded, and how to convert these raw values into two RGBA color endpoints. They can be summarized as follows:</p><p align="center">    <img src="/resource/cuda_astc/image/16cems.png" width="60%" height="60%"></p><p>ASTC has 16 color end point modes. To store the end points, Modes 0 to 3 use two integers, Modes 4 to 7 use four integers, Modes 7 to 11 use six integers, and Modes 12 to 15 use eight integers. In our implementation, we only support six modes: mode 0, mode 4, mode 6, mode 8, mode 10 and mode 12.</p><p>Decode the different LDR endpoint modes as follows:</p><p>1.Mode 0  LDR Luminance, direct:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">e0=(v0,v0,v0,<span class="hljs-number">0xFF</span>); <br>e1=(v1,v1,v1,<span class="hljs-number">0xFF</span>);<br></code></pre></td></tr></table></figure><p>2.Mode 4  LDR Luminance+Alpha,direct:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">e0=(v0,v0,v0,v2);<br>e1=(v1,v1,v1,v3);<br></code></pre></td></tr></table></figure><p>3.Mode 6  LDR RGB, base+scale</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">e0=(v0*v3&gt;&gt;<span class="hljs-number">8</span>,v1*v3&gt;&gt;<span class="hljs-number">8</span>,v2*v3&gt;&gt;<span class="hljs-number">8</span>, <span class="hljs-number">0xFF</span>);<br>e1=(v0,v1,v2,<span class="hljs-number">0xFF</span>);<br></code></pre></td></tr></table></figure><p>4.Mode 8  LDR RGB, Direct</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s0= v0+v2+v4; <br>s1= v1+v3+v5;<br><span class="hljs-keyword">if</span> (s1&gt;=s0)<br>&#123;<br>e0=(v0,v2,v4,<span class="hljs-number">0xFF</span>);<br>    e1=(v1,v3,v5,<span class="hljs-number">0xFF</span>); <br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123; <br>e0=<span class="hljs-built_in">blue_contract</span>(v1,v3,v5,<span class="hljs-number">0xFF</span>);<br>    e1=<span class="hljs-built_in">blue_contract</span>(v0,v2,v4,<span class="hljs-number">0xFF</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>5.Mode 10 LDR RGB, base+scale plus two A</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">e0=(v0*v3&gt;&gt;<span class="hljs-number">8</span>,v1*v3&gt;&gt;<span class="hljs-number">8</span>,v2*v3&gt;&gt;<span class="hljs-number">8</span>, v4);<br>e1=(v0,v1,v2, v5)<br></code></pre></td></tr></table></figure><p>6.Mode 12 LDR RGBA, direct</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s0= v0+v2+v4; s1= v1+v3+v5;<br><span class="hljs-keyword">if</span> (s1&gt;=s0)<br>&#123;<br>e0=(v0,v2,v4,v6);<br>    e1=(v1,v3,v5,v7); <br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>e0=<span class="hljs-built_in">blue_contract</span>(v1,v3,v5,v7);<br>    e1=<span class="hljs-built_in">blue_contract</span>(v0,v2,v4,v6); <br>&#125;<br></code></pre></td></tr></table></figure><p>Then, we estimate the error of each end point mode. Color end point modes can be classified into 3 types: luminance representation, scale representation and RGB representation. In astc-enc, the error estimation of luminance representation is the sum of the distances to vector normalize(lumi,lumin,lumin) &#x3D; float3(0.57,0.57,0.57). Scale representation error estimation is the sum of the distance to vector normalize(EndPointA + EndPointB).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">samec_rgb_lines.a = <span class="hljs-built_in">make_float4</span>(<span class="hljs-number">0</span>);<br>samec_rgb_lines.b = <span class="hljs-built_in">normalize_safe</span>(avg);<br><br><span class="hljs-type">float</span> val = <span class="hljs-number">0.577350258827209473f</span>;<br>luminance_plines.amod = <span class="hljs-built_in">make_float4</span>(<span class="hljs-number">0</span>);<br>luminance_plines.bs = <span class="hljs-built_in">make_float4</span>(val, val, val, <span class="hljs-number">0.0f</span>);<br></code></pre></td></tr></table></figure><p>Calculate and accumulate the scale and luminance error of each texel:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Compute same chroma error - no &quot;amod&quot;, its always zero</span><br>param = data_r * samec_bs0+ data_g * samec_bs1 + data_b * samec_bs2;<br><br>dist0 = (param * samec_bs0) - data_r;<br>dist1 = (param * samec_bs1) - data_g;<br>dist2 = (param * samec_bs2) - data_b;<br><br>error = dist0 * dist0 + dist1 * dist1 + dist2 * dist2;<br><br>samec_err += error;<br><br><span class="hljs-comment">// Compute luma error - no &quot;amod&quot;, its always zero</span><br>param = data_r * l_bs0 + data_g * l_bs1 + data_b * l_bs2;<br><br>dist0 = (param * l_bs0) - data_r;<br>dist1 = (param * l_bs1) - data_g;<br>dist2 = (param * l_bs2) - data_b;<br><br>error = dist0 * dist0 + dist1 * dist1 + dist2 * dist2;<br><br>l_err += error;<br></code></pre></td></tr></table></figure><p>The endpoint encoding uses 21 quant levels and 4 kinds of integer numbers, resulting in a total candidate format count of 21 * 4. For each quant level, we choose the endpoint format for each kind of integer number.</p><p>The error estimation contains six parts: baseline quant error, base quant error RGB, base quant error RGBA, scale error, luminance error, drop alpha error.</p><p>1.Baseline quant error is precomputed in a look up table and indexed by quant level.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__constant__ <span class="hljs-type">float</span> baseline_quant_error[<span class="hljs-number">21</span> - QUANT_6]&#123;<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">5</span> * <span class="hljs-number">5</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">7</span> * <span class="hljs-number">7</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">9</span> * <span class="hljs-number">9</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">11</span> * <span class="hljs-number">11</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">15</span> * <span class="hljs-number">15</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">19</span> * <span class="hljs-number">19</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">23</span> * <span class="hljs-number">23</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">31</span> * <span class="hljs-number">31</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">39</span> * <span class="hljs-number">39</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">47</span> * <span class="hljs-number">47</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">63</span> * <span class="hljs-number">63</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">79</span> * <span class="hljs-number">79</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">95</span> * <span class="hljs-number">95</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">127</span> * <span class="hljs-number">127</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">159</span> * <span class="hljs-number">159</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">191</span> * <span class="hljs-number">191</span>),<br>(<span class="hljs-number">65536.0f</span> * <span class="hljs-number">65536.0f</span> / <span class="hljs-number">18.0f</span>) / (<span class="hljs-number">255</span> * <span class="hljs-number">255</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><p>2.In our implementation, the base quant error of each channel is the same.  In astc-enc, the error of each channel can be adjusted by the user.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> base_quant_error_rgb = <span class="hljs-number">3</span> * blk.texel_count;<br><span class="hljs-type">float</span> base_quant_error_a = <span class="hljs-number">1</span> * blk.texel_count;<br><span class="hljs-type">float</span> base_quant_error_rgba = base_quant_error_rgb + base_quant_error_a;<br></code></pre></td></tr></table></figure><p>3.Scale error, luminance error and drop alpha error are computed in the previous step.</p><p>4.The final error for each endpoint format is the combination of the above errors.</p><p>Take the example of computing the error for the endpoint format encoded by 4 integers using the quant method 7.</p><p>The error of mode &lt;RGB base + scale&gt; calculation formula is as follows:<br>rgbs_alpha_error &#x3D; base quant error <strong>rgba</strong> * baseline quant error of quant method 7 + <strong>rgb scale</strong> error</p><p>The error of mode <RGB direct> calculation formula:<br>full_ldr_rgb_error &#x3D; base quant error <strong>rgb</strong> * baseline quant error of quant method 7 + <strong>alpha drop</strong> error</p><p>Select the format with the minimum error:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (rgbs_alpha_error &lt; full_ldr_rgb_error)<br>&#123;<br>best_error[i][<span class="hljs-number">2</span>] = rgbs_alpha_error;<br>format_of_choice[i][<span class="hljs-number">2</span>] = FMT_RGB_SCALE_ALPHA;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>best_error[i][<span class="hljs-number">2</span>] = full_ldr_rgb_error;<br>format_of_choice[i][<span class="hljs-number">2</span>] = FMT_RGB;<br>&#125;<br></code></pre></td></tr></table></figure><p align="center">    <img src="/resource/cuda_astc/image/cem_select.png" width="60%" height="60%"></p><h3 id="Find-The-Best-Endpoint-Quantization-Format"><a href="#Find-The-Best-Endpoint-Quantization-Format" class="headerlink" title="Find The Best Endpoint Quantization Format"></a>Find The Best Endpoint Quantization Format</h3><p>Search for all possible combinations of qunat level and color endpoint mode. We can obtain the available number of weight bits from the given block mode.  Given the number of available bits and the number of integer, we want to choose the quant level as high as possible to minimize the quantization error. It can be precomputed in a lookup table offline:</p><p align="center">    <img src="/resource/cuda_astc/image/quant_mode_table.png" width="60%" height="60%"></p><p>The best quant level can be directly accessed from the lookup table at runtime:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> quant_level = quant_mode_table[integer_count][bits_available];<br></code></pre></td></tr></table></figure><p>Store the best number of integers that has the minimum error given a block mode.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> integer_count = <span class="hljs-number">1</span>; integer_count &lt;= <span class="hljs-number">4</span>; integer_count++)<br>&#123;<br><span class="hljs-type">int</span> quant_level = quant_mode_table[integer_count][bits_available];<br><br><span class="hljs-type">float</span> integer_count_error = best_combined_error[quant_level][integer_count - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (integer_count_error &lt; best_integer_count_error)<br>&#123;<br>best_integer_count_error = integer_count_error;<br>best_integer_count = integer_count - <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>best color endpoint quant format:</p><p align="center">    <img src="/resource/cuda_astc/image/bast_color_endpoint_quant_format.png" width="75%" height="75%"></p><h2 id="Find-The-Candidate-Block-Mode"><a href="#Find-The-Candidate-Block-Mode" class="headerlink" title="Find The Candidate Block Mode"></a>Find The Candidate Block Mode</h2><p>The block mode total error is the sum of the errors that quantify the block texels weights and color endpoint.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = start_block_mode; i &lt; end_block_mode; i++)<br>&#123;<br><span class="hljs-type">float</span> total_error = error_of_best + qwt_errors[i];<br>errors_of_best_combination[i] = total_error;<br>&#125;<br></code></pre></td></tr></table></figure><p>We only compute the rough estimation error up to the current step. The next step is to compute the exact error given a block mode. We need to compress and quantify the block texels for each block mode. Since it is an expensive process, we choose four candidate block modes based on the block mode estimation error.</p><p>For each candidate block mode search iteration, find the block mode with the minimum error combining weight quant error and endpoint quant error, record the candidate block mode index:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">best_error_index</span><span class="hljs-params">(<span class="hljs-number">-1</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">best_ep_error</span><span class="hljs-params">(ERROR_CALC_DEFAULT)</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j = start_block_mode; j &lt; end_block_mode; j++)<br>&#123;<br><span class="hljs-type">float</span> err = errors_of_best_combination[j];<br><span class="hljs-type">bool</span> is_better = err &lt; best_ep_error;<br>best_ep_error = is_better ? err : best_ep_error;<br>best_error_index = is_better ? j : best_error_index;<br>&#125;<br><br>best_error_weights[i] = best_error_index;<br>errors_of_best_combination[best_error_index] = ERROR_CALC_DEFAULT;<br>&#125;<br></code></pre></td></tr></table></figure><p align="center">    <img src="/resource/cuda_astc/image/candidate_block_mode.png" width="80%" height="80%"></p><h2 id="Find-The-Actually-Best-Mode"><a href="#Find-The-Actually-Best-Mode" class="headerlink" title="Find The Actually Best Mode"></a>Find The Actually Best Mode</h2><p>Iterate over the 4 candidate block modes to find which one is actually best by quantifying the block and computing the error after unquantifying.</p><h3 id="RGB-Scale-Format-Quantification"><a href="#RGB-Scale-Format-Quantification" class="headerlink" title="RGB Scale Format Quantification"></a>RGB Scale Format Quantification</h3><p>As we quantize and decimate weights the optimal endpoint colors may change slightly, so we must recompute the ideal colors for a specific weight set.</p><p>RGB scale format contains two parts: the base endpoint and the scale factor.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">e0=(v0*v3&gt;&gt;<span class="hljs-number">8</span>,v1*v3&gt;&gt;<span class="hljs-number">8</span>,v2*v3&gt;&gt;<span class="hljs-number">8</span>, <span class="hljs-number">0xFF</span>);<br>e1=(v0,v1,v2,<span class="hljs-number">0xFF</span>);<br></code></pre></td></tr></table></figure><p>Compute the scale direction by normalizing the mean color and projecting the block texels to the scale direction. In addition, recording the min&#x2F;max scale factor.</p><p align="center">    <img src="/resource/cuda_astc/image/rgb_scale.png" width="50%" height="50%"></p><p>Compute the base color and scale factor based on the scale direction and scale maximum factor.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> scalediv = scale_min / <span class="hljs-built_in">max</span>(scale_max, <span class="hljs-number">1e-10</span>f);<br>scalediv = <span class="hljs-built_in">clamp</span>(scalediv,<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>);<br><br>float4 sds = scale_dir * scale_max;<br>rgbs_vectors = <span class="hljs-built_in">make_float4</span>(sds.x, sds.y, sds.z, scalediv);<br></code></pre></td></tr></table></figure><h3 id="Quantify-Endpoints"><a href="#Quantify-Endpoints" class="headerlink" title="Quantify Endpoints"></a>Quantify Endpoints</h3><p>Endpoint quantification is the same as interpolation weight quantification. There are only 17 possible quant levels and 255 possible values for each color channel. Therefore, the results can be stored in a precomputed table.</p><p align="center">    <img src="/resource/cuda_astc/image/color_quant_table.png" width="70%" height="70%"></p><h3 id="Error-Metric"><a href="#Error-Metric" class="headerlink" title="Error Metric"></a>Error Metric</h3><p>Given a candidate block mode, interpolate the texel color using quantized color endpoints and quantized weights. Compute the color difference and estimate the error using the squared error metric.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; texel_count; i++)<br>&#123;<br><span class="hljs-comment">// quantized weight * quantized endpoint</span><br><br><span class="hljs-type">float</span> color_error_r = <span class="hljs-built_in">fmin</span>(<span class="hljs-built_in">abs</span>(color_orig_r - color_r), <span class="hljs-built_in">float</span>(<span class="hljs-number">1e15</span>f));<br><span class="hljs-type">float</span> color_error_g = <span class="hljs-built_in">fmin</span>(<span class="hljs-built_in">abs</span>(color_orig_g - color_g), <span class="hljs-built_in">float</span>(<span class="hljs-number">1e15</span>f));<br><span class="hljs-type">float</span> color_error_b = <span class="hljs-built_in">fmin</span>(<span class="hljs-built_in">abs</span>(color_orig_b - color_b), <span class="hljs-built_in">float</span>(<span class="hljs-number">1e15</span>f));<br><span class="hljs-type">float</span> color_error_a = <span class="hljs-built_in">fmin</span>(<span class="hljs-built_in">abs</span>(color_orig_a - color_a), <span class="hljs-built_in">float</span>(<span class="hljs-number">1e15</span>f));<br><br><span class="hljs-comment">// Compute squared error metric</span><br>color_error_r = color_error_r * color_error_r;<br>color_error_g = color_error_g * color_error_g;<br>color_error_b = color_error_b * color_error_b;<br>color_error_a = color_error_a * color_error_a;<br><br><span class="hljs-type">float</span> metric = color_error_r + color_error_g + color_error_b + color_error_a;<br><br>summa += metric;<br>&#125;<br></code></pre></td></tr></table></figure><p>Find the block mode with the minimum block error.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (errorval &lt; best_errorval_in_scb)<br>&#123;<br>best_errorval_in_scb = errorval;<br>workscb.errorval = errorval;<br>scb = workscb;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Block-Encode"><a href="#Block-Encode" class="headerlink" title="Block Encode"></a>Block Encode</h2><p>Having found the best block mode with the minimum error, we can finally encode the block.</p><p>Below is a layout of the ASTC block. It contains the following parts in order: texel weight data, color endpoint data, color endpoint mode, extra data and block mode data.</p><p align="center">    <img src="/resource/cuda_astc/image/astc_block_mode_layout.png" width="85%" height="85%"></p><p>For texel weight, we scale the value based on the quant level of the best block mode. In order to improve the decoding efficiency, ASTC scrambles the order of the decoded values relative to the encoded values, which means that it must be compensated for in the encoder using a table.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">uint8_t</span> weights[<span class="hljs-number">64</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight_count; i++)<br>&#123;<br><span class="hljs-type">float</span> uqw = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(scb.weights[i]);<br><span class="hljs-type">float</span> qw = (uqw / <span class="hljs-number">64.0f</span>) * (weight_quant_levels - <span class="hljs-number">1.0f</span>);<br><span class="hljs-type">int</span> qwi = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(qw + <span class="hljs-number">0.5f</span>);<br>weights[i] = qat.scramble_map[qwi];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Once unpacked, the values must be unquantized from their storage range, returning them to a standard range of 0- 255.<br>For bit-only representations, this is simple bit replication from the most significant bit of the value.<br>For trit or quint-based representations, this involves a set of bit manipulations and adjustments to avoid the expense of full-width multipliers. This procedure ensures correct scaling, but scrambles the order of the decoded values relative to the encoded values. This must be compensated for using a table in the encoder.</p></blockquote><p>The scramble map table is precomputed:</p><p align="center">    <img src="/resource/cuda_astc/image/scramble_table.png" width="65%" height="65%"></p><p>Next, encode the integer sequence based on the Quant method. Assume that we encode the integer sequence using the Quant_80 method. Quant_80 method quantifies the integer sequence in quints form. Since 5^3 is 125, it is possible to pack three quints into 7 bits (which has 128 possible values), so a quint can be encoded as 2.33 bits. </p><p>We split the integer into higher and lower parts and pack three integers’ higher parts into seven bits. The result is precomputed and stored in a lookup table.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i2 = input_data[i + <span class="hljs-number">2</span>] &gt;&gt; bits;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i1 = input_data[i + <span class="hljs-number">1</span>] &gt;&gt; bits;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i0 = input_data[i + <span class="hljs-number">0</span>] &gt;&gt; bits;<br><br><span class="hljs-type">uint8_t</span> T = integer_of_quints[i2][i1][i0];<br></code></pre></td></tr></table></figure><p>Then, pack the result with the lower part of the integer.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Element 0</span><br>pack = (input_data[i++] &amp; mask) | (((T &gt;&gt; <span class="hljs-number">0</span>) &amp; <span class="hljs-number">0x7</span>) &lt;&lt; bits);<br><span class="hljs-built_in">write_bits</span>(pack, bits + <span class="hljs-number">3</span>, bit_offset, output_data);<br>bit_offset += bits + <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// Element 1</span><br>pack = (input_data[i++] &amp; mask) | (((T &gt;&gt; <span class="hljs-number">3</span>) &amp; <span class="hljs-number">0x3</span>) &lt;&lt; bits);<br><span class="hljs-built_in">write_bits</span>(pack, bits + <span class="hljs-number">2</span>, bit_offset, output_data);<br>bit_offset += bits + <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// Element 2</span><br>pack = (input_data[i++] &amp; mask) | (((T &gt;&gt; <span class="hljs-number">5</span>) &amp; <span class="hljs-number">0x3</span>) &lt;&lt; bits);<br><span class="hljs-built_in">write_bits</span>(pack, bits + <span class="hljs-number">2</span>, bit_offset, output_data);<br>bit_offset += bits + <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>The color endpoint packing is the same as the texel weight packing.</p><h1 id="GPU-Based-Implementation"><a href="#GPU-Based-Implementation" class="headerlink" title="GPU Based Implementation"></a>GPU Based Implementation</h1><p>There are two ways to accelerate ASTC block compression: task parallel and data parallel. The task parallel is compressing the texture block per thread.  The task parallel for ASTC block compression is heavy and uses many registers. This means that the number of active warps is low and we have low occupancy. Therefore, we can’t make full use of GPU for task parallel.  </p><p>For data parallel, we compress the ASTC block per cuda block. The GPU-based implementation references the CPU implementation. It splits the “for loop” task into each thread and shares the data between lanes by warp shuffle as possible as we can. For those data that can’t be efficiently shared by warp shuffle, we use shared memory to exchange the data.</p><h2 id="Compute-Endpoints"><a href="#Compute-Endpoints" class="headerlink" title="Compute Endpoints"></a>Compute Endpoints</h2><p>The first step is computing the best projection direction for the current block. Before this step, we load the image pixel data per thread and compute the mean pixel data by warp reduce sum operation. Then we broadcast the mean data to the whole warp.</p><p>Since the ASTC format 4x4 only has 16 texels to compress and the warp size on N-card is 32, we should mask the lanes used for block texels loading and sum operation.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> mask = __ballot_sync(<span class="hljs-number">0xFFFFFFFF</span>u, tid &lt; BLOCK_MAX_TEXELS);<br></code></pre></td></tr></table></figure><p>We use the max accumulation direction method to compute the best direction, which is the same as the CPU-based implementation. Each lane computes the offset direction relative to the mean block color. Then, we perform warp reduce to compute the sum of the offsets in the xyz direction.</p><p align="center">    <img src="/resource/cuda_astc/image/compute_avgs_and_dirs_3_comp_cuda.png" width="65%" height="65%"></p><p>If the lane ID is 0, compute and normalize the best direction based on the length of the sum of offsets in each direction.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__inline__ __device__ float3 <span class="hljs-title">compute_avgs_and_dirs_3_comp</span><span class="hljs-params">(float3 datav,float3 data_mean, <span class="hljs-type">uint32_t</span> lane_id, <span class="hljs-type">unsigned</span> mask)</span></span><br><span class="hljs-function"></span>&#123;<br>float3 safe_dir;<br>float3 texel_datum = datav - data_mean;<br><br>float3 valid_sum_xp = (texel_datum.x &gt; <span class="hljs-number">0</span> ? texel_datum : <span class="hljs-built_in">float3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>float3 valid_sum_yp = (texel_datum.y &gt; <span class="hljs-number">0</span> ? texel_datum : <span class="hljs-built_in">float3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>float3 valid_sum_zp = (texel_datum.z &gt; <span class="hljs-number">0</span> ? texel_datum : <span class="hljs-built_in">float3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br><br>float3 sum_xp = <span class="hljs-built_in">warp_reduce_vec_sum</span>(mask, valid_sum_xp);<br>float3 sum_yp = <span class="hljs-built_in">warp_reduce_vec_sum</span>(mask, valid_sum_yp);<br>float3 sum_zp = <span class="hljs-built_in">warp_reduce_vec_sum</span>(mask, valid_sum_zp);<br><br><span class="hljs-keyword">if</span> (lane_id == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-type">float</span> prod_xp = <span class="hljs-built_in">dot</span>(sum_xp, sum_xp);<br><span class="hljs-type">float</span> prod_yp = <span class="hljs-built_in">dot</span>(sum_yp, sum_yp);<br><span class="hljs-type">float</span> prod_zp = <span class="hljs-built_in">dot</span>(sum_zp, sum_zp);<br><br>float3 best_vector = sum_xp;<br><span class="hljs-type">float</span> best_sum = prod_xp;<br><br><span class="hljs-keyword">if</span> (prod_yp &gt; best_sum)<br>&#123;<br>best_vector = sum_yp;<br>best_sum = prod_yp;<br>&#125;<br><br><span class="hljs-keyword">if</span> (prod_zp &gt; best_sum)<br>&#123;<br>best_vector = sum_zp;<br>best_sum = prod_zp;<br>&#125;<br><br><span class="hljs-keyword">if</span> ((best_vector.x + best_vector.y + best_vector.z) &lt; <span class="hljs-number">0.0f</span>)<br>&#123;<br>best_vector = -best_vector;<br>&#125;<br><br><span class="hljs-type">float</span> length_dir = <span class="hljs-built_in">length</span>(best_vector);<br>safe_dir = (length_dir &lt; <span class="hljs-number">1e-10</span>) ? <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">make_float3</span>(<span class="hljs-number">1.0</span>)) : <span class="hljs-built_in">normalize</span>(best_vector);<br>&#125;<br><span class="hljs-keyword">return</span> safe_dir;<br>&#125;<br></code></pre></td></tr></table></figure><p>Compute the interpolation weight for each block texels. First, broadcast the best direction to the whole warp and project the texel data to the best direction. Then, use __shfl_xor_sync to compute the min&#x2F;max value. With the min&#x2F;max value, we can compute the scaled weight and store the result in shared memory.</p><p align="center">    <img src="/resource/cuda_astc/image/compute_ideal_colors_and_weights_4_comp.png" width="65%" height="65%"></p><h2 id="Find-The-Candidate-Block-Mode-1"><a href="#Find-The-Candidate-Block-Mode-1" class="headerlink" title="Find The Candidate Block Mode"></a>Find The Candidate Block Mode</h2><p>Our algorithm is based on the arm astc-enc implementation. However, we can’t port the astc-enc to Cuda directly. The astc-enc implementation has a large number of intermediate buffers during candidate block mode searching, which has little performance impact on CPU-based implementations, but has a significant impact on GPU-based implementations.</p><p>Here is a brief introduction to how astc-enc finds the candidate block mode:</p><p>1.Compute the quant error for each block mode and store the result and quant bits used in an intermediate buffer with the size of 2048 * (float + uint8)</p><p>2.For each block mode, compute the best combination with the candidate color quant format. This step has 3 intermediate buffers: best combination error buffer with the size of 2048xfloat, best color quant level buffer with the size of 2048xuint8, best endpoint format with the size of 2048xuint. </p><p>3.Choose 4 best candidate block mode and compute the more accurate error.</p><p>4.Compress the block using the best block mode</p><p>A lot of memory is wasted on the intermediate buffer. We have optimized this algorithm by in-place update, which removes the usage of the intermediate buffer:</p><p>1.Maintain a buffer recording the 4 candidate quant formats. </p><p>2.Iterate the block mode, compute the interpolation weight quant error, the best combination with the color quant format.</p><p>3.Compare with the candidate quant format stored in the step 1. Replace the candidate mode that has a larger error to current quant format.</p><p>4.Other steps are the same as the astc-enc implementation.</p><h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><p>Before iterating 2048 candidate block modes, we need to prepare some infomation used in block quant error computation.</p><p>The first one is the color endpoint format error for scale-based color endpoints or luminance-based color endpoints. We compute the errors for each block pixel and sum up the error by warp reduction. Then store the results in shared memory.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Luminance always goes though zero, so this is simpler than the others</span><br><span class="hljs-type">float</span> val = <span class="hljs-number">0.577350258827209473f</span>;<br>luminance_plines.amod = <span class="hljs-built_in">make_float3</span>(<span class="hljs-number">0</span>);<br>luminance_plines.bs = <span class="hljs-built_in">make_float3</span>(val, val, val);<br><br><span class="hljs-comment">// Compute uncorrelated error</span><br><span class="hljs-type">float</span> param = <span class="hljs-built_in">dot</span>(datav, uncor_rgb_plines.bs);<br>float3 dist = (uncor_rgb_plines.amod + param * uncor_rgb_plines.bs) - datav;<br><span class="hljs-type">float</span> uncor_err = <span class="hljs-built_in">dot</span>(dist, dist);<br><br><span class="hljs-comment">// Compute same chroma error - no &quot;amod&quot;, its always zero</span><br>param = <span class="hljs-built_in">dot</span>(datav, samec_rgb_plines.bs);<br>dist = param * samec_rgb_plines.bs - datav;<br><span class="hljs-type">float</span> samec_err = <span class="hljs-built_in">dot</span>(dist, dist);<br><br><span class="hljs-comment">// Compute luma error - no &quot;amod&quot;, its always zero</span><br>param = <span class="hljs-built_in">dot</span>(datav, luminance_plines.bs);<br>dist = param * luminance_plines.bs - datav;<br><span class="hljs-type">float</span> l_err = <span class="hljs-built_in">dot</span>(dist, dist);<br><br><span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>)<br>&#123;<br>shared_data_mean = data_mean;<br>shared_scale_dir = samec_rgb_lines.b;<br>&#125;<br><br>__syncwarp(mask);<br><br><span class="hljs-type">float</span> sum_uncor_err = <span class="hljs-built_in">warp_reduce_sum</span>(mask, uncor_err);<br><span class="hljs-type">float</span> sum_samec_err = <span class="hljs-built_in">warp_reduce_sum</span>(mask, samec_err);<br><span class="hljs-type">float</span> sum_l_err = <span class="hljs-built_in">warp_reduce_sum</span>(mask, l_err);<br><br><span class="hljs-keyword">if</span> (lane_id == <span class="hljs-number">0</span>)<br>&#123;<br>shared_rgb_scale_error = (sum_samec_err - sum_uncor_err) * <span class="hljs-number">0.7f</span>;<span class="hljs-comment">// empirical</span><br>shared_luminance_error = (sum_l_err - sum_uncor_err) * <span class="hljs-number">3.0f</span>;<span class="hljs-comment">// empirical</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Color endpoint has 21 quant methods and 4 kind of interger number to quant with total 21*4 possible combinations. We precomputed the result before block mode iteration. Each thread computes one error for one quant method and stores the result in shared memory.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__inline__ __device__ <span class="hljs-type">void</span> <span class="hljs-title">compute_color_error_for_every_integer_count_and_quant_level</span><span class="hljs-params">(<span class="hljs-type">const</span> block_size_descriptor* <span class="hljs-type">const</span> bsd, <span class="hljs-type">uint32_t</span> tid)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> choice_error_idx = tid;<br><span class="hljs-keyword">if</span> (choice_error_idx &gt;= QUANT_2 &amp;&amp; choice_error_idx &lt; QUANT_6)<br>&#123;<br>shared_best_error[choice_error_idx][<span class="hljs-number">3</span>] = ERROR_CALC_DEFAULT;<br>shared_best_error[choice_error_idx][<span class="hljs-number">2</span>] = ERROR_CALC_DEFAULT;<br>shared_best_error[choice_error_idx][<span class="hljs-number">1</span>] = ERROR_CALC_DEFAULT;<br>shared_best_error[choice_error_idx][<span class="hljs-number">0</span>] = ERROR_CALC_DEFAULT;<br><br>shared_format_of_choice[choice_error_idx][<span class="hljs-number">3</span>] = FMT_RGBA;<br>shared_format_of_choice[choice_error_idx][<span class="hljs-number">2</span>] = FMT_RGB;<br>shared_format_of_choice[choice_error_idx][<span class="hljs-number">1</span>] = FMT_RGB_SCALE;<br>shared_format_of_choice[choice_error_idx][<span class="hljs-number">0</span>] = FMT_LUMINANCE;<br>&#125;<br><br><span class="hljs-type">float</span> base_quant_error_rgb = <span class="hljs-number">3</span> * bsd-&gt;texel_count;<br><span class="hljs-type">float</span> base_quant_error_a = <span class="hljs-number">1</span> * bsd-&gt;texel_count;<br><span class="hljs-type">float</span> base_quant_error_rgba = base_quant_error_rgb + base_quant_error_a;<br><br><span class="hljs-keyword">if</span> (choice_error_idx &gt;= QUANT_6 &amp;&amp; choice_error_idx &lt;= QUANT_256)<br>&#123;<br><span class="hljs-type">float</span> base_quant_error = baseline_quant_error[choice_error_idx - QUANT_6];<br><span class="hljs-type">float</span> quant_error_rgb = base_quant_error_rgb * base_quant_error;<br><span class="hljs-type">float</span> quant_error_rgba = base_quant_error_rgba * base_quant_error;<br><br><span class="hljs-comment">// 8 integers can encode as RGBA+RGBA</span><br><span class="hljs-type">float</span> full_ldr_rgba_error = quant_error_rgba;<br>shared_best_error[choice_error_idx][<span class="hljs-number">3</span>] = full_ldr_rgba_error;<br>shared_format_of_choice[choice_error_idx][<span class="hljs-number">3</span>] = FMT_RGBA;<br><br><span class="hljs-comment">// 6 integers can encode as RGB+RGB or RGBS+AA</span><br><span class="hljs-type">float</span> full_ldr_rgb_error = quant_error_rgb + <span class="hljs-number">0</span>;<br><span class="hljs-type">float</span> rgbs_alpha_error = quant_error_rgba + shared_rgb_scale_error;<br><br><span class="hljs-keyword">if</span> (rgbs_alpha_error &lt; full_ldr_rgb_error)<br>&#123;<br>shared_best_error[choice_error_idx][<span class="hljs-number">2</span>] = rgbs_alpha_error;<br>shared_format_of_choice[choice_error_idx][<span class="hljs-number">2</span>] = FMT_RGB_SCALE_ALPHA;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>shared_best_error[choice_error_idx][<span class="hljs-number">2</span>] = full_ldr_rgb_error;<br>shared_format_of_choice[choice_error_idx][<span class="hljs-number">2</span>] = FMT_RGB;<br>&#125;<br><br><span class="hljs-comment">// 4 integers can encode as RGBS or LA+LA</span><br><span class="hljs-type">float</span> ldr_rgbs_error = quant_error_rgb + <span class="hljs-number">0</span> + shared_rgb_scale_error;<br><span class="hljs-type">float</span> lum_alpha_error = quant_error_rgba + shared_luminance_error;<br><br><span class="hljs-keyword">if</span> (ldr_rgbs_error &lt; lum_alpha_error)<br>&#123;<br>shared_best_error[choice_error_idx][<span class="hljs-number">1</span>] = ldr_rgbs_error;<br>shared_format_of_choice[choice_error_idx][<span class="hljs-number">1</span>] = FMT_RGB_SCALE;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>shared_best_error[choice_error_idx][<span class="hljs-number">1</span>] = lum_alpha_error;<br>shared_format_of_choice[choice_error_idx][<span class="hljs-number">1</span>] = FMT_LUMINANCE_ALPHA;<br>&#125;<br><br><span class="hljs-comment">// 2 integers can encode as L+L</span><br><span class="hljs-type">float</span> luminance_error = quant_error_rgb + <span class="hljs-number">0</span> + shared_luminance_error;<br><br>shared_best_error[choice_error_idx][<span class="hljs-number">0</span>] = luminance_error;<br>shared_format_of_choice[choice_error_idx][<span class="hljs-number">0</span>] = FMT_LUMINANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Block-Mode-Iteration"><a href="#Block-Mode-Iteration" class="headerlink" title="Block Mode Iteration"></a>Block Mode Iteration</h3><p>To make full use of the GPU, we process 2 block modes for each block mode iteration. Each processed block mode is handled by 16 threads, which is half the size of the warp. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_block_modes = bsd-&gt;block_mode_count_1plane_selected;<br><span class="hljs-type">int</span> block_mode_process_idx = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (block_mode_process_idx &lt; max_block_modes)<br>&#123;<br>__syncwarp();<br><br><span class="hljs-type">int</span> sub_block_idx = tid / <span class="hljs-number">16</span>;<br><span class="hljs-type">int</span> in_block_idx = tid % <span class="hljs-number">16</span>;<br><br><span class="hljs-type">int</span> global_idx = sub_block_idx + block_mode_process_idx; <span class="hljs-comment">// ignore the last block mode for now</span><br><span class="hljs-type">bool</span> is_block_mode_index_valid = (block_mode_process_idx + <span class="hljs-number">1</span>) &lt; max_block_modes;<br><span class="hljs-keyword">if</span> (is_block_mode_index_valid)<br>&#123;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>In the arm astc-enc implementation, weight quant errors are computed separately from color endpoint quant errors. The process generates a lot of intermediate buffers. To optimize intermediate buffer usage, we combine the separate passes together and update the total error in-place.</p><p>We compute the difference between quanted weights and unquantified weights per thread. The quant error of the block mode is computed by summing the squared texel error using warp reduction.</p><p>For each block mode, dispatch four threads to compute the combined error for four endpoint quant formats: integer number 1 to integer number 4. Then, use __shfl_xor_sync to find the best endpoint quant format with minimum error.</p><p align="center">    <img src="/resource/cuda_astc/image/blcok_mode_iteration.png" width="65%" height="65%"></p><p>We maintain a shared candidate block mode buffer with 4 actual candidate block modes and 2 block modes updated during each iteration. The last two block modes (4 + 0 and 4 + 1) are used for final GPU sorting.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (in_block_idx == <span class="hljs-number">0</span>)<br>&#123;<br>best_integer_count_error = integer_count_error;<br><br><span class="hljs-type">int</span> ql = quant_mode_table[best_integer_count + <span class="hljs-number">1</span>][bitcount];<br><br><span class="hljs-type">uint8_t</span> best_quant_level = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(ql);<br><span class="hljs-type">uint8_t</span> best_format = FMT_LUMINANCE;<br><br><span class="hljs-keyword">if</span> (ql &gt;= QUANT_6)<br>&#123;<br>best_format = shared_format_of_choice[ql][best_integer_count];<br>&#125;<br><br><span class="hljs-type">float</span> total_error = best_integer_count_error + error;<br><br>candidate_ep_format_specifiers[<span class="hljs-number">4</span> + sub_block_idx] = best_format;<br>candidate_block_mode_index[<span class="hljs-number">4</span> + sub_block_idx] = global_idx;<br>candidate_color_quant_level[<span class="hljs-number">4</span> + sub_block_idx] = ql;<br>candidate_combine_errors[<span class="hljs-number">4</span> + sub_block_idx] = total_error;<br>&#125;<br></code></pre></td></tr></table></figure><p>When current block mode iterations have been completed, perform a GPU sorting. The first four candidate block modes are used in the next pass.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (tid &lt; <span class="hljs-number">6</span>)<br>&#123;<br><span class="hljs-type">int</span> num_samller = <span class="hljs-number">0</span>;<br><span class="hljs-type">float</span> current_tid_error = candidate_combine_errors[tid];<br><span class="hljs-type">float</span> current_ep_format_specifier = candidate_ep_format_specifiers[tid];<br><span class="hljs-type">int</span> current_blk_mode_idx = candidate_block_mode_index[tid];<br><span class="hljs-type">int</span> current_col_quant_level = candidate_color_quant_level[tid];<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> candiate_idx = <span class="hljs-number">0</span>; candiate_idx &lt; <span class="hljs-number">6</span>; candiate_idx++)<br>&#123;<br><span class="hljs-type">float</span> other_candidate_error = candidate_combine_errors[candiate_idx];<br><span class="hljs-keyword">if</span> ((other_candidate_error &lt; current_tid_error) || ((other_candidate_error == current_tid_error) &amp;&amp; (candiate_idx &lt; tid)))<br>&#123;<br>num_samller++;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 0011 1111</span><br>__syncwarp(<span class="hljs-number">0x0000003F</span>);<br>candidate_combine_errors[num_samller] = current_tid_error;<br>candidate_ep_format_specifiers[num_samller] = current_ep_format_specifier;<br>candidate_block_mode_index[num_samller] = current_blk_mode_idx;<br>candidate_color_quant_level[num_samller] = current_col_quant_level;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Find-The-Best-Block-Mode"><a href="#Find-The-Best-Block-Mode" class="headerlink" title="Find The Best Block Mode"></a>Find The Best Block Mode</h2><p>We get four block mode candidates after all block mode iterations are complete. However, to accelerate block mode seraching, the candidate block modes are selected by approximate error instead of the actual difference between the original color and the compressed color. So, in the current pass, we quantify the interpolation weights and color endpoints and compute the exact difference between compressed color and original color.</p><p>The exact best block mode is stored in shared memory that will be used in the final block mode compression.</p><p align="center">    <img src="/resource/cuda_astc/image/compute_symbolic_block_difference_1plane_1partition.png" width="65%" height="65%"></p><h2 id="Compress-the-block-mode"><a href="#Compress-the-block-mode" class="headerlink" title="Compress the block mode"></a>Compress the block mode</h2><p>The final block mode compression is the same as the CPU-based implementation.</p><p>after astc compression:</p><p align="center">    <img src="/resource/cuda_astc/image/before_astc_comression.png" width="65%" height="65%"></p><p>before astc compression:</p><p align="center">    <img src="/resource/cuda_astc/image/after_astc_compression.png" width="65%" height="65%"></p><p><a href="https://github.com/ShawnTSH1229/fgac"><u><strong>GPU ASTC Compression Source Code</strong></u></a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GI Baking With Ray Guiding</title>
    <link href="/2024/06/14/GI-Baking-With-Ray-Guiding/"/>
    <url>/2024/06/14/GI-Baking-With-Ray-Guiding/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This project is part of HWRTL. HWRTL is a single file hardware ray tracing library containing GI baking, HLOD texture generation and DXR PVS generation.</p><p>Firstly, we pack the lightmaps of each mesh into a number of atlases and search for the best lightmap layout with the <strong>smallest</strong> total size. The packing algorithm uses a third-party library: <strong>stb_pack</strong>. Then, generate the <strong>lightmap gbuffer</strong> by GPU and start light map path tracing. For each texels in the light map gbuffer, we trace 512 rays from the world position recorded in the gbuffer and each tracing bounces 32 times. For each bounce, we perform a light sampling and material sampling and combine them by <strong>multi-importance sampling</strong> to reduce variance.</p><p>Furthermore, we have implemented part of the <strong>ray-guiding algorithm</strong>. First, we split the light map into <strong>clusters</strong> and each cluster shares the same luminance distribution, which can amplify the number of learning rays and reduce variance in the learned ray distribution. Then, map the ray sample direction of the first bounce into 2D, store the luminance at the corresponding position in the cluster and build the luminance distribution. After that, we build the luminance <strong>CDF</strong> in the compute shader by wave instruction. During the latter path tracing pass, we <strong>adjust the sample direction and PDF</strong> based on the ray guiding CDF.</p><p>We perform a simple <strong>dilate pass</strong> in order to solve the sampling bleed problem caused by bilinear sampling.</p><p>Unreal GPULM employs <strong>Odin</strong>(Open Image Denoise) to denoise the traced lightmap. We have implemented a custom denoising algorithm (<strong>Non-local means filtering</strong>)  to replace the Odin, since HWRTL design goal is a single file hardware raytracing library and we don’t want to involve the thirdparty.</p><h1 id="Packing"><a href="#Packing" class="headerlink" title="Packing"></a>Packing</h1><p>The diffuse lightmap UV which is usually called 2U is different from the other texture UV coordinates. Multipile meshes may share one lightmap atlas, which means we should pack their GI baking results together. </p><p>In HWRTL, the size of the mesh lightmap is specified by the user for simplicity. In practice, it’s better to calculate the lightmap size based on the triangle size in the world and UV space.</p><p>We use the exhaunst algorithm to search for the result. First, search the maximum lightmap size among the scene meshes and use this size as the primary search size.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;Vec2i&gt; giMeshLightMapSize;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> index = <span class="hljs-number">0</span>; index &lt; pGiBaker-&gt;m_giMeshes.<span class="hljs-built_in">size</span>(); index++)<br>&#123;<br>    SGIMesh&amp; giMeshDesc = pGiBaker-&gt;m_giMeshes[index];<br>    giMeshLightMapSize.<span class="hljs-built_in">push_back</span>(giMeshDesc.m_nLightMapSize);<br>    nAtlasSize.x = std::<span class="hljs-built_in">max</span>(nAtlasSize.x, giMeshDesc.m_nLightMapSize.x + <span class="hljs-number">2</span>);<br>    nAtlasSize.y = std::<span class="hljs-built_in">max</span>(nAtlasSize.y, giMeshDesc.m_nLightMapSize.y + <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-type">int</span> nextPow2 = <span class="hljs-built_in">NextPow2</span>(nAtlasSize.x);<br>nextPow2 = std::<span class="hljs-built_in">max</span>(nextPow2, <span class="hljs-built_in">NextPow2</span>(nAtlasSize.y));<br><br>nAtlasSize = <span class="hljs-built_in">Vec2i</span>(nextPow2, nextPow2);<br></code></pre></td></tr></table></figure><p>Then, iterate the light map packing size from the maximum lightmap size to the user-specified maximum atlas size. </p><p>For each iteration, try to pack them into a set of lightmap atlas using the open source library stb_rect_pack. If the total lightmap area is smaller than the minimum area computed in the previous iteration, use the current iteration lightmap layout results as the preferred layout.</p><p align="center">    <img src="/resource/gi_rayguiding/image/packing_vis.png" width="50%" height="50%"></p><p>Record the lightmap offset and scale of each mesh in the lightmap atlas texture.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> index = <span class="hljs-number">0</span>; index &lt; pGiBaker-&gt;m_giMeshes.<span class="hljs-built_in">size</span>(); index++)<br>&#123;<br>    SGIMesh&amp; giMeshDesc = pGiBaker-&gt;m_giMeshes[index];<br>    giMeshDesc.m_nAtlasOffset = <span class="hljs-built_in">Vec2i</span>(bestAtlasOffsets[index].x, bestAtlasOffsets[index].y);<br>    giMeshDesc.m_nAtlasIndex = bestAtlasOffsets[index].z;<br>    Vec2 scale = <span class="hljs-built_in">Vec2</span>(giMeshDesc.m_nLightMapSize) / <span class="hljs-built_in">Vec2</span>(bestAtlasSize);<br>    Vec2 bias = <span class="hljs-built_in">Vec2</span>(giMeshDesc.m_nAtlasOffset) / <span class="hljs-built_in">Vec2</span>(bestAtlasSize);<br>    Vec4 scaleAndBias = <span class="hljs-built_in">Vec4</span>(scale.x, scale.y, bias.x, bias.y);<br>    giMeshDesc.m_lightMapScaleAndBias = scaleAndBias;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="GBuffer-Generation"><a href="#GBuffer-Generation" class="headerlink" title="GBuffer Generation"></a>GBuffer Generation</h1><p>Generate the lightmap GBuffer for each lightmap atlas, which is GPU friendly for hardware raytracing. The pixel output destination is the texel position calculated from the lightmap UV and scale, which is located in atlas space rather than world space.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float2 lightMapCoord = IN.m_lightmapuv * m_lightMapScaleAndBias.xy + m_lightMapScaleAndBias.zw;<br>vs2PS.m_position = <span class="hljs-built_in">float4</span>((lightMapCoord - <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>)) * <span class="hljs-built_in">float2</span>(<span class="hljs-number">2.0</span>,<span class="hljs-number">-2.0</span>),<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure><p>lightmap gbuffer world position and world normal:</p><p align="center">    <img src="/resource/gi_rayguiding/image/lm_gbuffer_world_norm.png" width="30%" height="30%"></p><p align="center">    <img src="/resource/gi_rayguiding/image/lm_gbuffer_world_pos.png" width="30%" height="30%"></p><h1 id="Baking"><a href="#Baking" class="headerlink" title="Baking"></a>Baking</h1><p>Our implementation references Unreal GPU Light Mass’s implementation (<strong>GPULM</strong>). GPULM employ multi importance sampling algorithm.</p><h2 id="Multi-Importance-Sampling"><a href="#Multi-Importance-Sampling" class="headerlink" title="Multi Importance Sampling"></a>Multi Importance Sampling</h2><p>Consider the problem of evaluating direct lighting integrals of the form</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∫</mo><msup><mi>S</mi><mn>2</mn></msup></msub><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>o</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">)</mo><msub><mi>L</mi><mi>d</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>c</mi><mi>o</mi><mi>s</mi><msub><mi>θ</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">d</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_{o}(p,w_{o}) = \int_{S^{2}}f(p,w_{o},w_{i})L_{d}(p,w_{i})|cos\theta_{i}|\mathrm{d}w_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1666em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∣</span><span class="mord mathnormal">cos</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathrm">d</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br><br><p>If we were to perform importance sampling to estimate this integral according to distributions based on either Ld or fr, one of these two will often perform poorly<a href="https://pbr-book.org/3ed-2018/Monte_Carlo_Integration/Importance_Sampling"><u><strong>[PBRT-V4]</strong></u></a>. </p><p>GPULM uses two sampling distributions to estimate the value of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\int f(x)g(x)\mathrm{d}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.3061em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> in order to solve this problem. The new Monte Carlo estimator given by MIS is:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msub><mi>n</mi><mi>f</mi></msub></mfrac><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>f</mi></msub></msubsup><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>g</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo><msub><mi>w</mi><mi>f</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msub><mi>p</mi><mi>f</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mo>+</mo><mfrac><mn>1</mn><msub><mi>n</mi><mi>g</mi></msub></mfrac><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>g</mi></msub></msubsup><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>Y</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mi>g</mi><mo stretchy="false">(</mo><msub><mi>Y</mi><mi>j</mi></msub><mo stretchy="false">)</mo><msub><mi>w</mi><mi>g</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msub><mi>p</mi><mi>g</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{n_{f}}\Sigma_{i=1}^{n_{f}}\frac{f(X_{i})g(X_{i})w_{f}(X_{i})}{p_{f}(X_{i})} + \frac{1}{n_{g}}\Sigma_{j=1}^{n_{g}}\frac{f(Y_{j})g(Y_{j})w_{g}(Y_{j})}{p_{g}(Y_{j})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5862em;vertical-align:-0.5481em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2901em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5481em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8493em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2479em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2901em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0381em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2901em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0785em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5131em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0785em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0785em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0269em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2901em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0785em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5481em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.5746em;vertical-align:-0.5423em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5423em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8435em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2421em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.413em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0323em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.2222em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5073em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.2222em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.2222em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0269em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.2222em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5423em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br><br><p>Considering that our lighting sampling count of the time is equal to our BRDF sampling count of the time, the final result is:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy="false">(</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>g</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo><msub><mi>w</mi><mi>f</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msub><mi>p</mi><mi>f</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>g</mi><mo stretchy="false">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><msub><mi>w</mi><mi>g</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msub><mi>p</mi><mi>g</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{1}{n}\Sigma_{i=1}^{n}(\frac{f(X_{i})g(X_{i})w_{f}(X_{i})}{p_{f}(X_{i})} + \frac{f(Y_{i})g(Y_{i})w_{g}(Y_{i})}{p_{g}(Y_{i})})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5862em;vertical-align:-0.5481em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0381em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2901em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0785em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5131em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0785em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0785em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0269em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2901em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0785em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5481em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.5746em;vertical-align:-0.5423em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0323em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.2222em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5073em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.2222em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.2222em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0269em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.2222em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5423em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span><br><br><p>Given a sample X at a point where the value <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_{f}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>is relatively low. Assuming that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_{f}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> is a good match for the shape of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>, then the value of will also be relatively low. But suppose that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> has a relatively high value. </p><p>The standard importance sampling estimate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>p</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{f(x)g(x)}{p_{f}(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5581em;vertical-align:-0.5481em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2901em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5481em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>will have a very large value due to pf being small, and we will have high variance.</p><p>GPULM uses power heuristic weights with a power of two to reduce variance:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">MISWeightRobust</span><span class="hljs-params">(<span class="hljs-type">float</span> Pdf, <span class="hljs-type">float</span> OtherPdf)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (Pdf == OtherPdf)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0.5f</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (OtherPdf &lt; Pdf)<br>&#123;<br><span class="hljs-type">float</span> x = OtherPdf / Pdf;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / (<span class="hljs-number">1.0</span> + x * x);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-type">float</span> x = Pdf / OtherPdf;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> - <span class="hljs-number">1.0</span> / (<span class="hljs-number">1.0</span> + x * x);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Light-Map-Path-Tracing"><a href="#Light-Map-Path-Tracing" class="headerlink" title="Light Map Path Tracing"></a>Light Map Path Tracing</h2><p>Perform ray tracing for each texel in the lightmap GBuffer.</p><p>Obtain the world position and world normal from the lightmap buffer first.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 worldPosition = rtWorldPosition[rayIndex].xyz;<br>float3 worldFaceNormal = rtWorldNormal[rayIndex].xyz;<br></code></pre></td></tr></table></figure><p>Trace a ray from the world position and each ray bounce 32 time in our example.</p><p>For each bounce, we perform a light importance sampling and a material importance sampling.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> bounce = <span class="hljs-number">0</span>; bounce &lt;= maxBounces; bounce++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(bIsCameraRay)<br>    &#123;<br>        rtRaylod.m_worldPosition = worldPosition;<br>        rtRaylod.m_worldNormal = faceNormal;<br>        rtRaylod.m_vHiTt = <span class="hljs-number">1.0f</span>;<br>        rtRaylod.m_eFlag |= RT_PAYLOAD_FLAG_FRONT_FACE;<br>        rtRaylod.m_roughness = <span class="hljs-number">1.0f</span>;<br>        rtRaylod.m_baseColor = <span class="hljs-built_in">float3</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>        rtRaylod.m_diffuseColor = <span class="hljs-built_in">float3</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>        rtRaylod.m_specColor = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        rtRaylod = <span class="hljs-built_in">TraceLightRay</span>(ray,bIsLastBounce,pathThroughput,radiance);<br>    &#125;<br><br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-comment">// sampling</span><br>    <br>    <span class="hljs-comment">// step1: Sample Light, Select a [LIGHT] randomly</span><br>    <span class="hljs-keyword">if</span>(debugSample != <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (vLightPickingCdfPreSum &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">// ......</span><br>            <span class="hljs-comment">// light sampling</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// step2: Sample Material, Generate a [LIGHT DIRECTION] based on the material randomly</span><br>    <span class="hljs-keyword">if</span>(debugSample != <span class="hljs-number">2</span>)<br>    &#123;<br>        SMaterialSample materialSample = <span class="hljs-built_in">SampleMaterial</span>(rtRaylod,randomSample);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Light-Importance-Sampling"><a href="#Light-Importance-Sampling" class="headerlink" title="Light Importance Sampling"></a>Light Importance Sampling</h3><p>Generate the lighting picking cumulative distribution function first for inversion sampling method<a href="https://pbr-book.org/4ed/Monte_Carlo_Integration/Sampling_Using_the_Inversion_Method"><u><strong>[PBRT-V4]</strong></u></a>.</p><p>we can draw a sample <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_{i}  </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> from a PDF p(x) with the following steps:</p><p>1.Integrate the PDF  to find the CDF <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi>x</mi></msubsup><mi>p</mi><mo stretchy="false">(</mo><msup><mi>x</mi><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><msup><mi>x</mi><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">P(x) = \int_{0}^{x}p(x^{&#x27;})\mathrm{d}x^{&#x27;}  </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2983em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8593em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9425em;"><span style="top:-2.9425em;margin-right:0.05em;"><span class="pstrut" style="height:2.5795em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9425em;"><span style="top:-2.9425em;margin-right:0.05em;"><span class="pstrut" style="height:2.5795em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>. For discrete case, the result is: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup><mi>p</mi><mo stretchy="false">(</mo><mi>l</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x) = \sum_{i=0}^{n}p(light_{i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.104em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(uint index = <span class="hljs-number">0</span>; index &lt; m_nRtSceneLightCount; index++)<br>&#123;<br>    vLightPickingCdfPreSum += <span class="hljs-built_in">EstimateLight</span>(index,worldPosition,worldNormal);<br>    aLightPickingCdf[index] = vLightPickingCdfPreSum;<br>&#125;<br></code></pre></td></tr></table></figure><p>Estimate the light PDF for each light source in the scene:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetLightFallof</span><span class="hljs-params">(<span class="hljs-type">float</span> vSquaredDistance,<span class="hljs-type">int</span> nLightIndex)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> invLightAttenuation = <span class="hljs-number">1.0</span> / rtSceneLights[nLightIndex].m_vAttenuation;<br>    <span class="hljs-type">float</span> normalizedSquaredDistance = vSquaredDistance * invLightAttenuation * invLightAttenuation;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">saturate</span>(<span class="hljs-number">1.0</span> - normalizedSquaredDistance) * <span class="hljs-built_in">saturate</span>(<span class="hljs-number">1.0</span> - normalizedSquaredDistance);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">EstimateDirectionalLight</span><span class="hljs-params">(uint nlightIndex)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Luminance</span>(rtSceneLights[nlightIndex].m_color);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">EstimateSphereLight</span><span class="hljs-params">(uint nlightIndex,float3 worldPosition)</span></span><br><span class="hljs-function"></span>&#123;<br>    float3 lightDirection = <span class="hljs-built_in">float3</span>(rtSceneLights[nlightIndex].m_worldPosition - worldPosition);<br>    <span class="hljs-type">float</span> squaredLightDistance = <span class="hljs-built_in">dot</span>(lightDirection,lightDirection);<br>    <span class="hljs-type">float</span> lightPower = <span class="hljs-built_in">Luminance</span>(rtSceneLights[nlightIndex].m_color);<br><br>    <span class="hljs-keyword">return</span> lightPower * <span class="hljs-built_in">GetLightFallof</span>(squaredLightDistance,nlightIndex) / squaredLightDistance;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">EstimateLight</span><span class="hljs-params">(uint nlightIndex, float3 worldPosition,float3 worldNormal)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span>(rtSceneLights[nlightIndex].m_eLightType)<br>    &#123;<br>        <span class="hljs-keyword">case</span> RT_LIGHT_TYPE_DIRECTIONAL: <span class="hljs-keyword">return</span> <span class="hljs-built_in">EstimateDirectionalLight</span>(nlightIndex);<br>        <span class="hljs-keyword">case</span> RT_LIGHT_TYPE_SPHERE: <span class="hljs-keyword">return</span> <span class="hljs-built_in">EstimateSphereLight</span>(nlightIndex,worldPosition);<br>        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.Obtain a uniformly distributed random number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ξ</mi></mrow><annotation encoding="application/x-tex">\xi  </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.04601em;">ξ</span></span></span></span>.<br>3.Generate a sample <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ξ</mi><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\xi = P(X) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.04601em;">ξ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>by solving  for X; in other words, find <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><msup><mi>P</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>ξ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X = P^{-1}(\xi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04601em;">ξ</span><span class="mclose">)</span></span></span></span>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SelectLight</span><span class="hljs-params">(<span class="hljs-type">float</span> vRandom, <span class="hljs-type">int</span> nLights, inout <span class="hljs-type">float</span> aLightPickingCdf[RT_MAX_SCENE_LIGHT], out uint nSelectedIndex, out <span class="hljs-type">float</span> vLightPickPdf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> preCdf = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(nSelectedIndex = <span class="hljs-number">0</span>; nSelectedIndex &lt; nLights;nSelectedIndex++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(vRandom &lt; aLightPickingCdf[nSelectedIndex])<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        preCdf = aLightPickingCdf[nSelectedIndex];<br>    &#125;<br><br>    vLightPickPdf = aLightPickingCdf[nSelectedIndex] - preCdf;<br>&#125;<br></code></pre></td></tr></table></figure><p>Compute the direct lighting result of the sample.</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∫</mo><msup><mi>S</mi><mn>2</mn></msup></msub><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>o</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">)</mo><msub><mi>L</mi><mi>d</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>V</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>c</mi><mi>o</mi><mi>s</mi><msub><mi>θ</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">d</mi><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_{o}(p,w_{o}) = \int_{S^{2}}f(p,w_{o},w_{i})L_{d}(p,w_{i})Vis(p,w_{i})|cos\theta_{i}|\mathrm{d}w_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1666em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">Vi</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∣</span><span class="mord mathnormal">cos</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathrm">d</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br><br><p>1.Sample the light based on the type of light sample selected before.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SLightSample <span class="hljs-title">SampleLight</span><span class="hljs-params">(<span class="hljs-type">int</span> nLightIndex,float2 vRandSample,float3 vWorldPos,float3 vWorldNormal)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span>(rtSceneLights[nLightIndex].m_eLightType)<br>    &#123;<br>        <span class="hljs-keyword">case</span> RT_LIGHT_TYPE_DIRECTIONAL: <span class="hljs-keyword">return</span> <span class="hljs-built_in">SampleDirectionalLight</span>(nLightIndex,vRandSample,vWorldPos,vWorldNormal);<br>        <span class="hljs-keyword">case</span> RT_LIGHT_TYPE_SPHERE: <span class="hljs-keyword">return</span> <span class="hljs-built_in">SampleSphereLight</span>(nLightIndex,vRandSample,vWorldPos,vWorldNormal);<br>        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> (SLightSample)<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.Compute the visibility term by tracing a shadow ray from the hit position to the light sample position.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// trace a visibility ray</span><br>&#123;<br>    SMaterialClosestHitPayload shadowRayPaylod = (SMaterialClosestHitPayload)<span class="hljs-number">0</span>;<br>    <br>    RayDesc shadowRay;<br>    shadowRay.Origin = worldPosition;<br>    shadowRay.TMin = <span class="hljs-number">0.0f</span>;<br>    shadowRay.Direction = lightSample.m_direction;<br>    shadowRay.TMax = lightSample.m_distance;<br>    shadowRay.Origin += <span class="hljs-built_in">abs</span>(worldPosition) * <span class="hljs-number">0.001f</span> * worldNormal;<br><br>    <span class="hljs-built_in">TraceRay</span>(rtScene, RAY_FLAG_FORCE_OPAQUE, RAY_TRACING_MASK_OPAQUE, RT_SHADOW_SHADER_INDEX, <span class="hljs-number">1</span>,<span class="hljs-number">0</span>, shadowRay, shadowRayPaylod);<br>    <br>    <span class="hljs-type">float</span> sampleContribution = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">if</span>(shadowRayPaylod.m_vHiTt &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        sampleContribution = <span class="hljs-number">1.0</span>;<br>    &#125;<br>    lightSample.m_radianceOverPdf *= sampleContribution;<br>&#125;<br></code></pre></td></tr></table></figure><p>The ray bias calculation mathod is based on the <a href="https://ndotl.wordpress.com/2018/08/29/baking-artifact-free-lightmaps/"><u><strong>[Bakery LightMap Baker]</strong></u></a>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">shadowRay.Origin += <span class="hljs-built_in">abs</span>(worldPosition) * <span class="hljs-number">0.001f</span> * worldNormal;<br></code></pre></td></tr></table></figure><p>3.Compute the BRDF term. GPULM uses simple <strong>Lambertian</strong> BRDF to calculate diffuse reflection and combines it with multi-importance sampling.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">any</span>(lightSample.m_radianceOverPdf &gt; <span class="hljs-number">0</span>))<br>&#123;   <br>    SMaterialEval materialEval = <span class="hljs-built_in">EvalMaterial</span>(lightSample.m_direction,rtRaylod);<br>    float3 lightContrib = pathThroughput * lightSample.m_radianceOverPdf * materialEval.m_weight * materialEval.m_pdf;<br><br>    lightContrib *= <span class="hljs-built_in">MISWeightRobust</span>(lightSample.m_pdf,materialEval.m_pdf);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Material-Importance-Sampling"><a href="#Material-Importance-Sampling" class="headerlink" title="Material Importance Sampling"></a>Material Importance Sampling</h3><p>1.Sample cosine-weighted hemisphere to compute wi and pdf:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SMaterialSample <span class="hljs-title">SampleLambertMaterial</span><span class="hljs-params">(SMaterialClosestHitPayload payload, float4 randomSample)</span></span><br><span class="hljs-function"></span>&#123;<br>    float3 worldNormal = payload.m_worldNormal;<br>    float4 sampleValue = <span class="hljs-built_in">CosineSampleHemisphere</span>(randomSample.xy);<br><br>    SMaterialSample materialSample = (SMaterialSample)<span class="hljs-number">0</span>;<br>    materialSample.m_direction = <span class="hljs-built_in">TangentToWorld</span>(sampleValue.xyz,worldNormal);<br>    materialSample.m_pdf = sampleValue.w;<br>    <span class="hljs-keyword">return</span> materialSample;<br>&#125;<br></code></pre></td></tr></table></figure><p>Assign the ray direction to the new generated ray direction that will be used in the next bounce.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ray.Direction = <span class="hljs-built_in">normalize</span>(materialSample.m_direction);<br></code></pre></td></tr></table></figure><p>2.Calculate the incident radiance in the ray direction and trace a shadow ray to compute the visibility term by hardware raytracing.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(uint index = <span class="hljs-number">0</span>; index &lt; m_nRtSceneLightCount; index++)<br>&#123;<br>    SLightTraceResult lightTraceResult = <span class="hljs-built_in">TraceLight</span>(ray,index);<br><br>    <span class="hljs-comment">// ......</span><br><br>    RayDesc shadowRay = ray;<br>    shadowRay.TMax = lightTraceResult.m_hitT;<br>    <span class="hljs-built_in">TraceRay</span>(rtScene, RAY_FLAG_FORCE_OPAQUE, RAY_TRACING_MASK_OPAQUE, RT_SHADOW_SHADER_INDEX, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, shadowRay, shadowRayPaylod);<br>    <span class="hljs-keyword">if</span>(shadowRayPaylod.m_vHiTt &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        lightContribution = <span class="hljs-number">0.0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ......</span><br><br>    radiance += lightContribution;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.Combine the result with a multi-importance sampling weight.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> previousCdfValue = index &gt; <span class="hljs-number">0</span> ? aLightPickingCdf[index - <span class="hljs-number">1</span>] : <span class="hljs-number">0.0</span>;<br><span class="hljs-type">float</span> lightPickPdf = (aLightPickingCdf[index] - previousCdfValue) / vLightPickingCdfPreSum;<br><br>lightContribution *= <span class="hljs-built_in">MISWeightRobust</span>(materialSample.m_pdf,lightPickPdf * lightTraceResult.m_pdf);<br></code></pre></td></tr></table></figure><h2 id="Store-The-Trace-Result"><a href="#Store-The-Trace-Result" class="headerlink" title="Store The Trace Result"></a>Store The Trace Result</h2><p>Store the direct lighting result (bounce &#x3D;&#x3D; 0) and the indirect lighting result together and accumulate the valid sample count. What’s more, project the lighting luminance into the directionality SH. We will detail this store format in the latter “LightMap Encoding” part.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>    <span class="hljs-type">float</span> TangentZ = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(directLightRadianceDirection, worldFaceNormal));<br>    <span class="hljs-keyword">if</span>(TangentZ &gt; <span class="hljs-number">0.0</span>)<br>    &#123;<br>        shDirectionality[rayIndex].rgba += <span class="hljs-built_in">Luminance</span>(directLightRadianceValue) * <span class="hljs-built_in">SHBasisFunction</span>(directLightRadianceDirection);<br>    &#125;<br>    irradianceAndValidSampleCount[rayIndex].rgb += directLightRadianceValue;<br>&#125;<br><br>&#123;<br>    <span class="hljs-type">float</span> TangentZ = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(radianceDirection, worldFaceNormal));<br>    <span class="hljs-keyword">if</span>(TangentZ &gt; <span class="hljs-number">0.0</span>)<br>    &#123;<br>        shDirectionality[rayIndex].rgba += <span class="hljs-built_in">Luminance</span>(radianceValue) * <span class="hljs-built_in">SHBasisFunction</span>(radianceDirection);<br>    &#125;<br>    irradianceAndValidSampleCount[rayIndex].rgb += radianceValue;            <br>&#125;<br><br>irradianceAndValidSampleCount[rayIndex].w += <span class="hljs-number">1.0</span>;<br></code></pre></td></tr></table></figure><p>irradiance and count:</p><p align="center">    <img src="/resource/gi_rayguiding/image/irradiance_and_count.png" width="30%" height="30%"></p><p>directionality SH:</p><p align="center">    <img src="/resource/gi_rayguiding/image/directionality.png" width="30%" height="30%"></p><h1 id="First-Bounce-Ray-Guiding-WIP"><a href="#First-Bounce-Ray-Guiding-WIP" class="headerlink" title="First Bounce Ray Guiding (WIP)"></a>First Bounce Ray Guiding (WIP)</h1><blockquote><p>Note that ray guiding is disabled by default in our sample scene, since it still has some bugs.</p></blockquote><p>Unreal GPULM has implemented a new algorithm called “first bounce ray guiding”, which is similar to <a href="https://arisilvennoinen.github.io/Publications/ray_guiding_For_production_lightmap_baking_author_version.pdf"><u><strong>[Ray Guiding For COD]</strong></u></a>.</p><h2 id="Path-Guiding"><a href="#Path-Guiding" class="headerlink" title="Path Guiding"></a>Path Guiding</h2><p>A brief introduction to ralated algorithm (Path Guiding) referenced from Ray Guiding For COD:</p><blockquote><p>To improve the convergence of MC estimators, there has been a recent surge of work related to path guiding. The key idea is to collect samples of light transport and learn a probability distribution for importance sampling. Unlike analytical importance sampling methods, the guiding process is usually &gt;designed in a way that it can take into account the light modulated <strong>visibility term</strong>, which is often impractical to tackle analytically in a closed form. </p></blockquote><h2 id="Ray-Guiding-Introduction"><a href="#Ray-Guiding-Introduction" class="headerlink" title="Ray Guiding Introduction"></a>Ray Guiding Introduction</h2><p>As we mentioned above, the single BRDF importance sampling estimate will have a large value due to p(f) being small. So we add additional light importance sampling with MIS:</p><blockquote><p>The standard importance sampling estimate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>p</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{f(x)g(x)}{p_{f}(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5581em;vertical-align:-0.5481em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2901em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5481em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>will have a very large value due to p(f) being small, and we will have high variance.</p></blockquote><p>However, estimate lighting distribution is difficult. It’s hard to deal with the visibility term unless you trace a visibility ray and compute the intersection with the scene, which is expensive for GI Baker. Furthermore, it’s difficult to deal with secondary light sources.</p><p>Ray guiding in COD and Unreal GPULM runs in fixed memory footprint, independent of scene complexity. In addition, they are able to combine information from all the learning samples, leading to a more efficient estimator with reduced variance.</p><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>We have implemented part of the ray guiding algorithm. It contains four parts: clustering texels, building the guiding distribution, filtering the learned distribution and adjusting the sample PDF and direction.</p><p>We accumulate radiance in all directions during the first 128 light map pass tracing. Then, filter and build the ray guiding distribution based on the cluster radiance distribution. After that, adjust the sampling PDF and direction in the latter light map path tracing.</p><p align="center">    <img src="/resource/gi_rayguiding/image/ray_guiding_flow.png" width="50%" height="50%"></p><h3 id="Clustering-Texels"><a href="#Clustering-Texels" class="headerlink" title="Clustering Texels"></a>Clustering Texels</h3><h4 id="Concentric-Mapping"><a href="#Concentric-Mapping" class="headerlink" title="Concentric Mapping"></a>Concentric Mapping</h4><p>At first, we generate the sample direction based on concentric mapping. Since the concentric mapping is an equal-area mapping, the PDF p(x,y) is constant, which allows us to sample uniformly with respect to area. Furthermore, we can perform inverse concentric mapping to map the sample direction into the 2D position in which the radiance result is stored to be used in the construction of the ray guiding distribution.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float2 samplePoint = randomSample.yx;<br>float4 sampledValue = <span class="hljs-built_in">CosineSampleHemisphereConcentric</span>(samplePoint);<br>float3 outDirection = <span class="hljs-built_in">TangentToWorld</span>(sampledValue.xyz, N_World);<br><br>SMaterialSample materialSample = (SMaterialSample)<span class="hljs-number">0</span>;<br>materialSample.m_direction = outDirection;<br>materialSample.m_pdf = outPdf;<br></code></pre></td></tr></table></figure><p align="center">    <img src="/resource/gi_rayguiding/image/concentric_map.png" width="70%" height="70%"></p><p>We only perform concentric mapping on the first bounce.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SMaterialSample materialSample;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_FIRST_BOUNCE_RAY_GUIDING == 1</span><br><span class="hljs-keyword">if</span>(bounce == <span class="hljs-number">0</span>)<br>&#123;<br>    materialSample = <span class="hljs-built_in">SampleMaterial_RayGuiding</span>(rtRaylod,randomSample,dispatch_thread_idx);<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#123;<br>    materialSample  = <span class="hljs-built_in">SampleMaterial</span>(rtRaylod,randomSample);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Cluster-Texels"><a href="#Cluster-Texels" class="headerlink" title="Cluster Texels"></a>Cluster Texels</h4><blockquote><p>To reduce variance in the learned ray distribution, we amplify the number of learning rays used to construct the PDF by sharing the PDF between clusters of spatially and geometrically coherent texels.<br>—— ray guiding for cod</p></blockquote><p>In our example, every 8*8 pixels in the lightmap gbuffer share one cluster. The cluster size is 16 * 16, which corresponds to 256 sampling directions. The stored position in the cluster tile is a random sampling position before concentric mapping.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> minRenderPassIndex = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> maxRenderPassIndex = RAY_GUDING_MAX_SAMPLES;<br><br><span class="hljs-keyword">if</span>(( rtRenderPassInfo.m_renderPassIndex &gt;= minRenderPassIndex) &amp;&amp; (rtRenderPassInfo.m_renderPassIndex &lt; maxRenderPassIndex))<br>&#123;<br>    float2 Point = primaryRandSample.yx;<br>    float2 jittered_bin = Point * DIRECTIONAL_BINS_ONE_DIM;<br>    int2 position_in_bin = <span class="hljs-built_in">clamp</span>(jittered_bin, <span class="hljs-built_in">float2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">float2</span>(DIRECTIONAL_BINS_ONE_DIM - <span class="hljs-number">1</span>, DIRECTIONAL_BINS_ONE_DIM - <span class="hljs-number">1</span>));<br>    int2 final_position = ((rayIndex.xy / TEXEL_CLUSTER_SIZE)* DIRECTIONAL_BINS_ONE_DIM) + position_in_bin;<br><br>    <span class="hljs-type">float</span> illuminance = luminance_first_bounce_ray_guiding * <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(radianceDirection, worldFaceNormal));<br>    <span class="hljs-built_in">InterlockedMax</span>(rayGuidingLuminance[final_position], <span class="hljs-built_in">asuint</span>(<span class="hljs-built_in">max</span>(illuminance, <span class="hljs-number">0</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><p>We store the maximum luminance for each direction using InterlockedMax. For positive floats we can cast them to uint and use atomic max directly.</p><p align="center">    <img src="/resource/gi_rayguiding/image/cluster_texels.png" width="70%" height="70%"></p><p>radiance distribution:</p><p align="center">    <img src="/resource/gi_rayguiding/image/radiance_distribution.png" width="50%" height="50%"></p><h3 id="Building-Filtering-the-Guiding-Distribution"><a href="#Building-Filtering-the-Guiding-Distribution" class="headerlink" title="Building &amp; Filtering the Guiding Distribution"></a>Building &amp; Filtering the Guiding Distribution</h3><h4 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h4><blockquote><p>Even though we share all the texel samples within each cluster to learn the PDF, there is a risk of overfitting to the samples that can lead to slower convergence if the learned PDF does not reflect the population distribution well enough. To mitigate this effect, we apply a relaxation step by running a hierarchical smoothing filter over the quadtree representation of the guide distribution<br>—— ray guiding for cod</p></blockquote><p>Filter the radiance results around the current pixel:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> value = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> filterKernelSize = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> dx = -filterKernelSize; dx &lt;= filterKernelSize; dx++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> dy = -filterKernelSize; dy &lt;= filterKernelSize; dy++)<br>&#123;<br>        int2 final_pos = <span class="hljs-built_in">clamp</span>(grp_idx.xy *  DIRECTIONAL_BINS_ONE_DIM + thread_idx.xy + <span class="hljs-built_in">int2</span>(dx, dy), pixel_min_pos, pixel_max_pos);<br>        value += <span class="hljs-built_in">asfloat</span>(rayGuidingLuminanceBuildSrc[final_pos]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Building-Ray-Guiding-CDF"><a href="#Building-Ray-Guiding-CDF" class="headerlink" title="Building Ray Guiding CDF"></a>Building Ray Guiding CDF</h4><p>Build the CDF for each cluster. Compute the prefix sum per row using the WavePrefixSum operation. Then, obtain the sum of the row by using WaveReadLaneAt. It should be noticed that the compute group row size <strong>MUST</strong> be aligned to the warp size. Finally, calculate the normalized result based on the row sum.</p><p align="center">    <img src="/resource/gi_rayguiding/image/ray_guiding_cdfx.png" width="60%" height="60%"></p><p>The result computed above is ray guiding CDF in x dimension. We will compute the ray guiding CDF in y dimension next. Store the sum value for each row in the shared group during CDF X computation. Then, execute WaveReadLaneAt and WavePrefixSum to compute the CDF in the Y dimension.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (thread_idx.y == <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span> (thread_idx.x &lt; DIRECTIONAL_BINS_ONE_DIM)<br>    &#123;<br>    <span class="hljs-type">float</span> value = RowSum[thread_idx.x];<br>    <span class="hljs-type">float</span> prefixSum = <span class="hljs-built_in">WavePrefixSum</span>(value) + value;<br>        <span class="hljs-type">float</span> sum = <span class="hljs-built_in">WaveReadLaneAt</span>(prefixSum, DIRECTIONAL_BINS_ONE_DIM - <span class="hljs-number">1</span>);<br><br>    int2 writePos = <span class="hljs-built_in">int2</span>(thread_idx.x % (DIRECTIONAL_BINS_ONE_DIM / <span class="hljs-number">4</span>), thread_idx.x / (DIRECTIONAL_BINS_ONE_DIM/ <span class="hljs-number">4</span> ));<br>        int2 final_pos = grp_idx.xy * <span class="hljs-built_in">uint2</span>(DIRECTIONAL_BINS_ONE_DIM / <span class="hljs-number">4</span>,DIRECTIONAL_BINS_ONE_DIM / <span class="hljs-number">4</span>) + writePos;<br><br>        <span class="hljs-type">float</span> result = (sum == <span class="hljs-number">0.0f</span>) ? <span class="hljs-number">0.0</span> : (prefixSum / sum);<br>    rayGuidingCDFYBuildDest[final_pos] = result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Ray Guiding CDF X:</p><p align="center">    <img src="/resource/gi_rayguiding/image/CDFX.png" width="40%" height="40%"></p><p>Ray Guiding CDF Y:</p><p align="center">    <img src="/resource/gi_rayguiding/image/CDFY.png" width="40%" height="40%"></p><h3 id="Adjust-the-PDF"><a href="#Adjust-the-PDF" class="headerlink" title="Adjust the PDF"></a>Adjust the PDF</h3><p>Adjust the PDF based on the ray guiding CDF x and y. Amplify the PDF if the luminance in the current direction contribute greatly to the final result.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(rtRenderPassInfo.m_renderPassIndex &gt;= RAY_GUDING_MAX_SAMPLES)<br>&#123;<br>    <span class="hljs-type">float</span> lastRowPrefixSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">float</span> rowPrefixSum;<br>    <span class="hljs-type">int</span> y = <span class="hljs-built_in">floor</span>(primarySample.y * DIRECTIONAL_BINS_ONE_DIM);<br><br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-comment">// compute lastRowPrefixSum and rowPrefixSum</span><br>    pdfAdjust *= ((rowPrefixSum - lastRowPrefixSum) * DIRECTIONAL_BINS_ONE_DIM);<br><br>    <span class="hljs-type">float</span> lastPrefixSum = <span class="hljs-number">0</span>;<br><span class="hljs-type">float</span> prefixSum;<br>    <span class="hljs-type">int</span> x = <span class="hljs-built_in">floor</span>(primarySample.x * DIRECTIONAL_BINS_ONE_DIM);<br><br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-comment">// compute lastPrefixSum and prefixSum</span><br><br>    pdfAdjust *= ((prefixSum - lastPrefixSum) * DIRECTIONAL_BINS_ONE_DIM);<br>&#125;<br><br><span class="hljs-type">float</span> out_pdf = ((NoL / PI) * pdfAdjust);<br></code></pre></td></tr></table></figure><p>Adjust the sampling direction based on the radiance CDF during material importance sampling.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(rtRenderPassInfo.m_renderPassIndex &gt;= RAY_GUDING_MAX_SAMPLES)<br>&#123;<br>    <span class="hljs-type">float</span> lastRowPrefixSum = <span class="hljs-number">0</span>;<br><span class="hljs-type">float</span> rowPrefixSum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-comment">// compute the rowPrefixSum and lastRowPrefixSum</span><br>    samplePoint.y = <span class="hljs-built_in">float</span>(y + (samplePoint.y - lastRowPrefixSum) / (rowPrefixSum - lastRowPrefixSum)) / DIRECTIONAL_BINS_ONE_DIM;<br><br>    <span class="hljs-type">float</span> prefixSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">float</span> lastPrefixSum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-comment">// compute the prefixSum and lastPrefixSum</span><br>    samplePoint.x = <span class="hljs-built_in">float</span>(x + (samplePoint.x - lastPrefixSum) / (prefixSum - lastPrefixSum)) / DIRECTIONAL_BINS_ONE_DIM;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Dilate"><a href="#Dilate" class="headerlink" title="Dilate"></a>Dilate</h1><p>Because of bilinear interpolation and typical non-conservative rasterization, the sampling texels may blend with the background lightmap color. Furthermore, we may sample the texels that don’t belong to the current mesh’s light map since multiple meshes may share one lightmap atlas.</p><p>In our example, we solve this problem by expanding the lightmap with some padding board texels. Then, dilate the lightmap path tracing result. There is still a lot of work to be done on this simple implementation.</p><p align="center">    <img src="/resource/gi_rayguiding/image/dilate.png" width="100%" height="100%"></p><h1 id="Denoise"><a href="#Denoise" class="headerlink" title="Denoise"></a>Denoise</h1><p>Unreal GPULM employs Odin(Open Image Denoise) to denoise the traced lightmap. We have implemented a custom denoising algorithm to replace the Odin, since HWRTL design goal is a single file hardware raytracing library and we don’t want to involve the thirdparty.</p><p>Our algorithm is based on <a href="https://www.cs.umd.edu/~zwicker/publications/AdaptiveRenderingNLM-SIGA12.pdf"><u><strong>Non-Local Means filtering</strong></u></a> combined with Joint Filtering.</p><h2 id="Bilateral-Filtering"><a href="#Bilateral-Filtering" class="headerlink" title="Bilateral Filtering"></a>Bilateral Filtering</h2><blockquote><p>A bilateral filter is a non-linear, edge-preserving, and noise-reducing smoothing filter for images. It replaces the intensity of each pixel with a weighted average of intensity values from nearby pixels. This weight can be based on a Gaussian distribution. Crucially, the weights depend not only on Euclidean distance of pixels, but also on the radiometric differences (e.g., range differences, such as color intensity, depth distance, etc.). This preserves sharp edges<br>——From Wikipedia</p></blockquote><p>The bilateral filter is defined as:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi>b</mi><mi>f</mi></mrow></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mfrac><mrow><mo>−</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>q</mi><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow><mrow><mn>2</mn><msubsup><mi>σ</mi><mi>s</mi><mn>2</mn></msubsup></mrow></mfrac><mo stretchy="false">)</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mfrac><mrow><mo>−</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>c</mi><mi>p</mi></msub><mo>−</mo><msub><mi>c</mi><mi>q</mi></msub><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow><mrow><mn>2</mn><msubsup><mi>σ</mi><mi>r</mi><mn>2</mn></msubsup></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w_{bf}(p,q)=exp(\frac{-||p-q||^{2}}{2\sigma^{2}_{s}})exp(\frac{-||c_{p}-c_{q}||^{2}}{2\sigma^{2}_{r}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.6764em;vertical-align:-0.5452em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1089em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.214em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mtight">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5452em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1312em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.214em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5073em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∣∣</span><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mtight">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5452em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span><br><br><p>A key issue with the bilateral filter, however, is that the range-distance estimation can be sensitive to noise.</p><h2 id="Non-Local-Means"><a href="#Non-Local-Means" class="headerlink" title="Non-Local Means"></a>Non-Local Means</h2><p>The non-local means (NL-Means) filter is a generalization of the bilateral filter where the range distance is computed using small patches <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>around the pixels <a href="https://benedikt-bitterli.me/nfor/nfor.pdf"><u><strong>(NFOR)</strong></u></a>:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi>n</mi><mi>l</mi><mi>m</mi></mrow></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mfrac><mrow><mo>−</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>q</mi><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow><mrow><mn>2</mn><msubsup><mi>σ</mi><mi>s</mi><mn>2</mn></msubsup></mrow></mfrac><mo stretchy="false">)</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mfrac><mrow><mo>−</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>P</mi><mi>p</mi></msub><mo>−</mo><msub><mi>P</mi><mi>q</mi></msub><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow><mrow><msup><mi>k</mi><mn>2</mn></msup><mn>2</mn><msubsup><mi>σ</mi><mi>r</mi><mn>2</mn></msubsup></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w_{nlm}(p,q)=exp(\frac{-||p-q||^{2}}{2\sigma^{2}_{s}})exp(\frac{-||P_{p}-P_{q}||^{2}}{k^{2}2\sigma^{2}_{r}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.6764em;vertical-align:-0.5452em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1089em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.214em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mtight">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5452em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1312em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.214em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5073em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∣∣</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mtight">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5452em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span><br><br><p>where k is a user parameter controlling the strength of the filter. The squared patch-based range distance is defined as:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>P</mi><mi>p</mi></msub><mo>−</mo><msub><mi>P</mi><mi>q</mi></msub><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi>P</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><msub><mo>∑</mo><mrow><mi>n</mi><mo>∈</mo><msub><mi>P</mi><mn>0</mn></msub></mrow></msub><mi>d</mi><mo stretchy="false">(</mo><mi>p</mi><mo>+</mo><mi>n</mi><mo separator="true">,</mo><mi>q</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">||P_{p}-P_{q}||^{2}=max(0,\frac{1}{|P|}\sum_{n \in P_{0}}d(p+n,q+n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord">∣∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1002em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3651em;vertical-align:-0.52em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3998em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span><br><br><p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">P_{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> is a square patch of size |P| (usually 7 x 7 pixels) centered on p, and P0 enumerates the offsets to the pixels within a patch. </p><h2 id="Joint-Filtering"><a href="#Joint-Filtering" class="headerlink" title="Joint Filtering"></a>Joint Filtering</h2><p>If additional per-pixel information is available, the quality of bilateral or NL-Means filtering can be further improved by factoring the information into the weight-the so-called joint filtering<a href="https://benedikt-bitterli.me/nfor/nfor.pdf"><u><strong>(NFOR)</strong></u></a>:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi>j</mi><mi>n</mi><mi>l</mi><mi>m</mi></mrow></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>w</mi><mrow><mi>n</mi><mi>l</mi><mi>m</mi></mrow></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>w</mi><mrow><mi>a</mi><mi>u</mi><mi>x</mi></mrow></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w_{jnlm}(p,q)=w_{nlm}(p,q)*w_{aux}(p,q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">jn</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">ux</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span><p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi>a</mi><mi>u</mi><mi>x</mi></mrow></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w_{aux}(p,q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">ux</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span> is a weight derived from the additional information. Given a vector of k auxiliary feature buffers, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>f</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f = (f1,..., fk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>, we can compute the weight as:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi>a</mi><mi>u</mi><mi>x</mi></mrow></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi mathvariant="normal">Π</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><msub><mi>d</mi><mrow><mi>f</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w_{aux}(p,q)=\Pi_{i=1}^{k}exp(-d_{f,i}(p,q))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">ux</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1352em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord">Π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">))</span></span></span></span><br><p>where:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>f</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>p</mi></mrow></msub><mo>−</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>q</mi></mrow></msub><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow><mrow><mn>2</mn><msubsup><mi>σ</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>p</mi></mrow><mn>2</mn></msubsup></mrow></mfrac></mrow><annotation encoding="application/x-tex">d_{f,i}(p,q) = \frac{||f_{i,p}-f_{i,q}||^{2}}{2\sigma^{2}_{i,p}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.8276em;vertical-align:-0.6964em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1312em;"><span style="top:-2.6264em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8051em;"><span style="top:-2.1777em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-2.8448em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4612em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5073em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1076em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1076em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mtight">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6964em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br><p>and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>i</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sigma^{2}_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0728em;vertical-align:-0.2587em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4413em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span> is the bandwidth of feature i. Joint filtering is typical for denoising MC renderings where feature buffers (e.g. normal, albedo, depth) can be obtained inexpensively as a byproduct of rendering the image</p><h2 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h2><p>For the square patch Pp centered on p with the size of 20x20(HALF_SEARCH_WINDOW * 2) in our case, we compute the squared patch-based range distance to another patch Pq.</p><p>Pp search range:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> searchY = -HALF_SEARCH_WINDOW; searchY &lt;= HALF_SEARCH_WINDOW; searchY++) <br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> searchX = -HALF_SEARCH_WINDOW; searchX &lt;= HALF_SEARCH_WINDOW; searchX++) <br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Compute the color squared distance between these patches:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> searchY = -HALF_SEARCH_WINDOW; searchY &lt;= HALF_SEARCH_WINDOW; searchY++) <br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> searchX = -HALF_SEARCH_WINDOW; searchX &lt;= HALF_SEARCH_WINDOW; searchX++) <br>    &#123;<br>        float2 searchUV = texUV + <span class="hljs-built_in">float2</span>(searchX,searchY) * denoiseParamsBuffer.inputTexSizeAndInvSize.zw;<br>                <br>        float3 searchRGB = inputTexture.<span class="hljs-built_in">SampleLevel</span>(gSamPointWarp, searchUV, <span class="hljs-number">0.0</span>).xyz;<br>        float3 searchNormal = denoiseInputNormalTexture.<span class="hljs-built_in">SampleLevel</span>(gSamPointWarp, searchUV, <span class="hljs-number">0.0</span>).xyz;<br><br>        <span class="hljs-type">float</span> patchSquareDist = <span class="hljs-number">0.0f</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> offsetY = -HALF_PATCH_WINDOW; offsetY &lt;= HALF_PATCH_WINDOW; offsetY++) <br>        &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> offsetX = -HALF_PATCH_WINDOW; offsetX &lt;= HALF_PATCH_WINDOW; offsetX++) <br>            &#123;<br>                float2 offsetInputUV = texUV + <span class="hljs-built_in">float2</span>(offsetX,offsetY) * denoiseParamsBuffer.inputTexSizeAndInvSize.zw;<br>                float2 offsetSearchUV = searchUV + <span class="hljs-built_in">float2</span>(offsetX,offsetY) * denoiseParamsBuffer.inputTexSizeAndInvSize.zw;<br><br>                float3 offsetInputRGB = inputTexture.<span class="hljs-built_in">SampleLevel</span>(gSamPointWarp, offsetInputUV, <span class="hljs-number">0.0</span>).xyz;<br>                float3 offsetSearchRGB = inputTexture.<span class="hljs-built_in">SampleLevel</span>(gSamPointWarp, offsetSearchUV, <span class="hljs-number">0.0</span>).xyz;<br>                float3 offsetDeltaRGB = offsetInputRGB - offsetSearchRGB;<br>                patchSquareDist += <span class="hljs-built_in">dot</span>(offsetDeltaRGB, offsetDeltaRGB) - TWO_SIGMA_LIGHT_SQUARE;<br>&#125;<br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float2 pixelDelta = <span class="hljs-built_in">float2</span>(searchX, searchY);<br><span class="hljs-type">float</span> pixelSquareDist = <span class="hljs-built_in">dot</span>(pixelDelta, pixelDelta);<br>weight *= <span class="hljs-built_in">exp</span>(-pixelSquareDist / TWO_SIGMA_SPATIAL_SQUARE);<br>weight *= <span class="hljs-built_in">exp</span>(-pixelSquareDist / FILTER_SQUARE_TWO_SIGMA_LIGHT_SQUARE);<br></code></pre></td></tr></table></figure><p>Combine the result with the joint filter weight derived from the additional normal information:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 normalDelta = inputNormal - searchNormal;<br><span class="hljs-type">float</span> normalSquareDist = <span class="hljs-built_in">dot</span>(normalDelta, normalDelta);<br>weight *= <span class="hljs-built_in">exp</span>(-normalSquareDist / TWO_SIGMA_NORMAL_SQUARE);<br></code></pre></td></tr></table></figure><h1 id="LightMap-Encoding"><a href="#LightMap-Encoding" class="headerlink" title="LightMap Encoding"></a>LightMap Encoding</h1><p>1.Store the sqrt irradiance result to give more precision in the draw region.</p><p>2.Separately store the integer and decimal parts of the log radiance.</p><p>3.Store the SH Directionality in a separate lightmap. The reason we store directionality separately instead of multiplying it with irradiance is that many pixels on the screen may share one texel and we can adjust the lighting result based on the world normal, which improves the visual quality.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SEncodeOutputs <span class="hljs-title">EncodeLightMapPS</span><span class="hljs-params">(SEncodeGeometryVS2PS IN )</span></span><br><span class="hljs-function"></span>&#123;<br>    SEncodeOutputs output;<br><br>    float4 lightMap0 = encodeInputIrradianceTexture.<span class="hljs-built_in">SampleLevel</span>(gSamPointWarp, IN.textureCoord, <span class="hljs-number">0.0</span>).xyzw;<br>    float4 lightMap1 = encodeInputSHDirectionalityTexture.<span class="hljs-built_in">SampleLevel</span>(gSamPointWarp, IN.textureCoord, <span class="hljs-number">0.0</span>).xyzw;<br><br>    <span class="hljs-type">float</span> sampleCount = lightMap0.w;<br>    <span class="hljs-keyword">if</span>(sampleCount &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        float4 encodedSH = lightMap1.yzwx;<br>        float3 irradiance = lightMap0.xyz / sampleCount;<br><br>        <span class="hljs-comment">//todo: fixme</span><br>        <span class="hljs-type">const</span> half logBlackPoint = <span class="hljs-number">0.01858136</span>;<br>        output.irradianceAndLuma = <span class="hljs-built_in">float4</span>(<span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">max</span>(irradiance, <span class="hljs-built_in">float3</span>(<span class="hljs-number">0.00001</span>, <span class="hljs-number">0.00001</span>, <span class="hljs-number">0.00001</span>))), <span class="hljs-built_in">log2</span>( <span class="hljs-number">1</span> + logBlackPoint ) - (encodedSH.w / <span class="hljs-number">255</span> - <span class="hljs-number">0.5</span> / <span class="hljs-number">255</span>)); <br>        output.shDirectionalityAndLuma = encodedSH;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        output.irradianceAndLuma = <span class="hljs-built_in">float4</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        output.shDirectionalityAndLuma = <span class="hljs-built_in">float4</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br></code></pre></td></tr></table></figure><p>LightMap Decoding:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SVisualizeGIResult output;<br><br>float4 lightmap0 = visResultIrradianceAndLuma.<span class="hljs-built_in">SampleLevel</span>(gSamPointWarp, IN.lightMapUV, <span class="hljs-number">0.0</span>);<br>float4 lightmap1 = visResultDirectionalityAndLuma.<span class="hljs-built_in">SampleLevel</span>(gSamPointWarp, IN.lightMapUV, <span class="hljs-number">0.0</span>);<br><br><span class="hljs-comment">// irradiance</span><br>float3 irradiance = lightmap0.rgb * lightmap0.rgb;<br><br><span class="hljs-comment">// luma</span><br><span class="hljs-type">float</span> logL = lightmap0.w;<br>logL += lightmap1.w * (<span class="hljs-number">1.0</span> / <span class="hljs-number">255</span>) - (<span class="hljs-number">0.5</span> / <span class="hljs-number">255</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> logBlackPoint = <span class="hljs-number">0.01858136</span>;<br><span class="hljs-type">float</span> luma = <span class="hljs-built_in">exp2</span>( logL ) - logBlackPoint;<br><br><span class="hljs-comment">// directionality</span><br>float3 wordlNormal = IN.normal;<br>float4 SH = lightmap1.xyzw;<br><span class="hljs-type">float</span> Directionality = <span class="hljs-built_in">dot</span>(SH,<span class="hljs-built_in">float4</span>(wordlNormal.yzx,<span class="hljs-number">1.0</span>));<br><br>output.giResult = <span class="hljs-built_in">float4</span>(irradiance * luma * Directionality, <span class="hljs-number">1.0</span>);<br><span class="hljs-keyword">return</span> output;<br></code></pre></td></tr></table></figure><p>result:</p><p align="center">    <img src="/resource/gi_rayguiding/image/result.png" width="70%" height="70%"></p><p><a href="https://github.com/ShawnTSH1229/hwrtl"><u><strong>GI Baking Source Code</strong></u></a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Simplified Lumen GI In MiniEngine</title>
    <link href="/2024/05/18/Simplified-Lumen-GI-In-MiniEngine/"/>
    <url>/2024/05/18/Simplified-Lumen-GI-In-MiniEngine/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This is a simplified Unreal Lumen GI implementation (<strong>SimLumen</strong>) based on <strong>Unreal’s Lumen GI</strong>. We have implemented <strong>most</strong> of Unreal Lumen’s features.</p><p>To perform fast ray tracing, SimLumen builds the <strong>mesh SDFs</strong> offline using the <strong>embree</strong> library. We also precompute a <strong>global low resolution SDF</strong> of the whole scene, which is used in surface cache ray tracing and screen probe voxel ray tracing.</p><p>SimLumen builds <strong>mesh cards</strong> offline in order to capture <strong>material attributes</strong> (normal, albedo) at run time. Mesh cards store the capture direction as well as the camera capture frustum. Since our meshes in the test example are simple and most are boxes, we generate only 6 cards for each mesh. Each direction corresponds a mesh card. At run time, SimLumen captures the mesh attributes, and copies them into a <strong>global surface cache material attributes atlas</strong>.</p><p>The surface cache describes the <strong>lighting of the scene</strong>. It contains 5 parts: <strong>surface cache material attributes</strong>, <strong>surface cache direct lighting</strong>, <strong>surface cache indirect lighting</strong>, <strong>surface cache combined final lighting</strong> and <strong>voxelized scene lighting</strong>.</p><p>With the global surface cache material attributes (normal, albedo and depth), SimLumen computes the direct lighting for each pixel in the surface cache atlas.</p><p>What’s more, we have implemented <strong>infinity</strong> bounce lighting similar to Unreal Lumen. At first, we <strong>voxelize</strong> the scene. Each voxel has 6 directions. For each direction, we perform a mesh SDF trace and store the <strong>hit mesh index and hit distance</strong> in the <strong>voxel visibility buffer</strong>. Then, we <strong>inject</strong> the surface cache final lighting into the voxel if the voxel hit a mesh.</p><p>With the voxelized lighting, we compute the <strong>surface cache indirect lighting</strong> in the surface cache Atlas space. Firstly, SimLumen places probes every <strong>4x4 pixels</strong> in the Atlas space. In the next step, we trace the ray to the voxelized scene via global SDF and sample the radiance within the voxel. In order to denoise the trace result, SimLumen <strong>filters</strong> the radiance atlas and converts them into <strong>spherical harmonics</strong>. By integrating the probes around the pixel, we obtained surface cache indirect lighting.</p><p>The surface cache final lighting is computed by <strong>combining surface direct and indirect lighting</strong>.</p><p>As we have SDF to trace the scene quickly as well as surface cache that describes the scene lighting, we are able to proform the <strong>screen space probe trace</strong>.</p><p>SimLumen uses <strong>importance sampling</strong> to reduce the trace noisy. The PDF of the sampling function contains two parts: <strong>BRDF PDF</strong> and <strong>lighting PDF</strong>. The BRDF PDF is stored in <strong>spherical harmonic</strong> form, and we project the pixel BRDF PDF around the probe into spherical harmonics if the PDF is <strong>not rejected</strong> by the plane depth weight.  We use the <strong>previous frame’s</strong> screen radiance result to estimate the lighting PDF by <strong>reprojecting</strong> the probe into the previous screen space, since we do not have information about the lighting source in the current frame. To improve performance, SimLumen employs <strong>structured importance sampling</strong> by reassigning the unimportant samples to those with a higher PDF.</p><p>Each probe traces 64 rays to the scene. SimLumen implements a <strong>hybrid GI</strong> similar to Unreal Lumen. The probes whose distance from the camera is less than 100 meters trace the scene by <strong>mesh SDF</strong> and sample the radiance from the <strong>surface cache atlas</strong>. Other probes use <strong>Global SDF</strong> to trace the scene and sample the radiance from the <strong>voxel lighting</strong>.</p><p>After that, we perform two additional passes to denoise the results. In the first pass, we <strong>filter</strong> the radiance with a uniform weight. Then, in the second pass, we convert the radiance into <strong>spherical harmonics</strong> and transform the SH into boardered <strong>octchedron form</strong>. This is usefull in hardware <strong>bilinear sampling</strong> in the following pass.</p><p>We finally obtained the final indirect lighting by integrating the probes around the current screen pixel and sampling the <strong>octchedron form SH</strong> by a linear sampler.</p><h1 id="Fast-Ray-Tracing"><a href="#Fast-Ray-Tracing" class="headerlink" title="Fast Ray Tracing"></a>Fast Ray Tracing</h1><p>SimLumen uses signed distance fields to trace the ray with the mesh. SDF is a uniform mesh representation. What’s more, it is differentiable, which means we can calculate the normal at the ray hit position. SimLumen precomputes the mesh SDF and the scene global SDF. GI nearby camera employs mesh SDF to accelerate ray-mesh intersection. Global SDF is used in distant GI and surface cache indirect lighting calculation.</p><h2 id="Build-Mesh-SDF-Offline"><a href="#Build-Mesh-SDF-Offline" class="headerlink" title="Build Mesh SDF Offline"></a>Build Mesh SDF Offline</h2><p>The mesh SDF volume has different size based on the mesh bounding box. To pack these mesh SDF into a single 3D texture, we split the volume into bricks. Brick size is the same for mesh SDFs.</p><p align="center">    <img src="/resource/simlumen/image/build_mesh_sdf.drawio.png" width="60%" height="60%"></p><p>SimLumen use Embree to calculate the mesh SDF, which is the same as Unreal does. For each voxel, we traces 512 ray samples to intersect with the mesh and finds the closest hit position between these samples. A voxel is considered within the mesh if more than 25% of the 512 ray samples hit the triangle backface. We take the negative value of the closest hit distance.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (hit_num &gt; <span class="hljs-number">0</span> &amp;&amp; hit_back_num &gt; <span class="hljs-number">0.25f</span> * samples0.<span class="hljs-built_in">size</span>())<br>&#123;<br>min_distance *= <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Then, scale and quantify the closest distance to uint8 format, and store the result into brick sdf data.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> scaled_min_distance = min_distance / max_distance;<span class="hljs-comment">// -1-&gt;1</span><br><span class="hljs-type">float</span> clamed_min_distance = Math::<span class="hljs-built_in">Clamp</span>(scaled_min_distance * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//0 - 1</span><br><span class="hljs-type">uint8_t</span> normalized_min_distance = <span class="hljs-built_in">uint8_t</span>(<span class="hljs-built_in">int32_t</span>(clamed_min_distance * <span class="hljs-number">255.0f</span> + <span class="hljs-number">0.5</span>));<br><br><span class="hljs-type">int</span> brick_index = brick_index_z * volume_brick_num_y * volume_brick_num_x + brick_index_y * volume_brick_num_x + brick_index_x;<br>volumeData.distance_filed_volume[brick_index].m_brick_data[brick_vol_idx_x][brick_vol_idx_y][brick_vol_idx_z] = normalized_min_distance;<br></code></pre></td></tr></table></figure><h2 id="Trace-Mesh-SDF"><a href="#Trace-Mesh-SDF" class="headerlink" title="Trace Mesh SDF"></a>Trace Mesh SDF</h2><p>At runtime, we copy and upload each mesh’s brick texture to the global mesh SDF brick texture and record the brick texture offset. We can find any SDF value at a given position in the mesh volume for each mesh by global brick texture and brick offset.</p><p align="center">    <img src="/resource/simlumen/image/build_scene_mesh_sdf.png" width="80%" height="80%"></p><p>The GI nearby camera uses mesh SDF to trace rays. In this case, we calculate the possible meshes that can be intersected in the ray tracing direction. Then, we perform SDF tracing for each mesh and find the closest hit position.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[loop]<br><span class="hljs-keyword">for</span>(uint mesh_idx = <span class="hljs-number">0</span>; mesh_idx &lt; scene_mesh_sdf_num; mesh_idx++)<br>&#123;<br>    <span class="hljs-built_in">RayTraceSingleMeshSDF</span>(world_position, ray_direction, <span class="hljs-number">1000</span>, mesh_idx, trace_result);<br>&#125;<br></code></pre></td></tr></table></figure><p>At first, SimNanite transform the ray from the world position into sdf volume position. If the ray intersects the volume bound box, we trace the ray from the intersection position. When the sphere trace step is over 64 or the closest distance in the sample position is closer than on voxel size, it means that we hit the mesh surface and should stop the sphere trace.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float2 volume_space_intersection_times = <span class="hljs-built_in">LineBoxIntersect</span>(volume_ray_start, volume_ray_end, volume_min_pos, volume_max_pos);<br><br>......<br>volume_space_intersection_times *= volume_max_trace_distance;<br><br><span class="hljs-keyword">if</span>((volume_space_intersection_times.x &lt; volume_space_intersection_times.y) &amp;&amp; (volume_space_intersection_times.x &lt; trace_result.hit_distance))<br>&#123;<br>    <span class="hljs-type">float</span> <span class="hljs-type">sample_ray_t</span> = volume_space_intersection_times.x;<br><br>    uint max_step = <span class="hljs-number">64</span>;<br>    <span class="hljs-type">bool</span> bhit = <span class="hljs-literal">false</span>;<br>    uint step_idx = <span class="hljs-number">0</span>;<br><br>    [loop]<br>    <span class="hljs-keyword">for</span>( ; step_idx &lt; max_step; step_idx++)<br>    &#123;<br>        float3 sample_volume_position = volume_ray_start + volume_ray_direction * <span class="hljs-type">sample_ray_t</span>;<br>        <span class="hljs-type">float</span> distance_filed = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(sample_volume_position, mesh_sdf_info);<br>        <span class="hljs-type">float</span> min_hit_distance = mesh_sdf_info.volume_brick_size * <span class="hljs-number">0.125</span> * <span class="hljs-number">1.0</span>; <span class="hljs-comment">// 1 voxel</span><br><br>        <span class="hljs-keyword">if</span>(distance_filed &lt; min_hit_distance)<br>        &#123;<br>            bhit = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">sample_ray_t</span> = <span class="hljs-built_in">clamp</span>(<span class="hljs-type">sample_ray_t</span> + distance_filed - min_hit_distance, volume_space_intersection_times.x, volume_space_intersection_times.y);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-type">sample_ray_t</span> += distance_filed;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-type">sample_ray_t</span> &gt; volume_space_intersection_times.y + min_hit_distance)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(step_idx == max_step)<br>    &#123;<br>        bhit = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(bhit &amp;&amp; <span class="hljs-type">sample_ray_t</span> &lt; trace_result.hit_distance)<br>    &#123;<br>        trace_result.is_hit = <span class="hljs-literal">true</span>;   <br>        trace_result.hit_distance = <span class="hljs-type">sample_ray_t</span>;<br>        trace_result.hit_mesh_index = object_index;<br>        trace_result.hit_mesh_sdf_card_index = mesh_sdf_info.mesh_card_start_index;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SDF-Normal"><a href="#SDF-Normal" class="headerlink" title="SDF Normal"></a>SDF Normal</h2><p>We can calculate the normal at any sample position by calculating the closest distance gradient of the voxels around it.</p><p align="center">    <img src="/resource/simlumen/image/sdf_normal.png" width="70%" height="70%"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">float3 <span class="hljs-title">CalculateMeshSDFGradient</span><span class="hljs-params">(float3 sample_volume_position, SMeshSDFInfo mesh_sdf_info)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> voxel_offset = mesh_sdf_info.volume_brick_size * <span class="hljs-number">0.125</span>;<br><br>    <span class="hljs-type">float</span> R = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x + voxel_offset, sample_volume_position.y, sample_volume_position.z),mesh_sdf_info);<br>    <span class="hljs-type">float</span> L = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x - voxel_offset, sample_volume_position.y, sample_volume_position.z),mesh_sdf_info);<br><br>    <span class="hljs-type">float</span> F = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x, sample_volume_position.y + voxel_offset, sample_volume_position.z),mesh_sdf_info);<br>    <span class="hljs-type">float</span> B = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x, sample_volume_position.y - voxel_offset, sample_volume_position.z),mesh_sdf_info);<br><br>    <span class="hljs-type">float</span> U = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x, sample_volume_position.y, sample_volume_position.z + voxel_offset),mesh_sdf_info);<br>    <span class="hljs-type">float</span> D = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x, sample_volume_position.y, sample_volume_position.z - voxel_offset),mesh_sdf_info);<br><br>    float3 gradiance = <span class="hljs-built_in">float3</span>(R - L, F - B, U - D);<br><span class="hljs-keyword">return</span> gradiance;<br>&#125;<br></code></pre></td></tr></table></figure><p>Below is a SDF ray-tracing visualization.  In this example, the ray-tracing direction for each cube is determined by its offset from the center cube. RGB colors represent the hit position’s normal. X is represented by red color, Y by green color, and Z by blue color.</p><p align="center">    <img src="/resource/simlumen/image/sdf_normal_visualize.png" width="80%" height="80%"></p><h2 id="Global-SDF"><a href="#Global-SDF" class="headerlink" title="Global SDF"></a>Global SDF</h2><p>The global signed distance field is a low resolution SDF of the whole scene. We precompute the global SDF offline. Global SDF differs from scene mesh SDF in that the scene mesh SDF is stored in brick textures with fixed z-dimensions, whereas global SDF is stored in a size-scalable volume texture based on the scene bounding box.</p><h1 id="Surface-Cache"><a href="#Surface-Cache" class="headerlink" title="Surface Cache"></a>Surface Cache</h1><p>The mesh SDF trace allows us to determine the hit position of a ray, however it does not provide information regarding the material attributes (albedo, normal, etc.) at the hit position. Unreal Lumen uses mesh cards to capture these material attributs runtime. </p><p>Mesh cars describe the material attributes capture infomation. It can be generated offline. However, material attributes capture must be performed at runtime, since occlusion between scene meshes can’t be determined offline.</p><h2 id="SimLumen-Card-Generation"><a href="#SimLumen-Card-Generation" class="headerlink" title="SimLumen Card Generation"></a>SimLumen Card Generation</h2><p><strong>In Unreal, a mesh may have many mesh cards depend on mesh complexity.</strong> SimLumen simplifies mesh card generation: generates a fixed number mesh card (6 direction) based on the mesh bounding box.  </p><p align="center">    <img src="/resource/simlumen/image/mesh_card.png" width="40%" height="40%"></p><p>We calculate the capture position and direction from the bounding box directly. The mesh card depth is determined by software raytracing. For each texel in the mesh card, we trace a ray in the mesh card direction, calculate the ray-mesh intersection and find the furthest intersection distance.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> max_depth = <span class="hljs-number">2.0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x_idx = <span class="hljs-number">0</span>; x_idx &lt; <span class="hljs-number">128</span>; x_idx++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y_idx = <span class="hljs-number">0</span>; y_idx &lt; <span class="hljs-number">128</span>; y_idx++)<br>&#123;<br>XMFLOAT3 trace_position = palne_start_trace_pos;<br><span class="hljs-built_in">AddFloatComponent</span>(trace_position, dimension_x, (x_idx + <span class="hljs-number">0.5</span>) * x_stride);<br><span class="hljs-built_in">AddFloatComponent</span>(trace_position, dimension_y, (y_idx + <span class="hljs-number">0.5</span>) * y_stride);<br><br>RTCRayHit embree_ray;<br>......<br><span class="hljs-built_in">rtcIntersect1</span>(m_rt_scene, &amp;embree_ray, &amp;args);<br><br><span class="hljs-keyword">if</span> ((embree_ray.ray.tfar != <span class="hljs-number">1e30</span>f) &amp;&amp; embree_ray.hit.geomID != RTC_INVALID_GEOMETRY_ID &amp;&amp; embree_ray.hit.primID != RTC_INVALID_GEOMETRY_ID)<br>&#123;<br><span class="hljs-function">Math::Vector3 <span class="hljs-title">hit_normal</span><span class="hljs-params">(embree_ray.hit.Ng_x, embree_ray.hit.Ng_y, embree_ray.hit.Ng_z)</span></span>;<br>hit_normal = Math::<span class="hljs-built_in">Normalize</span>(hit_normal);<br><span class="hljs-type">float</span> dot_value = Math::<span class="hljs-built_in">Dot</span>(trace_dir, hit_normal);<br><br><span class="hljs-keyword">if</span> (dot_value &lt; <span class="hljs-number">0</span> &amp;&amp; max_depth &lt; embree_ray.ray.tfar)<br>&#123;<br>max_depth = embree_ray.ray.tfar;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br>XMFLOAT3 points[<span class="hljs-number">4</span>];<br>points[<span class="hljs-number">0</span>] = palne_start_trace_pos;<br>points[<span class="hljs-number">1</span>] = plane_end_trace_pos;<br><br>points[<span class="hljs-number">2</span>] = palne_start_trace_pos;<br>points[<span class="hljs-number">2</span>].x += trace_dir.x * max_depth;<br>points[<span class="hljs-number">2</span>].y += trace_dir.y * max_depth;<br>points[<span class="hljs-number">2</span>].z += trace_dir.z * max_depth;<br><br>points[<span class="hljs-number">3</span>] = plane_end_trace_pos;<br>points[<span class="hljs-number">3</span>].x += trace_dir.x * max_depth;<br>points[<span class="hljs-number">3</span>].y += trace_dir.y * max_depth;<br>points[<span class="hljs-number">3</span>].z += trace_dir.z * max_depth;<br><br>Math::BoundingBox RetBound;<br>Math::BoundingBox::<span class="hljs-built_in">CreateFromPoints</span>(RetBound, <span class="hljs-number">4</span>, points, <span class="hljs-built_in">sizeof</span>(XMFLOAT3));<br><span class="hljs-keyword">return</span> RetBound;<br></code></pre></td></tr></table></figure><h2 id="Material-Attributes-Capture"><a href="#Material-Attributes-Capture" class="headerlink" title="Material Attributes Capture"></a>Material Attributes Capture</h2><p>SimLumen captures the mesh card at runtime. After the mesh card capture is completed, we copy these mesh card attribute textures into a global card atlas.</p><p align="center">    <img src="/resource/simlumen/image/mat_attributes_alebedo.png" width="35%" height="35%"></p><p align="center">    <img src="/resource/simlumen/image/mat_attributes_normal.png" width="35%" height="35%"></p><p>Below is a visualization of the mesh card’s normal and albedo for a scene:</p><p align="center">    <img src="/resource/simlumen/image/scene_attributes_alebedo.png" width="50%" height="50%"></p><p align="center">    <img src="/resource/simlumen/image/scene_attributes_normal.png" width="50%" height="50%"></p><h2 id="Surface-Cache-Lighting"><a href="#Surface-Cache-Lighting" class="headerlink" title="Surface Cache Lighting"></a>Surface Cache Lighting</h2><p>Unreal Lumen has implemented an <strong>infinity bounce</strong> lighting by the combination of the surface cache lighting and voxel lighting. Here is the surface cache flow graph:</p><p>Step 1: Calculate direct lighting with surface cache attributes (albedo &#x2F; normal).</p><p>Step 2: Combine direct lighting and indirect lighting together. In the first frame, direct lighting results in black, since no light has been injected into the scene voxel.</p><p>Step 3: Inject the combined light into the scene voxel.</p><p>Step 4: Calculate indirect lighting used in the next frame.</p><p align="center">    <img src="/resource/simlumen/image/surface_cache_lighting_flow.png" width="75%" height="75%"></p><h2 id="Surface-Cache-Direct-Lighting"><a href="#Surface-Cache-Direct-Lighting" class="headerlink" title="Surface Cache Direct Lighting"></a>Surface Cache Direct Lighting</h2><p>The world position of a mesh card pixel is calculated by the card rotation matrix and card depth. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 local_position;<br>local_position.xy = (card_uv * (<span class="hljs-number">2.0f</span>) - <span class="hljs-number">1.0f</span>) * card_info.rotated_extents.xy;<br>local_position.z = -(depth * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0f</span>)  * card_info.rotated_extents.z;<br>float3 rotate_back_pos = <span class="hljs-built_in">mul</span>((float3x3)card_info.rotate_back_matrix, local_position);<br>rotate_back_pos += card_info.bound_center;;<br></code></pre></td></tr></table></figure><p>After that, SimLumen transforms the world position into shadow space in order to determine whether the pixel is inside or outside the shadow.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> shadow = <span class="hljs-number">0.0</span>;<br>&#123;<br>    float4 shadow_screen_pos = <span class="hljs-built_in">mul</span>(ShadowViewProjMatrix, <span class="hljs-built_in">float4</span>(card_data.world_position,<span class="hljs-number">1.0</span>));<br>    float2 shadow_uv = shadow_screen_pos.xy;<br>    shadow_uv = shadow_uv * <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">-0.5</span>) + <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);<br>    float2 shadow_pixel_pos = shadow_uv.xy * <span class="hljs-number">2048</span>;<br><br>    <span class="hljs-type">float</span> shadow_depth_value = shadow_depth_buffer.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(shadow_pixel_pos.xy,<span class="hljs-number">0</span>)).x;;<br>    shadow = ((shadow_screen_pos.z + <span class="hljs-number">0.0005</span>) &lt; shadow_depth_value ) ? <span class="hljs-number">0.0</span> :<span class="hljs-number">1.0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>We calculate the direct lighting for each light source and accumulate them if the scene has many light sources.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 directional_lighting = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#123;<br>    float3 light_direction = SunDirection;<br>    <span class="hljs-type">float</span> NoL = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(light_direction, card_data.world_normal));<br>    directional_lighting = SunIntensity * NoL * card_data.albedo * shadow;<br>&#125;<br><br>float3 point_lighting = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#123;<br>    float3 point_light_direction = point_light_world_pos - card_data.world_position;<br>    float3 light_dist = <span class="hljs-built_in">length</span>(point_light_direction);<br>    <span class="hljs-type">float</span> attenuation = <span class="hljs-built_in">saturate</span>((point_light_radius - light_dist) / point_light_radius);   <br>    <span class="hljs-type">float</span> NoL = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(<span class="hljs-built_in">normalize</span>(point_light_direction), card_data.world_normal));<br>    point_lighting = NoL * card_data.albedo * attenuation * attenuation;<br>&#125;<br>surface_cache_direct_lighting[<span class="hljs-built_in">int2</span>(pixel_pos.xy)] = <span class="hljs-built_in">float4</span>(point_lighting + directional_lighting, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure><p>surface cache direct lighting visualization:</p><p align="center">    <img src="/resource/simlumen/image/scache_direct_lighting.png" width="64%" height="64%"></p><h2 id="Voxel-Visibility-Buffer"><a href="#Voxel-Visibility-Buffer" class="headerlink" title="Voxel Visibility Buffer"></a>Voxel Visibility Buffer</h2><p>Voxel visibility buffer stores the hit mesh index and hit distance in x&#x2F;y&#x2F;z direction. As a persistent data, it is only updated when the meshes’ positions change. SDF traces are performed for each voxel along the xyz direction for meshes that are possibly intersected with its center. If the ray from the voxel center along the x&#x2F;y&#x2F;z direction hit a mesh, we store the mesh index in the voxel. This will be used in the next light injection pass.</p><p align="center">    <img src="/resource/simlumen/image/voxel_vis_info.png" width="60%" height="60%"></p><h2 id="Lighting-Injection"><a href="#Lighting-Injection" class="headerlink" title="Lighting Injection"></a>Lighting Injection</h2><p>We can obtain the intersection mesh and intersection position directly from the voxel visibility buffer. After that, we transform the hit world position into mesh card space location and calculate the final light atlas UV. The final light is the combination of the direct light and indirect light. However, the indirect lighting remains black until the second frame as it is dependent on voxel illumination.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint direction_idx = group_idx.y;<br>SVoxelVisibilityInfo voxel_vis_info = scene_voxel_visibility_buffer[voxel_index_1d];<br><span class="hljs-type">int</span> mesh_index = voxel_vis_info.voxel_vis_info[direction_idx].mesh_index;<br><span class="hljs-keyword">if</span>(mesh_index != <span class="hljs-number">-1</span>)<br>&#123;<br>    SMeshSDFInfo mesh_info = scene_sdf_infos[mesh_index];<br>    uint card_index = direction_idx; <br>    uint global_card_index = mesh_info.mesh_card_start_index + card_index;<br><br>    SCardInfo card_info = scene_card_infos[global_card_index];<br><br>    <span class="hljs-type">float</span> hit_distance = voxel_vis_info.voxel_vis_info[direction_idx].hit_distance;<br>    float3 light_direction = voxel_light_direction[direction_idx];<br>    float3 hit_world_pos = voxel_world_pos + light_direction * hit_distance;<br><br>    float2 uv = <span class="hljs-built_in">GetCardUVFromWorldPos</span>(card_info, hit_world_pos);<br><br>    uint2 card_index_xy = <span class="hljs-built_in">uint2</span>((global_card_index % card_num_xy), (global_card_index / card_num_xy));<br>    uint2 pixel_pos = card_index_xy * <span class="hljs-number">128</span> + <span class="hljs-built_in">float2</span>(uv * <span class="hljs-number">128</span>);<br>    pixel_pos.y = SURFACE_CACHE_TEX_SIZE - pixel_pos.y;<br>    float3 final_lighting = final_lighting_tex.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(pixel_pos,<span class="hljs-number">0</span>)).xyz;<br><br>    scene_voxel_lighting[voxel_index_1d].final_lighting[direction_idx] = final_lighting;<br>&#125;<br></code></pre></td></tr></table></figure><p>voxel lighting visualization:</p><p align="center">    <img src="/resource/simlumen/image/voxel_lighting_visualize.png" width="60%" height="60%"></p><h2 id="Surface-Cache-Indirect-Lighting"><a href="#Surface-Cache-Indirect-Lighting" class="headerlink" title="Surface Cache Indirect Lighting"></a>Surface Cache Indirect Lighting</h2><p>The first step is to calculate the radiance of the current surface cache pixel using global SDF, filter, and store the radiance in a radiance atlas. We then convert radiance into SH, which allows us to perform probe interpolation to reduce lighting noise.<br>The irradiance in a unit area is the integral of the f(x) over the half sphere:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><mi>L</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>⋅</mo><mi>i</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">E(p) = \int_{\Omega}L(p,i)max(0,n\cdot i )\mathrm{d}i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">i</span></span></span></span><br><p>F(x) can be split into two parts: the lighting function and the diffuse transfer function:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>H</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">E(p) = \int_{\Omega}L(i)\cdot H(i)\mathrm{d}i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">i</span></span></span></span><br><p>L(i) is reconstructed from the spherical harmonic by SH factors and biasis function:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>≈</mo><mi mathvariant="normal">Σ</mi><msub><mi>l</mi><mi>k</mi></msub><msub><mi>B</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(i) \approx \Sigma l_{k}B_{k}(i) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span><br><p>We project the radiance into the basis function to get the SH factors in Convert SH pass:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mi>k</mi></msub><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mi>B</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">l_{k} = \int_{\Omega}L(i)B(i)\mathrm{d}i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">i</span></span></span></span><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(<span class="hljs-built_in">SHBasisFunction</span>(world_ray), trace_irradiance / pdf));<br></code></pre></td></tr></table></figure><p>If we project both the illumination and transfer functions into SH coefficients then orthogonality guarantees that the integral of the function’s products is the same as the dot product of their coefficients:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><msup><mi>n</mi><mn>2</mn></msup></msubsup><msub><mi>l</mi><mi>k</mi></msub><msub><mi>h</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">E(p) = \Sigma_{k=0}^{n^{2}} l_{k}h_{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.27em;vertical-align:-0.2831em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9869em;"><span style="top:-2.4169em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>⋅</mo><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(i) = max(0,n\cdot l) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span><br><p>The irradiance of a pixel is calculated in the integrate pass:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FTwoBandSHVector diffuse_transfer_sh = <span class="hljs-built_in">CalcDiffuseTransferSH</span>(card_data.world_normal, <span class="hljs-number">1.0f</span>);<br>float3 texel_irradiance = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">float3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>), <span class="hljs-built_in">DotSH</span>(irradiance_sh, diffuse_transfer_sh));<br></code></pre></td></tr></table></figure><p align="center">    <img src="/resource/simlumen/image/scache_indirect_lighting.png" width="40%" height="40%"></p><h3 id="Radiosity-Trace"><a href="#Radiosity-Trace" class="headerlink" title="Radiosity Trace"></a>Radiosity Trace</h3><p>SimLumen split the atlas space surface cache into 8x8 tiles. Each tile place 2x2 probes. </p><p align="center">    <img src="/resource/simlumen/image/scache_radiosity_trace_probe.png" width="30%" height="30%"></p><p>Each probe performs 16 ray tracings in the hemisphere direction.</p><p align="center">    <img src="/resource/simlumen/image/radiosity_probe_ray.png" width="30%" height="30%"></p><p>To accelerate the speed of convergence of the integrate, the probe center is jittered according to the tile index and the frame index.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint2 probe_jitter = <span class="hljs-built_in">GetProbeJitter</span>(indirect_lighting_temporal_index);<br></code></pre></td></tr></table></figure><p>For each direction, we trace a ray from the probe center and find the world space hit position by global SDF.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 world_ray;<br><span class="hljs-type">float</span> pdf;<br><span class="hljs-built_in">GetRadiosityRay</span>(tile_idx, sub_tile_pos, card_data.world_normal, world_ray, pdf);<br><br>SGloablSDFHitResult hit_result = (SGloablSDFHitResult)<span class="hljs-number">0</span>;<br><span class="hljs-built_in">TraceGlobalSDF</span>(card_data.world_position + card_data.world_normal * gloabl_sdf_voxel_size * <span class="hljs-number">2.0</span>, world_ray, hit_result);<br></code></pre></td></tr></table></figure><p>Finally, fetch the voxel lighting at the hit position and accumulate the weighted lighting results in the x&#x2F;y&#x2F;z direction.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint voxel_index_1d = <span class="hljs-built_in">GetVoxelIndexFromWorldPos</span>(hit_world_position);<br><br>SVoxelLighting voxel_lighting = scene_voxel_lighting[voxel_index_1d];<br>float3 voxel_lighting_x = voxel_lighting.final_lighting[x_dir];<br>float3 voxel_lighting_y = voxel_lighting.final_lighting[y_dir];<br>float3 voxel_lighting_z = voxel_lighting.final_lighting[z_dir];<br><br><span class="hljs-type">float</span> weight_x = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(world_ray, voxel_light_direction[x_dir]));<br><span class="hljs-type">float</span> weight_y = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(world_ray, voxel_light_direction[y_dir]));<br><span class="hljs-type">float</span> weight_z = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(world_ray, voxel_light_direction[z_dir]));<br><br>radiance += voxel_lighting_x * weight_x;<br>radiance += voxel_lighting_y * weight_y;<br>radiance += voxel_lighting_z * weight_z;<br><br>radiance /= (weight_x + weight_y + weight_z);<br></code></pre></td></tr></table></figure><p>radiance trace result:</p><p align="center">    <img src="/resource/simlumen/image/scache_radiosity_atlas.png" width="60%" height="60%"></p><p>radiance trace visualization:</p><p align="center">    <img src="/resource/simlumen/image/scache_radiosity_vis.png" width="60%" height="60%"></p><h3 id="Radiosity-Filter"><a href="#Radiosity-Filter" class="headerlink" title="Radiosity Filter"></a>Radiosity Filter</h3><p>In this pass, SimLumen filters the radiance atlas to reduce the noise. We sample the radiance around the current texel and accumulate weighted samples. Radiance sample weights in Unreal Lumen are dependent upon a number of factors, including the texel’s World space plane and the distance between the planes.</p><p>filtered radiance atlas:</p><p align="center">    <img src="/resource/simlumen/image/scache_radiosity_atlas_filtered.png" width="60%" height="60%"></p><h3 id="Convert-To-SH"><a href="#Convert-To-SH" class="headerlink" title="Convert To SH"></a>Convert To SH</h3><p>Radiance atlas results are still noisy after filtering, since we only have 16 samples per probe. We solve this problem by converting the tile radiance into two bands SH, which allows us to interpolate the probes more easily. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(uint trace_idx_x = <span class="hljs-number">0</span>; trace_idx_x &lt; SURFACE_CACHE_PROBE_TEXELS_SIZE; trace_idx_x++)<br>&#123;<br>    <span class="hljs-keyword">for</span>(uint trace_idx_y = <span class="hljs-number">0</span>; trace_idx_y &lt; SURFACE_CACHE_PROBE_TEXELS_SIZE; trace_idx_y++)<br>    &#123;<br>        ......<br>        float3 trace_irradiance = trace_radiance_atlas.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(pixel_atlas_pos.xy, <span class="hljs-number">0</span>)).xyz;<br>        irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(<span class="hljs-built_in">SHBasisFunction</span>(world_ray), trace_irradiance / pdf));<br>num_valid_sample += <span class="hljs-number">1.0f</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (num_valid_sample &gt; <span class="hljs-number">0</span>)<br>&#123;<br>irradiance_sh = <span class="hljs-built_in">MulSH</span>(irradiance_sh, <span class="hljs-number">1.0f</span> / num_valid_sample);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Radiosity-Integrate"><a href="#Radiosity-Integrate" class="headerlink" title="Radiosity Integrate"></a>Radiosity Integrate</h3><p>Finally, sample the probes around the current pixel and calculate the weights based on the atlas position. Then, accumulate the SH weights and weighted SH, calculate the basis function using the current pixel’s world normal, and dot product the basis function with the SH result.  By dividing it by the total sum of SH weights, we get the final radiance value for the current pixel.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FTwoBandSHVectorRGB irradiance_sh = (FTwoBandSHVectorRGB)<span class="hljs-number">0</span>;<br><br>FTwoBandSHVectorRGB sub_irradiance_sh00 = <span class="hljs-built_in">GetRadiosityProbeSH</span>(ProbeCoord00);<br>FTwoBandSHVectorRGB sub_irradiance_sh01 = <span class="hljs-built_in">GetRadiosityProbeSH</span>(ProbeCoord01);<br>FTwoBandSHVectorRGB sub_irradiance_sh10 = <span class="hljs-built_in">GetRadiosityProbeSH</span>(ProbeCoord10);<br>FTwoBandSHVectorRGB sub_irradiance_sh11 = <span class="hljs-built_in">GetRadiosityProbeSH</span>(ProbeCoord11);<br><br>irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(sub_irradiance_sh00, weights.x));<br>irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(sub_irradiance_sh01, weights.y));<br>irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(sub_irradiance_sh10, weights.z));<br>irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(sub_irradiance_sh11, weights.w));<br><br>uint card_index_1d = card_idx_2d.y * SURFACE_CACHE_CARD_NUM_XY + card_idx_2d.x;<br>SCardInfo card_info = scene_card_infos[card_index_1d];<br>SCardData card_data = <span class="hljs-built_in">GetSurfaceCardData</span>(card_info, <span class="hljs-built_in">float2</span>(<span class="hljs-built_in">uint2</span>(thread_index.xy % <span class="hljs-number">128u</span>)) / <span class="hljs-number">128.0f</span>, pixel_atlas_pos.xy);<br>FTwoBandSHVector diffuse_transfer_sh = <span class="hljs-built_in">CalcDiffuseTransferSH</span>(card_data.world_normal, <span class="hljs-number">1.0f</span>);<br><br>float3 texel_irradiance = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">float3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>), <span class="hljs-built_in">DotSH</span>(irradiance_sh, diffuse_transfer_sh));<br>irtexel_radiance = texel_irradiance / (weights.x + weights.y + weights.z + weights.w);<br></code></pre></td></tr></table></figure><p>surface cache indirect lighting visualization:</p><p align="center">    <img src="/resource/simlumen/image/indirect_lighting_vis.png" width="60%" height="60%"></p><p>surface cache combined lighting visualization:</p><p align="center">    <img src="/resource/simlumen/image/combined_lighting_vis.png" width="60%" height="60%"></p><h1 id="Final-Gather"><a href="#Final-Gather" class="headerlink" title="Final Gather"></a>Final Gather</h1><p>We place the probe in screen space for each 8x8 pixels and use octchedron mapping to map the screen coordinates into spherical coordinates. Each probe trace 64 rays into the scene.</p><h2 id="Importance-Sampling"><a href="#Importance-Sampling" class="headerlink" title="Importance Sampling"></a>Importance Sampling</h2><p>It’s too noisy if we employ uniform sampling rather than importance sampling.<br>without importance sampling Vs with importance sampling:</p><p align="center">    <img src="/resource/simlumen/image/is_vs_no_is.png" width="60%" height="60%"></p><p>What we do in the importance sampling part is searching the rays that orientates to the lighting source and world normal. That is to say, we peroform importance sampling for BRDF(fs) term and input radiance(Li) term:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>N</mi></mfrac><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mfrac><mrow><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><msub><mi>f</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>l</mi><mo>−</mo><mo>&gt;</mo><mi>v</mi><mo stretchy="false">)</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>θ</mi><mi>l</mi><mo stretchy="false">)</mo></mrow><msub><mi>P</mi><mi>k</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{N}\Sigma_{k=1}^{N}\frac{L_{i}(l)f_{s}(l-&gt;v)cos(\theta l)}{P_{k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4609em;vertical-align:-0.4509em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.4169em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.1076em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mtight">−</span><span class="mrel mtight">&gt;</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span><span class="mord mathnormal mtight">cos</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">θl</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4509em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br><h3 id="BRDF-PDF"><a href="#BRDF-PDF" class="headerlink" title="BRDF PDF"></a>BRDF PDF</h3><p>In this step, SimLumen generate the three band sphere harmonic factors for the BRDF function. We sample the screen pixels around the screen probe and compute the influence weight on the probe. If the weight is over the threshold, convert the BRDF to SH and accumulate the SH. Then write the result to the BRDF SH buffer.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 pixel_world_position = <span class="hljs-built_in">GetWorldPosByDepth</span>(thread_depth, piexl_tex_uv);<br>float3 probe_world_position = <span class="hljs-built_in">GetWorldPosByDepth</span>(probe_depth, ss_probe_atlas_pos / global_thread_size);<br><br>float4 pixel_world_plane = <span class="hljs-built_in">float4</span>(thread_world_normal, <span class="hljs-built_in">dot</span>(thread_world_normal,pixel_world_position));<br><span class="hljs-type">float</span> plane_distance = <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">dot</span>(<span class="hljs-built_in">float4</span>(probe_world_position, <span class="hljs-number">-1</span>), pixel_world_plane));<br><br><span class="hljs-type">float</span> probe_view_dist = <span class="hljs-built_in">length</span>(probe_world_position - CameraPos);<br><span class="hljs-type">float</span> relative_depth_diff = plane_distance / probe_view_dist;<br><span class="hljs-type">float</span> depth_weight = <span class="hljs-built_in">exp2</span>(<span class="hljs-number">-10000.0f</span> * (relative_depth_diff * relative_depth_diff));<br><span class="hljs-keyword">if</span>(depth_weight &gt; <span class="hljs-number">0.1f</span>)<br>&#123;<br>    uint write_index;<br>    <span class="hljs-built_in">InterlockedAdd</span>(group_num_sh, <span class="hljs-number">1</span>, write_index);<br><br>    FThreeBandSHVector brdf = <span class="hljs-built_in">CalcDiffuseTransferSH3</span>(thread_world_normal, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-built_in">WriteGroupSharedSH</span>(brdf, write_index);<br>&#125;<br></code></pre></td></tr></table></figure><p>The pixel normal may be located in a different plane from the probe. Therefore, we compute the plane weight for the given pixel and reject the pixel if the depth weight is over the threshold. Then, store the results of those valid pixels in a <strong>group shared</strong> array.</p><p align="center">    <img src="/resource/simlumen/image/brdf_depth_weight.png" width="60%" height="60%"></p><p>After that, perform a parallel reduction to accumulate these SH factors.</p><p align="center">    <img src="/resource/simlumen/image/acc_brdf_pdf.png" width="60%" height="60%"></p><p>Finally, the first nine threads store the 9 SH factors in output BRDF SH buffer.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (thread_index &lt; <span class="hljs-number">9</span> &amp;&amp; group_num_sh &gt; <span class="hljs-number">0</span>)<br>&#123;<br>    uint write_index = (ss_probe_idx_xy.y * screen_probe_size_x + ss_probe_idx_xy.x) * <span class="hljs-number">9</span> + thread_index;<br>    <span class="hljs-type">float</span> normalize_weight = <span class="hljs-number">1.0f</span> / (<span class="hljs-type">float</span>)(group_num_sh);<br>    brdf_pdf_sh[write_index] = pdf_sh[offset][thread_index] * normalize_weight;<br>&#125;<br></code></pre></td></tr></table></figure><p>brdf pdf visualization:</p><p align="center">    <img src="/resource/simlumen/image/brdf_pdf_vis.png" width="60%" height="60%"></p><h3 id="Lighting-PDF"><a href="#Lighting-PDF" class="headerlink" title="Lighting PDF"></a>Lighting PDF</h3><p>The light source direction in the current frame is unknown. In order to search the light direction, we assume lighting changes slightly and reuse the previous frame’s lighting result.</p><p align="center">    <img src="/resource/simlumen/image/ss_light_is.png" width="60%" height="60%"></p><p>Then, reproject the probe into the previous frame screen position and find the corresponding direction texel.</p><p>Calculate the lighting pdf based on its luminance.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> float2 global_thread_size = <span class="hljs-built_in">float2</span>(is_pdf_thread_size_x,is_pdf_thread_size_y);<br>float3 probe_world_position = gbuffer_c.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(ss_probe_atlas_pos.xy,<span class="hljs-number">0</span>)).xyz;<br><br>float4 pre_view_pos = <span class="hljs-built_in">mul</span>(PreViewProjMatrix,<span class="hljs-built_in">float4</span>(probe_world_position, <span class="hljs-number">1.0</span>));<br>float2 pre_view_screen_pos = (<span class="hljs-built_in">float2</span>(pre_view_pos.xy / pre_view_pos.w) * <span class="hljs-number">0.5</span> + <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>));<br>pre_view_screen_pos.y = (<span class="hljs-number">1.0</span> - pre_view_screen_pos.y);<br>pre_view_screen_pos = pre_view_screen_pos * global_thread_size;<br>uint2 pre_probe_pos = <span class="hljs-built_in">uint2</span>(pre_view_screen_pos) / <span class="hljs-built_in">uint2</span>(PROBE_SIZE_2D,PROBE_SIZE_2D);<br>uint2 pre_texel_pos = pre_probe_pos * <span class="hljs-built_in">uint2</span>(PROBE_SIZE_2D,PROBE_SIZE_2D) + group_thread_idx.xy;<br><br>lighting = sspace_composited_radiance.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(pre_texel_pos.xy,<span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>lighting importance sampling pdf visualization:</p><p align="center">    <img src="/resource/simlumen/image/lighting_is_pdf_vis.png" width="60%" height="60%"></p><h3 id="Structured-Importance-Sampling"><a href="#Structured-Importance-Sampling" class="headerlink" title="Structured Importance Sampling"></a>Structured Importance Sampling</h3><p>Unreal Lumen adopted a new mechanism called structured importance sampling to reassign the not important samples to those importance directions.</p><p>The first step is to calculate the PDF of probe 8x8 pixels. We can obtain the world ray direction by pixel’s uv in the group based on the equi area spherical mapping algorithm. The BRDF PDF in this direction can be calculated by the BRDF PDF SH computed in the last pass.</p><p align="center">    <img src="/resource/simlumen/image/struct_id_cull.png" width="70%" height="70%"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// brdf pdf</span><br>FThreeBandSHVector brdf;<br>brdf.V0.x = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">0</span>];<br>brdf.V0.y = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">1</span>];<br>brdf.V0.z = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">2</span>];<br>brdf.V0.w = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">3</span>];<br>brdf.V1.x = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">4</span>];<br>brdf.V1.y = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">5</span>];<br>brdf.V1.z = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">6</span>];<br>brdf.V1.w = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">7</span>];<br>brdf.V2.x = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">8</span>];<br><br>float2 probe_uv = (group_thread_idx.xy + <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.5f</span>)) / PROBE_SIZE_2D;<br>float3 world_cone_direction = <span class="hljs-built_in">EquiAreaSphericalMapping</span>(probe_uv);<br><br>FThreeBandSHVector direction_sh = <span class="hljs-built_in">SHBasisFunction3</span>(world_cone_direction);<br><span class="hljs-type">float</span> pdf = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">DotSH3</span>(brdf, direction_sh), <span class="hljs-number">0</span>);<br><br><span class="hljs-type">float</span> light_pdf = light_pdf_tex.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(dispatch_thread_idx.xy,<span class="hljs-number">0</span>));<br><span class="hljs-type">bool</span> is_pdf_no_culled_by_brdf = pdf &gt;= MIN_PDF_TRACE;<br><br><span class="hljs-type">float</span> light_pdf_scaled = light_pdf * PROBE_SIZE_2D * PROBE_SIZE_2D;<br>pdf *= light_pdf_scaled;<br><span class="hljs-keyword">if</span>(is_pdf_no_culled_by_brdf)<br>&#123;<br>    pdf = <span class="hljs-built_in">max</span>(pdf, MIN_PDF_TRACE);<br>&#125;<br></code></pre></td></tr></table></figure><p>Perform a GPU sort from low to high to find those ray directions that need refinement.</p><p align="center">    <img src="/resource/simlumen/image/struct_is_flow.png" width="50%" height="50%"></p><p>We refine the rays in groups of three. If the maximum PDF among the three rays is less than the minimum PDF threshold, these samples are discarded and refinement is performed. The ray refinement is similar to the mip map. Double the coordinates, compute the local coordinates based on the ray indexes (0,1), (1,1), and (1,0), respectively. Coordinate (0,0) is the position of the corresponding ray to the refine group.</p><p align="center">    <img src="/resource/simlumen/image/struct_is_0.png" width="65%" height="65%"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint merge_thread_idx = thread_idx % <span class="hljs-number">3</span>;<br>uint merge_idx = thread_idx / <span class="hljs-number">3</span>;<br>uint ray_idx_to_refine = <span class="hljs-built_in">max</span>((<span class="hljs-type">int</span>)PROBE_SIZE_2D * PROBE_SIZE_2D - (<span class="hljs-type">int</span>)merge_idx - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>uint ray_idx_to_merge = merge_idx * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span>(ray_idx_to_merge &lt; ray_idx_to_refine)<br>&#123;<br>    uint2 ray_tex_coord_to_merge;<br>uint ray_level_to_merge;<br><span class="hljs-type">float</span> ray_pdf_to_merge;<br><span class="hljs-built_in">UnpackRaySortInfo</span>(RaysToRefine[sort_offset + ray_idx_to_merge], ray_tex_coord_to_merge, ray_level_to_merge, ray_pdf_to_merge);<br><br>    <span class="hljs-keyword">if</span>(ray_pdf_to_merge &lt; MIN_PDF_TRACE)<br>    &#123;<br>        uint2 origin_ray_tex_coord;<br>        uint original_ray_level;<br>        uint original_pdf;<br>        <span class="hljs-built_in">UnpackRaySortInfo</span>(RaysToRefine[sort_offset + ray_idx_to_refine], origin_ray_tex_coord, original_ray_level, original_pdf);<br><br>        RaysToRefine[sort_offset + thread_idx] = <span class="hljs-built_in">PackRaySortInfo</span>(origin_ray_tex_coord * <span class="hljs-number">2</span> + <span class="hljs-built_in">uint2</span>((merge_thread_idx + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>, (merge_thread_idx + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>), original_ray_level - <span class="hljs-number">1</span>, <span class="hljs-number">0.0f</span>);<br><br><span class="hljs-keyword">if</span> (merge_idx == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">InterlockedAdd</span>(num_rays_to_subdivide, <span class="hljs-number">1</span>);<br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Screen-Space-Probe-Trace"><a href="#Screen-Space-Probe-Trace" class="headerlink" title="Screen Space Probe Trace"></a>Screen Space Probe Trace</h2><p>Unreal Lumen is a hybird global illumination solution consisting four GI methods: SSGI, Mesh SDF trace, global SDF trace and cube map. Unreal Lumen performs screen space GI first by sampling the previous scene color. When the SSGI fails to hit, Unreal Lumen performs a mesh SDF trace and samples the surface cache final lighting atlas. Mesh SDF trace is only performed on probes near the camera (positions in 40m radius around the camera). For those further probes, Unreal Lumen performs Global SDF trace and samples the scene voxel lighting. If all of these methods fail, Unreal Lumen falls back to sample the cube map.</p><p>In SimLumen, we only perform <strong>two trace methods</strong>: sampling the <strong>surface cache final lighting</strong> by mesh SDF trace and sampling the <strong>scene voxel lighting</strong> by global SDF trace. </p><p align="center">    <img src="/resource/simlumen/image/hybrid_gi.png" width="65%" height="65%"></p><h3 id="Screen-Space-Probe-Mesh-SDF-Trace"><a href="#Screen-Space-Probe-Mesh-SDF-Trace" class="headerlink" title="Screen Space Probe Mesh SDF Trace"></a>Screen Space Probe Mesh SDF Trace</h3><p>We perform mesh SDF trace if the probe’s distance to the camera is less than 100m.</p><p>Sample 64 directions for each screen space probe. The sample direction is obtained from structured importance sampling table. This table stores the ray coordinates. The refined ray’s coordinates (mip 0) range from (0,0) to (16,16), and the other ray’s coordinates (mip 1) range from (0,0) to (8,8). Divide the ray coordinates by the mip size and transform them into range (0,1). We can obtain the mapped direction by EquiAreaSphericalMapping with mapped UV.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetScreenProbeTexelRay</span><span class="hljs-params">(uint2 buffer_idx, inout float3 ray_direction)</span></span><br><span class="hljs-function"></span>&#123;<br>    uint packed_ray_info = structed_is_indirect_table.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(buffer_idx.xy,<span class="hljs-number">0</span>));<br><br>    uint2 texel_coord;<br>    uint level;<br>    <span class="hljs-built_in">UnpackRayInfo</span>(packed_ray_info, texel_coord, level);<br><br>    uint mip_size = <span class="hljs-number">16</span> &gt;&gt; level;<br>    <span class="hljs-type">float</span> inv_mip_size = <span class="hljs-number">1.0f</span> / <span class="hljs-built_in">float</span>(mip_size);<br><br>    float2 probe_uv = (texel_coord + <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>)) * inv_mip_size;<br>    ray_direction = <span class="hljs-built_in">EquiAreaSphericalMapping</span>(probe_uv);<br>    ray_direction = <span class="hljs-built_in">normalize</span>(ray_direction);<br>&#125;<br></code></pre></td></tr></table></figure><p>Then trace the scene mesh SDFs that are around the current probe in the world space.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[loop]<br><span class="hljs-keyword">for</span>(uint mesh_idx = <span class="hljs-number">0</span>; mesh_idx &lt; SCENE_SDF_NUM; mesh_idx++)<br>&#123;<br>    SMeshSDFInfo mesh_sdf_info = scene_sdf_infos[mesh_idx];<br>    <span class="hljs-type">float</span> trace_bais = mesh_sdf_info.volume_brick_size * <span class="hljs-number">0.125</span> * <span class="hljs-number">2.0</span>; <span class="hljs-comment">//2 voxel</span><br>    <span class="hljs-built_in">RayTraceSingleMeshSDF</span>(probe_world_position + world_normal * trace_bais, ray_direction, <span class="hljs-number">1000</span>, mesh_idx, trace_result);<br>&#125;<br></code></pre></td></tr></table></figure><p>Calculate the hit world position if the ray hits the scene SDFs. Then, sample the surface cache card based on the world position. Unreal Lumen samples the surface cache cards <strong>three times</strong> based on it’s ray directions and the normal in the hit position. Considering our meshes are not too complex, SimLumen only <strong>samples once</strong> based on the <strong>maximum ray direction</strong>.</p><p>The surface cache card index is calculated from the mesh card start index and the card direction offset index.</p><p>With the mesh card index, we can get the surface cache atlas UV and sample the final lighting.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 hit_world_position = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>);<br><span class="hljs-keyword">if</span>(trace_result.is_hit)<br>&#123;<br>    SMeshSDFInfo mesh_sdf_info = scene_sdf_infos[trace_result.hit_mesh_index];<br><br>    <span class="hljs-type">float</span> trace_bais = mesh_sdf_info.volume_brick_size * <span class="hljs-number">0.125</span> * <span class="hljs-number">2.0</span>; <span class="hljs-comment">//2 voxel</span><br>    hit_world_position = probe_world_position + world_normal * trace_bais + ray_direction * trace_result.hit_distance;<br>    <br>    <span class="hljs-type">float</span> max_ray_dir = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-type">int</span> max_dir_card_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(ray_direction.x) &gt; max_ray_dir)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(ray_direction.x &gt; <span class="hljs-number">0</span>)&#123;max_dir_card_idx = <span class="hljs-number">5</span>;&#125;<br>        <span class="hljs-keyword">else</span>&#123;max_dir_card_idx = <span class="hljs-number">4</span>;&#125;;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(ray_direction.y) &gt; max_ray_dir)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(ray_direction.y &gt; <span class="hljs-number">0</span>)&#123;max_dir_card_idx = <span class="hljs-number">3</span>;&#125;<br>        <span class="hljs-keyword">else</span>&#123;max_dir_card_idx = <span class="hljs-number">2</span>;&#125;;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(ray_direction.z) &gt; max_ray_dir)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(ray_direction.z &gt; <span class="hljs-number">0</span>)&#123;max_dir_card_idx = <span class="hljs-number">1</span>;&#125;<br>        <span class="hljs-keyword">else</span>&#123;max_dir_card_idx = <span class="hljs-number">0</span>;&#125;;<br>    &#125;<br><br>    uint card_index = mesh_sdf_info.mesh_card_start_index + max_dir_card_idx;<br>    <br>    SCardInfo card_info = scene_card_infos[card_index];<br>    float2 card_uv = <span class="hljs-built_in">GetCardUVFromWorldPos</span>(card_info, hit_world_position);<br>    <br>    uint2 card_index_xy = <span class="hljs-built_in">uint2</span>((card_index % card_num_xy), (card_index / card_num_xy));<br>    uint2 pixel_pos = card_index_xy * <span class="hljs-number">128</span> + <span class="hljs-built_in">float2</span>(card_uv * <span class="hljs-number">128</span>);<br>    pixel_pos.y = SURFACE_CACHE_TEX_SIZE - pixel_pos.y;<br>    <br>    float3 lighting = surface_cache_final_lighting.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(pixel_pos,<span class="hljs-number">0</span>)).xyz;<br>    trace_radiance = lighting;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    trace_radiance = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>); <span class="hljs-comment">//hack sky light</span><br>&#125;<br></code></pre></td></tr></table></figure><p>surface cache sample result:</p><p align="center">    <img src="/resource/simlumen/image/mesh_sdf_trace_result.png" width="85%" height="85%"></p><h3 id="Screen-Space-Probe-Voxel-Trace"><a href="#Screen-Space-Probe-Voxel-Trace" class="headerlink" title="Screen Space Probe Voxel Trace"></a>Screen Space Probe Voxel Trace</h3><p>The probes further than 100m using voxel lighting trace, which is similar to surface cache sampling. There are several differences between them: the probes trace the scene using a low resolution global SDF rather than single mesh SDFs, and they sample voxel lighting rather than surface cache lighting.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SGloablSDFHitResult hit_result = (SGloablSDFHitResult)<span class="hljs-number">0</span>;<br><span class="hljs-built_in">TraceGlobalSDF</span>(probe_world_position + world_normal * gloabl_sdf_voxel_size * <span class="hljs-number">2.0</span>, ray_direction, hit_result);<br></code></pre></td></tr></table></figure><p>Voxel lighting is sampled three times based on the ray trace direction. The sample weights are computed by the dot product result between the ray trace direction and voxel face direction.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x_dir = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(ray_direction.x &gt; <span class="hljs-number">0.0</span>) &#123; x_dir = <span class="hljs-number">5</span>;  &#125;<br><span class="hljs-keyword">else</span> &#123; x_dir = <span class="hljs-number">4</span>;  &#125;<br><br><span class="hljs-type">int</span> y_dir = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(ray_direction.y &gt; <span class="hljs-number">0.0</span>) &#123; y_dir = <span class="hljs-number">3</span>;  &#125;<br><span class="hljs-keyword">else</span> &#123; y_dir = <span class="hljs-number">2</span>;  &#125;<br><br><span class="hljs-type">int</span> z_dir = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(ray_direction.z &gt; <span class="hljs-number">0.0</span>) &#123; z_dir = <span class="hljs-number">1</span>;  &#125;<br><span class="hljs-keyword">else</span> &#123; z_dir = <span class="hljs-number">0</span>;  &#125;<br><br><br><span class="hljs-keyword">if</span>(hit_result.bHit)<br>&#123;<br>    float3 hit_world_position =  ray_direction * (hit_result.hit_distance - gloabl_sdf_voxel_size) + probe_world_position + world_normal * gloabl_sdf_voxel_size * <span class="hljs-number">2.0</span>;<br><br>    uint voxel_index_1d = <span class="hljs-built_in">GetVoxelIndexFromWorldPos</span>(hit_world_position);<br>    SVoxelLighting voxel_lighting = scene_voxel_lighting[voxel_index_1d];<br><br>    float3 voxel_lighting_x = voxel_lighting.final_lighting[x_dir];<br>    float3 voxel_lighting_y = voxel_lighting.final_lighting[y_dir];<br>    float3 voxel_lighting_z = voxel_lighting.final_lighting[z_dir];<br><br>    <span class="hljs-type">float</span> weight_x = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(ray_direction, voxel_light_direction[x_dir]));<br>    <span class="hljs-type">float</span> weight_y = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(ray_direction, voxel_light_direction[y_dir]));<br>    <span class="hljs-type">float</span> weight_z = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(ray_direction, voxel_light_direction[z_dir]));<br><br>    radiance += (voxel_lighting_x * weight_x);<br>    radiance += (voxel_lighting_y * weight_y);<br>    radiance += (voxel_lighting_z * weight_z);<br><br>    radiance /= (weight_x + weight_y + weight_z);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    radiance = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>); <span class="hljs-comment">//hack sky light</span><br>&#125;<br></code></pre></td></tr></table></figure><p>voxel lighting sampling result:</p><p align="center">    <img src="/resource/simlumen/image/voxel_trace_result.png" width="85%" height="85%"></p><h2 id="Traced-Radiance-Composite"><a href="#Traced-Radiance-Composite" class="headerlink" title="Traced Radiance Composite"></a>Traced Radiance Composite</h2><p>Since the samples may be refined, we perform an additional composition pass to accumulate the ray samples. Each comptue group processes one probe ( 8x8 samples).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">groupshared uint shared_accumulator[PROBE_SIZE_2D * PROBE_SIZE_2D][<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p>The refined ray weighs 1&#x2F;4 and the other ray weighs 1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">float</span> sample_weight = (<span class="hljs-type">float</span>)<span class="hljs-number">8</span> / mip_size * <span class="hljs-number">8</span> / mip_size; <span class="hljs-comment">// level 0: weight 1/4, level 1: weight 1</span><br>float3 lighting = screen_space_trace_radiance.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(dispatch_thread_idx.xy, <span class="hljs-number">0</span>)).xyz * sample_weight;<br></code></pre></td></tr></table></figure><p> We acclumulate the samples in a probe and assign the result to the original unrefined sample position.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint2 remaped_texel_coord = texel_coord * PROBE_SIZE_2D / mip_size;<br>uint remapped_thread_idx = remaped_texel_coord.y * PROBE_SIZE_2D + remaped_texel_coord.x;<br><br>uint3 quantized_lighting = lighting * lighting_quantize_scale;<br><br><span class="hljs-built_in">InterlockedAdd</span>(shared_accumulator[remapped_thread_idx][<span class="hljs-number">0</span>], quantized_lighting.x);<br><span class="hljs-built_in">InterlockedAdd</span>(shared_accumulator[remapped_thread_idx][<span class="hljs-number">1</span>], quantized_lighting.y);<br><span class="hljs-built_in">InterlockedAdd</span>(shared_accumulator[remapped_thread_idx][<span class="hljs-number">2</span>], quantized_lighting.z);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint thread_index = group_thread_idx.y * PROBE_SIZE_2D + group_thread_idx.x;<br>radiance = <span class="hljs-built_in">float3</span>(shared_accumulator[thread_index][<span class="hljs-number">0</span>], shared_accumulator[thread_index][<span class="hljs-number">1</span>], shared_accumulator[thread_index][<span class="hljs-number">2</span>]) / lighting_quantize_scale;<br></code></pre></td></tr></table></figure><p align="center">    <img src="/resource/simlumen/image/composition.png" width="75%" height="75%"></p><p>radiance composition result:</p><p align="center">    <img src="/resource/simlumen/image/composited_result.png" width="85%" height="85%"></p><h2 id="Screen-Radiance-Filter"><a href="#Screen-Radiance-Filter" class="headerlink" title="Screen Radiance Filter"></a>Screen Radiance Filter</h2><p>Filter the screen space radiance to denoise the result. Radiance filter weight is a combination of <strong>angle weight and depth weight</strong> in Unreal Lumen. We use a <strong>simple uniform weight</strong> instead of an angle&#x2F;depth weight because our scene is simple and most of the mesh is cubes.</p><p align="center">    <img src="/resource/simlumen/image/radiance_filter.png" width="40%" height="40%"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 total_radiance = screen_space_radiance.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(dispatch_thread_idx.xy, <span class="hljs-number">0</span>)).xyz;<br><span class="hljs-type">float</span> total_weight = <span class="hljs-number">1.0</span>;<br><br>int2 offsets[<span class="hljs-number">4</span>]; offsets[<span class="hljs-number">0</span>] = <span class="hljs-built_in">int2</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>); offsets[<span class="hljs-number">1</span>] = <span class="hljs-built_in">int2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>); offsets[<span class="hljs-number">2</span>] = <span class="hljs-built_in">int2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>); offsets[<span class="hljs-number">3</span>] = <span class="hljs-built_in">int2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span> (uint offset_index = <span class="hljs-number">0</span>; offset_index &lt; <span class="hljs-number">4</span>; offset_index++)<br>&#123;<br>    int2 neighbor_index = offsets[offset_index] * PROBE_SIZE_2D + dispatch_thread_idx.xy;<br>    <span class="hljs-keyword">if</span>((neighbor_index.x &gt;= <span class="hljs-number">0</span>) &amp;&amp; (neighbor_index.x &lt; is_pdf_thread_size_x) &amp;&amp; (neighbor_index.y &gt;= <span class="hljs-number">0</span>) &amp;&amp; (neighbor_index.y &lt; is_pdf_thread_size_y))<br>    &#123;<br>        <span class="hljs-type">float</span> neigh_depth = gbuffer_depth.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(ss_probe_atlas_pos.xy + offsets[offset_index] * PROBE_SIZE_2D, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">if</span>(neigh_depth != <span class="hljs-number">0</span>)<br>        &#123;<br>            total_radiance += screen_space_radiance.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(dispatch_thread_idx.xy, <span class="hljs-number">0</span>)).xyz;<br>            total_weight += <span class="hljs-number">1.0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>filtered_radiance = total_radiance / total_weight;<br></code></pre></td></tr></table></figure><p>filtered radiance result:</p><p align="center">    <img src="/resource/simlumen/image/filtered_radiance.png" width="80%" height="80%"></p><h2 id="Convert-To-Oct-SH-Representaion"><a href="#Convert-To-Oct-SH-Representaion" class="headerlink" title="Convert To Oct SH Representaion"></a>Convert To Oct SH Representaion</h2><p>To denoise the radiance result further, we convert the radiance into <strong>shperical harmonic</strong>, which acts as a low-pass filter. After that we transform the SH into <strong>octahedron</strong> representation. The reason we perform this additional pass is to use <strong>hardware bilinear filter</strong> in the next integration pass. In order to avoid sampling the other probe’s result, we add a pixel <strong>board</strong> around the center.</p><p align="center">    <img src="/resource/simlumen/image/radiance_to_oct.png" width="35%" height="35%"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint2 texel_coord_with_boarder = <span class="hljs-built_in">OctahedralMapWrapBorder</span>(<span class="hljs-built_in">uint2</span>(write_idx_x, write_idx_y),SCREEN_SPACE_PROBE,<span class="hljs-number">1</span>);<br>float2 probe_texel_center = <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);<br>float2 probe_uv = (texel_coord_with_boarder + probe_texel_center) / (<span class="hljs-type">float</span>)SCREEN_SPACE_PROBE;<br>float3 texel_direction = <span class="hljs-built_in">EquiAreaSphericalMapping</span>(probe_uv);<br><br>FThreeBandSHVector diffuse_transfer = <span class="hljs-built_in">CalcDiffuseTransferSH3</span>(texel_direction, <span class="hljs-number">1.0f</span>);<br>float3 irradiance = <span class="hljs-number">4.0f</span> * PI * <span class="hljs-built_in">DotSH3</span>(irradiance_sh, diffuse_transfer);<br>screen_space_oct_irradiance[texel_screen_pos] = irradiance;<br></code></pre></td></tr></table></figure><p>octahedron spherical  harmonic result:</p><p align="center">    <img src="/resource/simlumen/image/oct_result.png" width="70%" height="70%"></p><h2 id="Integrate"><a href="#Integrate" class="headerlink" title="Integrate"></a>Integrate</h2><p>With the boardered octahedron spherical harmonic, we can sample the sh by <strong>hardware bilinear filter</strong>, which denoises the result further.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">float3 <span class="hljs-title">GetScreenProbeIrradiance</span><span class="hljs-params">(uint2 probe_start_pos, float2 irradiance_probe_uv)</span></span><br><span class="hljs-function"></span>&#123;<br>    float2 sub_pos = irradiance_probe_uv * (SCREEN_SPACE_PROBE - <span class="hljs-number">1.0</span>) + <span class="hljs-number">1.0</span>;<br>    float2 texel_uv = (probe_start_pos * SCREEN_SPACE_PROBE + sub_pos) / <span class="hljs-built_in">float2</span>(is_pdf_thread_size_x, is_pdf_thread_size_y);<br>    <span class="hljs-keyword">return</span> screen_space_oct_irradiance.<span class="hljs-built_in">SampleLevel</span>(sampler_linear_clamp,texel_uv,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>For each screen pixel, we sample 5 screen probes and accumulate the samples. After dividing the result by the sum of the weights, we are able to obtain the final result for screen indirect lighting:</p><p align="center">    <img src="/resource/simlumen/image/screen_indirect_lighting_result.png" width="70%" height="70%"></p><h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><p>direct lighting only:</p><p align="center">    <img src="/resource/simlumen/image/direct_lighting_only.png" width="70%" height="70%"></p><p>with GI:</p><p align="center">    <img src="/resource/simlumen/image/with_gi.png" width="70%" height="70%"></p><p><a href="https://github.com/ShawnTSH1229/SimLumen"><u><strong>Simplified Lumen Source Code</strong></u></a></p>]]></content>
    
    
    <categories>
      
      <category>My Projects</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Simplified Nanite In MiniEngine</title>
    <link href="/2024/05/08/Simplified-Nanite-Virtualized-Geometry-In-MiniEngine/"/>
    <url>/2024/05/08/Simplified-Nanite-Virtualized-Geometry-In-MiniEngine/</url>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>This is a simplified Nanite implementation (SimNanite) based on Unreal’s Nanite virtual geometry. We have implemented most of Unreal Nanite’s features.</p><p>In offline, we partition the triangles into clusters with the Metis graph partition library. Then, SimNanite partitions the clusters into cluster groups, builds the DAG (Directed Acyclic Graph) and BVH tree based on the cluster groups. In order to avoid the LOD crack, SimNanite simplify the mesh globally rather than simplifying the triangles per cluster.</p><p>At runtime, we implement a three-level GPU culling pipeline: instance culling, BVH node culling and cluster culling. In the BVH node culling pass, we use the MPMC ( Multiple Producers, Single Consumer ) model to transverse the BVH structure and integrate the cluster culling into the BVH culling shader for work balance.</p><p>We generate an indirect draw or indirect dispatch command for those clusters that pass the culling. If the cluster is small enough, we employ the software rasterization with compute shader.</p><p>During the rasterization pass, we write the cluster index and triangle index to the visibility buffer. In the next base pass or GBuffer rendering, we fetch these indices from the visibility buffer, calculate the pixel attributes (UV and normal) by barycentric coordinates and render the scene with these attributes.</p><h1 id="Nanite-Builder"><a href="#Nanite-Builder" class="headerlink" title="Nanite Builder"></a>Nanite Builder</h1><h2 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h2><p>SimNanite (Simplified Nanite) building is an offline mesh processing during mesh import. It splits the mesh into <strong>clusters</strong> to provide a fine-grained mesh culling with a graph partition algorithm. Beyond the cluster level, SimNanite partitions the cluster into <strong>groups</strong> to accelerate mesh culling. Cluster groups are the leaf nodes of the <strong>BVH structure</strong>. In addtion, SimNanite <strong>simplifies the merged clusters</strong> at the current level rather than separate clusters in order to avoid the Lod crack artifact without boundnary edge locking.</p><p align="center">    <img src="/resource/simnanite/image/nanite_builder_overview.png" width="60%" height="60%"></p><h2 id="Triangle-Partition"><a href="#Triangle-Partition" class="headerlink" title="Triangle Partition"></a>Triangle Partition</h2><p>SimNanite partitions the mesh into clusters in order to perform fine-grained GPU culling. Meshes can be viewed as graphs, whose nodes are vertex points and edges are mesh topology. With the graph representation, we can partition it with the Metis graph library. </p><p>Given a mesh without an index buffer, SimNanite processes the mesh triangles sequentially. For each triangle, SimNanite hash the vertex position to find the vertex index of the adjacent list array. Each vertex in the triangle has 6 edges. We add these edge points into the coresponding vertex adjacent unordered_set. </p><p align="center">    <img src="/resource/simnanite/image/find_vertex_adjacent.png" width="50%" height="50%"></p><p>The Metis library’s graph partition function input has two parts: vertex adjacent list array and vertex adjacent offsets. Vertex adjacent offsets record the offsets of each vertex in the vertex adjacent list.</p><p align="center">    <img src="/resource/simnanite/image/metis_input_format.png" width="60%" height="60%"></p><p>With the adjacent vertex list for each vertex, we can pack them into an array and record their offsets.</p><p align="center">    <img src="/resource/simnanite/image/metis_input.png" width="60%" height="60%"></p><p>After the triangle partition, Metis outputs an array containing the partition index of each vertex. The next step is to batch the triangles into clusters with the partition result and find out the linked clusters for each cluster. If the vertices of one triangle belong to different partitions, this triangle can be viewed as an “edge-cluster”. We add these clusters to the linked clusters array in order to partition the clusters in the next step.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">idx_t</span> tri_parts[<span class="hljs-number">3</span>];<br>tri_parts[<span class="hljs-number">0</span>] = part_a;<br><br><span class="hljs-type">int</span> triangle_part_num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (part_b != part_a)<br>&#123;<br>tri_parts[triangle_part_num] = part_b;<br>triangle_part_num++;<br>&#125;<br><br><span class="hljs-keyword">if</span> ((part_c != part_a) &amp;&amp; (part_c != part_b))<br>&#123;<br>tri_parts[triangle_part_num] = part_c;<br>triangle_part_num++;<br>&#125;<br><br><span class="hljs-keyword">if</span> (triangle_part_num == <span class="hljs-number">2</span>)<br>&#123;<br>out_clusters[tri_parts[<span class="hljs-number">0</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">1</span>]);<br>out_clusters[tri_parts[<span class="hljs-number">1</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">0</span>]);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (triangle_part_num == <span class="hljs-number">3</span>)<br>&#123;<br>out_clusters[tri_parts[<span class="hljs-number">0</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">1</span>]);<br>out_clusters[tri_parts[<span class="hljs-number">0</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">2</span>]);<br><br>out_clusters[tri_parts[<span class="hljs-number">1</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">0</span>]);<br>out_clusters[tri_parts[<span class="hljs-number">1</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">2</span>]);<br><br>out_clusters[tri_parts[<span class="hljs-number">2</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">0</span>]);<br>out_clusters[tri_parts[<span class="hljs-number">2</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Cluster-Partition"><a href="#Cluster-Partition" class="headerlink" title="Cluster Partition"></a>Cluster Partition</h2><p>With clusters and linked clusters, we can partition them into cluster groups as we do in the triangle partition pass. Cluster group is the leaf node in BVH acceleration structure. Usually, it consists of four to eight clusters.</p><p align="center">    <img src="/resource/simnanite/image/vtx_clu_grp_map.png" width="50%" height="50%"></p><p>Below is the cluster visualization at LOD level 0, 1 and 2 in SimNanite:</p><p align="center">    <img src="/resource/simnanite/image/vis_clu_0.png" width="50%" height="50%"></p><p align="center">    <img src="/resource/simnanite/image/vis_clu_1.png" width="50%" height="50%"></p><p align="center">    <img src="/resource/simnanite/image/vis_clu_2.png" width="50%" height="50%"></p><h2 id="Mesh-Simplification"><a href="#Mesh-Simplification" class="headerlink" title="Mesh Simplification"></a>Mesh Simplification</h2><p>We simplify the mesh until the cluster number is less than 24 or fails to simplify the mesh. The mesh simplification library is Meshoptimizer. It employs the QEM method to simplify the mesh, which is similar to what the Unreal Engine does. Another important point is that we simplify the global mesh rather than the cluster, as the latter method causes the <strong>LOD crack</strong> whitout boundnary edge locking. </p><p align="center">    <img src="/resource/simnanite/image/mesh_simplify.png" width="50%" height="50%"></p><h2 id="Build-DAG"><a href="#Build-DAG" class="headerlink" title="Build DAG"></a>Build DAG</h2><p>In the DAG (Directed Acyclic Graph) building pass, we organize the data and translate it into a GPU-friendly structure to acclerate to GPU-culling performed later. </p><p align="center">    <img src="/resource/simnanite/image/adg_structure.png" width="70%" height="70%"></p><p>SimNanite merges the resources of all lod level into a global resource array. That is to say, a simnanite mesh resource only has one vertex buffer, one index buffer, one cluster group array and one cluster array. UE’s Nanite performs an additional compression process after mesh building. We ignore compression for simplicity.</p><p align="center">    <img src="/resource/simnanite/image/dag_data.png" width="50%" height="50%"></p><p>A nanite mesh resource contains several lod resources. Each LOD resource stores cluster group indices in the current level. The max cluster group number per LOD is 8.  It stores the vertex and index location in the mesh vertex buffer. Nanite mesh building consume a lot of time. To accelerate programming efficiency, we serialize the DAG structure on the disk and load it without building at the next launch.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSimNaniteClusterResource</span><br>&#123;<br>DirectX::BoundingBox m_bouding_box;<br><br><span class="hljs-type">int</span> m_index_count;<br><span class="hljs-type">int</span> m_start_index_location;<br><span class="hljs-type">int</span> m_start_vertex_location;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSimNaniteClusterGrpupResource</span><br>&#123;<br>DirectX::BoundingBox m_bouding_box;<br><span class="hljs-type">float</span> cluster_next_lod_dist;<br><span class="hljs-type">int</span> m_child_group_num;<br><span class="hljs-type">int</span> m_cluster_num;<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt;m_child_group_indices;<br>std::vector&lt;<span class="hljs-type">int</span>&gt;m_clusters_indices;<br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*group_serialize_fun)</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">void</span>* streaming)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Serialize</span><span class="hljs-params">(group_serialize_fun func, <span class="hljs-type">void</span>* streaming)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSimNaniteLodResource</span><br>&#123;<br><span class="hljs-type">int</span> m_cluster_group_num;<br><span class="hljs-type">int</span> m_cluster_group_index[<span class="hljs-number">8</span>];<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSimNaniteMeshResource</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>SSimNaniteMeshHeader m_header;<br><br>DirectX::BoundingBox m_bouding_box;<br><br>std::vector&lt;DirectX::XMFLOAT3&gt; m_positions;<br>std::vector&lt;DirectX::XMFLOAT3&gt; m_normals;<br>std::vector&lt;DirectX::XMFLOAT2&gt; m_uvs;<br>std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt; m_indices;<br><br>std::vector&lt;CSimNaniteClusterGrpupResource&gt; m_cluster_groups;<br>std::vector&lt;CSimNaniteClusterResource&gt;m_clusters;<br>std::vector&lt;CSimNaniteLodResource&gt; m_nanite_lods;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LoadFrom</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; source_file_an, <span class="hljs-type">const</span> std::wstring&amp; source_file, <span class="hljs-type">bool</span> bforce_rebuild = <span class="hljs-literal">false</span>)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Build-BVH"><a href="#Build-BVH" class="headerlink" title="Build BVH"></a>Build BVH</h2><p>UE’s nanite use BVH to acclerate the GPU cluster group culling and LOD selection. In the offline, UE builds the BVH by SAH (Surface Area Heuristic) method. In SimNanite, we find the maximum dimension of the bound box extents and sort the cluster goups based on the position distribution in the maximum dimension. After that, we split the cluster groups into 4 nodes and build the whole BVH tree bottom-up. Each LOD has a root BVH node. For example, the mesh that has four LOD contains four root nodes.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;SClusterGroupBVHNode&gt; leaf_nodes;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> clu_grp_idx = <span class="hljs-number">0</span>; clu_grp_idx &lt; lod_resource.m_cluster_group_num; clu_grp_idx++)<br>&#123;<br><span class="hljs-type">uint32_t</span> global_clu_grp_idx = lod_resource.m_cluster_group_start + clu_grp_idx;<br>SClusterGroupBVHNode leaf_node;<br>leaf_node.m_is_leaf_node = <span class="hljs-literal">true</span>;<br>leaf_node.m_cluster_group_index = global_clu_grp_idx;<br>leaf_node.m_bouding_box = out_nanite_reousource.m_cluster_groups[global_clu_grp_idx].m_bouding_box;<br>leaf_nodes.<span class="hljs-built_in">push_back</span>(leaf_node);<br>&#125;<br><br><span class="hljs-type">uint32_t</span> max_dimension_index = (bbox.Extents.x &gt; bbox.Extents.y) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br><span class="hljs-type">float</span> max_dimension = (bbox.Extents.x &gt; bbox.Extents.y) ? bbox.Extents.x : bbox.Extents.y;<br>max_dimension_index = (max_dimension &gt; bbox.Extents.z) ? max_dimension_index : <span class="hljs-number">2</span>;<br>max_dimension = (max_dimension &gt; bbox.Extents.z) ? max_dimension : bbox.Extents.z;<br>SCustomLess custom_less;<br>custom_less.m_split_dimension = max_dimension_index;<br><br>std::<span class="hljs-built_in">sort</span>(leaf_nodes.<span class="hljs-built_in">begin</span>(), leaf_nodes.<span class="hljs-built_in">end</span>(), custom_less);<br><br><span class="hljs-type">uint32_t</span> offset = bvh_nodes.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">uint32_t</span> level_node_num = leaf_nodes.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> leaf_idx = <span class="hljs-number">0</span>; leaf_idx &lt; leaf_nodes.<span class="hljs-built_in">size</span>(); leaf_idx++)<br>&#123;<br>bvh_nodes.<span class="hljs-built_in">push_back</span>(leaf_nodes[leaf_idx]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Culling"><a href="#Culling" class="headerlink" title="Culling"></a>Culling</h1><h2 id="Instance-Culling"><a href="#Instance-Culling" class="headerlink" title="Instance Culling"></a>Instance Culling</h2><p>This step performs instance-level GPU-Culling, which is easy to implement and not necessary to detail it. The input of this step is the scene instance data and the output is the instance culled by the camera.</p><p>scene instance data:</p><p align="center">    <img src="/resource/simnanite/image/ins_cull_scene.png" width="50%" height="50%"></p><p>instances viewed by camera:</p><p align="center">    <img src="/resource/simnanite/image/ins_cull_view.png" width="50%" height="50%"></p><p>instances culled by camera:</p><p align="center">    <img src="/resource/simnanite/image/ins_cull_scene_view.png" width="50%" height="50%"></p><h2 id="Persistent-Culling"><a href="#Persistent-Culling" class="headerlink" title="Persistent Culling"></a>Persistent Culling</h2><p>I tried to implement a DAG transversal at first. But I found it was too complicated to traverse to DAG in the compute shader. So I finally use the <strong>BVH structure</strong> to traverse the cluster group on GPU, which is same as the unreal does.</p><p>UE’s Nanite use the MPMC ( Multiple Producers, Single Consumer ) model to transverse the BVH structure. What’s more, it integrates the cluster culling into BVH culling shader for work balance. <strong>In SimNanite, we have implemented the two features (MPMC and integrate cluster culling) mentioned above.</strong></p><p align="center">    <img src="/resource/simnanite/image/persistent_cull_work_flow.png" width="80%" height="80%"></p><p>SimNanite processes the node culling tasks at first. After the previous node culling task has completed, the first thread in the group fetches the node tasks from the node MPMC culling task queue.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(node_processed_size == GROUP_PROCESS_NODE_NUM)<br>&#123;<br>    <span class="hljs-keyword">if</span>(group_index == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">InterlockedAdd</span>(queue_pass_state[<span class="hljs-number">0</span>].node_task_read_offset, GROUP_PROCESS_NODE_NUM, group_start_node_idx);<br>    &#125;<br>    <span class="hljs-built_in">GroupMemoryBarrierWithGroupSync</span>();<br><br>    node_processed_size = <span class="hljs-number">0</span>;<br>    node_start_idx = group_start_node_idx;<br>&#125;<br></code></pre></td></tr></table></figure><p>Then, the compute group counts the node tasks ready to process.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(is_node_ready)<br>&#123;<br>    <span class="hljs-built_in">InterlockedOr</span>(group_node_processed_mask, <span class="hljs-number">1u</span> &lt;&lt; group_index);<br>&#125;<br><span class="hljs-built_in">AllMemoryBarrierWithGroupSync</span>();<br></code></pre></td></tr></table></figure><p>We start the node culling task when at least one node is ready in the group. SimNanite generates cluster culling tasks and pushes these tasks to the cluster culling queue if a node is a leaf node and its cluster group error is small enough. Otherwise, SimNanite generates BVH node culling tasks and push these to the BVH node culling queue.</p><p align="center">    <img src="/resource/simnanite/image/process_node.png" width="70%" height="70%"></p><h2 id="Cluster-Culling"><a href="#Cluster-Culling" class="headerlink" title="Cluster Culling"></a>Cluster Culling</h2><p>Cluster culling is a two-pass process. The first pass is performed at the persistent culling stage. It will process the cluster culling task if there are no node culling tasks for the compute group to process. SimNanite dispatches an additional cluster culling pass after the persistent culling stage to process tasks that were not handled in the previous stage.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(clu_task_start_index == <span class="hljs-number">0xFFFFFFFF</span>u)<br>&#123;<br>    <span class="hljs-keyword">if</span>(group_index == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">InterlockedAdd</span>(queue_pass_state[<span class="hljs-number">0</span>].cluster_task_read_offset, <span class="hljs-number">1</span>, group_start_clu_index);<br>    &#125;<br>    <span class="hljs-built_in">GroupMemoryBarrierWithGroupSync</span>();<br>    clu_task_start_index = group_start_clu_index;<br>&#125;<br><br><span class="hljs-keyword">if</span> (group_index == <span class="hljs-number">0</span>)<br>&#123;<br>    group_node_task_num = queue_pass_state[<span class="hljs-number">0</span>].node_num;<br>    group_clu_task_size = cluster_task_batch_size.<span class="hljs-built_in">Load</span>(clu_task_start_index * <span class="hljs-number">4</span> <span class="hljs-comment">/*sizeof uint*/</span>);<br>&#125;<br><span class="hljs-built_in">GroupMemoryBarrierWithGroupSync</span>();<br><br>uint clu_task_ready_size = group_clu_task_size;<br><span class="hljs-keyword">if</span>(!has_node_task &amp;&amp; clu_task_ready_size == <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(clu_task_ready_size &gt; <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span>(group_index &lt; clu_task_ready_size)<br>    &#123;<br>        <span class="hljs-type">const</span> uint2 cluster_task = cluster_task_queue.<span class="hljs-built_in">Load2</span>(clu_task_start_index * <span class="hljs-number">8</span> <span class="hljs-comment">/*sizeof(uint2)*/</span>);<br>        <span class="hljs-type">const</span> uint cluster_task_instance_index = cluster_task.x;<br>        <span class="hljs-type">const</span> uint cluster_task_clu_start_index = cluster_task.y;<br>        <span class="hljs-built_in">ProcessCluster</span>(cluster_task_instance_index, cluster_task_clu_start_index + group_index);<br>    &#125;<br>    clu_task_start_index = <span class="hljs-number">0xFFFFFFFF</span>u;<br>&#125;<br><br><span class="hljs-type">int</span> node_task_num = group_node_task_num;<br><span class="hljs-keyword">if</span> (has_node_task &amp;&amp; node_task_num == <span class="hljs-number">0</span>)<br>&#123;<br>    has_node_task = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Generate-Indirect-Draw-Command"><a href="#Generate-Indirect-Draw-Command" class="headerlink" title="Generate Indirect Draw Command"></a>Generate Indirect Draw Command</h1><p>An indirect draw command is generated during cluster culling. SimNanite uses <strong>software rasterization</strong> for those clusters that are small enough, which is the same as UE’s Nanite solution.</p><p align="center">    <img src="/resource/simnanite/image/generate_indirect_draw.png" width="70%" height="70%"></p><p>SimNanite uses instance ID to index the cluster buffer for hardware rasterization. For software rasterization, SimNanite uses group ID to index the cluster buffer. Each compute group processes one cluster triangle.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SIndirectDrawParameters indirect_draw_parameters;<br>indirect_draw_parameters.vertex_count = <span class="hljs-number">1701</span>;<br>indirect_draw_parameters.instance_count = hardware_indirect_draw_num.<span class="hljs-built_in">Load</span>(<span class="hljs-number">0</span>);<br>indirect_draw_parameters.start_vertex_location = <span class="hljs-number">0</span>;<br>indirect_draw_parameters.start_instance_location = <span class="hljs-number">0</span>;<br>hardware_draw_indirect[<span class="hljs-number">0</span>] = indirect_draw_parameters;<br><br>SIndirectDispatchCmd indirect_dispatch_parameters;<br>indirect_dispatch_parameters.thread_group_count_x = software_indirect_draw_num.<span class="hljs-built_in">Load</span>(<span class="hljs-number">0</span>);<br>indirect_dispatch_parameters.thread_group_count_y = <span class="hljs-number">1</span>;<br>indirect_dispatch_parameters.thread_group_count_z = <span class="hljs-number">1</span>;<br>software_draw_indirect[<span class="hljs-number">0</span>] = indirect_dispatch_parameters;<br></code></pre></td></tr></table></figure><h1 id="Hardware-Rasterization"><a href="#Hardware-Rasterization" class="headerlink" title="Hardware Rasterization"></a>Hardware Rasterization</h1><p>SimNanite uses indirect draw instances for hardware rasterization clusters. Vertex shaders index clusters by instance ID. Clusters store the information about the vertex buffer range. It should be noticed that all vertex buffers in the <strong>scene are merged into a global single buffer</strong>. Otherwise, we can rasterize the scene only with an indirect draw call if we don’t merge buffers together. UE’s Nanite also implement a complicated steaming solution for the global scene vertex buffer mannagement.</p><p align="center">    <img src="/resource/simnanite/image/hardware_indirect_draw.png" width="70%" height="70%"></p><p>We load the vertex position data indexed by scene index buffer and culled from cluster buffer. After MVP transform, we store the cluster index and triangle index into the visibility buffer. In additional, we store the material index to the material ID buffer, which will be used as depth test buffer in the latter rendering pass.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(vertex_id &lt; index_count)<br>&#123;<br>    uint index_read_pos = start_index_location + vertex_id;<br><br>    uint vertex_index_idx = global_index_buffer.<span class="hljs-built_in">Load</span>(index_read_pos * <span class="hljs-number">4</span><span class="hljs-comment">/*sizeof int*/</span>);<br>    uint vertex_idx = vertex_index_idx + start_vertex_location;<br><br>    float3 vertex_position = <span class="hljs-built_in">asfloat</span>(global_vertex_pos_buffer.<span class="hljs-built_in">Load3</span>((vertex_idx * <span class="hljs-number">3</span>)* <span class="hljs-number">4</span><span class="hljs-comment">/*sizeof int*/</span>));<br><br>    uint triangle_id = vertex_id / <span class="hljs-number">3</span>;<br>    uint visibility_value = triangle_id &amp; <span class="hljs-number">0x0000FFFF</span>u;<br>    visibility_value = visibility_value | <span class="hljs-built_in">uint</span>(instance_id &lt;&lt; <span class="hljs-number">16u</span>);<br><br>    float4 position = <span class="hljs-built_in">float4</span>(vertex_position, <span class="hljs-number">1.0</span>);<br>    float3 worldPos = <span class="hljs-built_in">mul</span>(cluster_draw.world_matrix, position).xyz;<br>    vsOutput.position = <span class="hljs-built_in">mul</span>(ViewProjMatrix, <span class="hljs-built_in">float4</span>(worldPos, <span class="hljs-number">1.0</span>));<br>    vsOutput.visibility_value = visibility_value;<br>    vsOutput.material_idx = cluster_draw.material_idx;<br>&#125;<br></code></pre></td></tr></table></figure><p>Bellow is the visibility buffer visualization:</p><p align="center">    <img src="/resource/simnanite/image/visibility_buffer.png" width="100%" height="100%"></p><h1 id="Software-Rasterization"><a href="#Software-Rasterization" class="headerlink" title="Software Rasterization"></a>Software Rasterization</h1><p>In cases of triangles that are small enough, we use software rasterization by the compute shader. Each thread in the compute group processes one triangle. First, load the vertex position buffer based on the triangle index and the cluster index.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint start_index_this_triangle = start_index_location + triangle_index * <span class="hljs-number">3</span>;<br>uint3 indices = global_index_buffer.<span class="hljs-built_in">Load3</span>((start_index_this_triangle / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> * <span class="hljs-number">4</span> <span class="hljs-comment">/* 3 * sizeof(uint) */</span>);<br><br>float3 vertex_pos_a = <span class="hljs-built_in">asfloat</span>(global_vertex_pos_buffer.<span class="hljs-built_in">Load3</span>((start_vertex_location + indices.x) * <span class="hljs-number">3</span> * <span class="hljs-number">4</span> <span class="hljs-comment">/* 3 * sizeof(float)*/</span>));<br>float3 vertex_pos_b = <span class="hljs-built_in">asfloat</span>(global_vertex_pos_buffer.<span class="hljs-built_in">Load3</span>((start_vertex_location + indices.y) * <span class="hljs-number">3</span> * <span class="hljs-number">4</span> <span class="hljs-comment">/* 3 * sizeof(float)*/</span>));<br>float3 vertex_pos_c = <span class="hljs-built_in">asfloat</span>(global_vertex_pos_buffer.<span class="hljs-built_in">Load3</span>((start_vertex_location + indices.z) * <span class="hljs-number">3</span> * <span class="hljs-number">4</span> <span class="hljs-comment">/* 3 * sizeof(float)*/</span>));<br></code></pre></td></tr></table></figure><p>Then, calculate the screen position based on the cluster instance world matrix and view projection matrix.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float4x4 world_matrix = cluster_draw.world_matrix;<br>        <br>float4 worldPos_a = <span class="hljs-built_in">mul</span>(world_matrix, position_a).xyzw;<br>float4 worldPos_b = <span class="hljs-built_in">mul</span>(world_matrix, position_b).xyzw;<br>float4 worldPos_c = <span class="hljs-built_in">mul</span>(world_matrix, position_c).xyzw;<br><br>float4 clip_pos_a = <span class="hljs-built_in">mul</span>(ViewProjMatrix, worldPos_a);<br>float4 clip_pos_b = <span class="hljs-built_in">mul</span>(ViewProjMatrix, worldPos_b);<br>float4 clip_pos_c = <span class="hljs-built_in">mul</span>(ViewProjMatrix, worldPos_c);<br><br>float3 ndc_pos_a = <span class="hljs-built_in">float3</span>(clip_pos_a.xyz / clip_pos_a.w);<br>float3 ndc_pos_b = <span class="hljs-built_in">float3</span>(clip_pos_b.xyz / clip_pos_b.w);<br>float3 ndc_pos_c = <span class="hljs-built_in">float3</span>(clip_pos_c.xyz / clip_pos_c.w);<br><br>float4 screen_pos_a = <span class="hljs-built_in">float4</span>((ndc_pos_a.x + <span class="hljs-number">1.0f</span>) * <span class="hljs-number">0.5f</span> * rendertarget_size.x, (ndc_pos_a.y + <span class="hljs-number">1.0f</span>) * <span class="hljs-number">0.5f</span> * rendertarget_size.y, ndc_pos_a.z, clip_pos_a.w); <br>float4 screen_pos_b = <span class="hljs-built_in">float4</span>((ndc_pos_b.x + <span class="hljs-number">1.0f</span>) * <span class="hljs-number">0.5f</span> * rendertarget_size.x, (ndc_pos_b.y + <span class="hljs-number">1.0f</span>) * <span class="hljs-number">0.5f</span> * rendertarget_size.y, ndc_pos_b.z, clip_pos_b.w); <br>float4 screen_pos_c = <span class="hljs-built_in">float4</span>((ndc_pos_c.x + <span class="hljs-number">1.0f</span>) * <span class="hljs-number">0.5f</span> * rendertarget_size.x, (ndc_pos_c.y + <span class="hljs-number">1.0f</span>) * <span class="hljs-number">0.5f</span> * rendertarget_size.y, ndc_pos_c.z, clip_pos_c.w); <br></code></pre></td></tr></table></figure><p>Execute the back face culling process.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">IsBackFace</span>(ndc_pos_a, ndc_pos_b, ndc_pos_c))<br>&#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Rasterize the screen pixels covered by triangles. This is the simplest implementation and can be optimized in the future.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">int2 bbox_min = (int2)<span class="hljs-built_in">min</span>(screen_pos_a.xy,  <span class="hljs-built_in">min</span>(screen_pos_b.xy, screen_pos_c.xy));<br>int2 bbox_max = (int2)<span class="hljs-built_in">max</span>(screen_pos_a.xy,  <span class="hljs-built_in">max</span>(screen_pos_b.xy, screen_pos_c.xy));<br><br><span class="hljs-keyword">if</span>(bbox_max.x &gt; <span class="hljs-number">0</span> &amp;&amp; bbox_max.y &gt; <span class="hljs-number">0</span> &amp;&amp; bbox_min.x &lt; rendertarget_size.x &amp;&amp; bbox_min.y &lt; rendertarget_size.y)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = bbox_min.y; y &lt;= bbox_max.y; y++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = bbox_min.x; x &lt;= bbox_max.x; x++)<br>        &#123;<br>            ......<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Finally, we calculate the barycentric coordinates and screen depth of this pixel. The compute shader is not able to perform a hardware depth test, so we convert the depth value type from float to int and use <strong>InterlockedMax</strong> to perform a software depth test.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 barycentric = <span class="hljs-built_in">BarycentricCoordinate</span>(<span class="hljs-built_in">float2</span>(x, y), screen_pos_a.xy, screen_pos_b.xy, screen_pos_c.xy);<br><span class="hljs-keyword">if</span>(barycentric.x &gt;= <span class="hljs-number">0</span> &amp;&amp; barycentric.y &gt;= <span class="hljs-number">0</span> &amp;&amp; barycentric.z &gt;= <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-type">float</span> depth = barycentric.x * screen_pos_a.z + barycentric.y * screen_pos_b.z + barycentric.z * screen_pos_c.z;<br><br>    uint depth_uint = depth * <span class="hljs-number">0x7FFFFFFF</span>u;<br>    uint2 pixel_pos = <span class="hljs-built_in">uint2</span>(x, rendertarget_size.y - y);<br>    uint pre_depth;<br>    <span class="hljs-built_in">InterlockedMax</span>(intermediate_depth_buffer[pixel_pos], depth_uint, pre_depth);<br>    <span class="hljs-keyword">if</span> (depth_uint &gt; pre_depth)<br>    &#123;<br>        uint triangle_id = triangle_index;<br>        uint visibility_value = triangle_id &amp; <span class="hljs-number">0x0000FFFF</span>u;<br>        visibility_value = visibility_value | <span class="hljs-built_in">uint</span>(instance_id &lt;&lt; <span class="hljs-number">16u</span>);<br><br>        out_vis_buffer[pixel_pos] = visibility_value;<br>        out_mat_id_buffer[pixel_pos] = cluster_draw.material_idx;<br>        visualize_softrasterization[pixel_pos] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Below is a visualization of the software rasterization process. The <strong>green</strong> area is rasterized by the software compute shader.</p><p>Hardware Rasterization Part:</p><p align="center">    <img src="/resource/simnanite/image/vis_softraster_hard.png" width="70%" height="70%"></p><p>Software Rasterization Part:</p><p align="center">    <img src="/resource/simnanite/image/vis_softraster_soft.png" width="70%" height="70%"></p><p>Visualize Visibility Buffer:</p><p align="center">    <img src="/resource/simnanite/image/vis_softraster_visbuffer.png" width="70%" height="70%"></p><h1 id="BasePass-or-GBuffer-Pass"><a href="#BasePass-or-GBuffer-Pass" class="headerlink" title="BasePass or GBuffer Pass"></a>BasePass or GBuffer Pass</h1><p>With the visibility buffer, we can finally render the scene. First, SimNanite transfers the material index to the depth buffer, which will be used in the next pass’s depth test operation.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">ps_main</span><span class="hljs-params">(in float2 tex: TexCoord0)</span>: SV_Depth</span><br><span class="hljs-function">&#123;</span><br>    uint2 load_pos = tex * rendertarget_size;<br>    uint material_index = mat_id_buffer.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(load_pos.xy, <span class="hljs-number">0</span>));<br>    <span class="hljs-type">float</span> depth = <span class="hljs-built_in">float</span>(material_index) / <span class="hljs-number">1024.0</span>;<br>    <span class="hljs-keyword">return</span> depth;<br>&#125;<br></code></pre></td></tr></table></figure><p>Then we draw a full screen quad for each material. The depth of this quad equals to material index.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vs_main</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    in uint VertID : SV_VertexID,</span></span><br><span class="hljs-params"><span class="hljs-function">    out float2 Tex : TexCoord0,</span></span><br><span class="hljs-params"><span class="hljs-function">    out float4 Pos : SV_Position)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> depth = <span class="hljs-built_in">float</span>(material_index) / <span class="hljs-number">1024.0</span>;<br><br>    Tex = <span class="hljs-built_in">float2</span>(<span class="hljs-built_in">uint2</span>(VertID, VertID &lt;&lt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">2</span>);<br>    Pos = <span class="hljs-built_in">float4</span>(<span class="hljs-built_in">lerp</span>(<span class="hljs-built_in">float2</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>), <span class="hljs-built_in">float2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>), Tex), depth, <span class="hljs-number">1</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>Unreal’s Nanite dipatches an additional material classify pass to split the screen into tiles. Then Unreal uses indirect draw to draw the tiles generated in the previous pass, which reduces quad overdraw. In SimNanite, we remove the classify pass and draw the screen quad directly. For each material quad, we only render pixels that pass the material index depth test. Below are two material quad depth test figures. The first one is bunny material and the second one is teapot material.</p><p align="center">    <img src="/resource/simnanite/image/depth_test_0.png" width="50%" height="50%"></p><p align="center">    <img src="/resource/simnanite/image/depth_test_1.png" width="50%" height="50%"></p><p>For each pixel, SimNanite fetches the cluster index and triangle index from the visibility buffer. Then, we calculate the barycentric coordinates based on the vertex position buffer. Finally, SimNanite calculates the vertex attributes, such as pixel UV and pixel normal by barycentric coordnates. The render the material with these attributes.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">float4 <span class="hljs-title">ps_main</span><span class="hljs-params">(in float2 tex: TexCoord0)</span>: SV_Target0</span><br><span class="hljs-function">&#123;</span><br>    uint2 load_pos = tex * rendertarget_size;<br>    uint depth_buffer = in_depth_buffer.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(load_pos.xy,<span class="hljs-number">0</span>));<br>    float4 output_color = <span class="hljs-built_in">float4</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(depth_buffer != <span class="hljs-number">0</span>)<br>    &#123;<br>        uint visibility_value = in_vis_buffer.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(load_pos.xy,<span class="hljs-number">0</span>));<br>        uint cluster_index = visibility_value &gt;&gt; <span class="hljs-number">16</span>;<br>        uint triangle_index = visibility_value &amp; <span class="hljs-number">0x0000FFFF</span>u;<br><br>        <span class="hljs-comment">// calculate vertex attributes</span><br>        <span class="hljs-comment">// ......</span><br><br>        float3 barycentric = <span class="hljs-built_in">BarycentricCoordinate</span>(<span class="hljs-built_in">float2</span>(load_pos.x, rendertarget_size.y - load_pos.y), screen_pos_a.xy, screen_pos_b.xy, screen_pos_c.xy);<br>        <span class="hljs-type">float</span> z = <span class="hljs-number">1</span> / (barycentric.x / position_a.w + barycentric.y / position_b.w + barycentric.z / position_c.w);<br>        barycentric = barycentric / <span class="hljs-built_in">float3</span>(position_a.w, position_b.w, position_c.w) * z;<br><br>        float2 vertex_uv_a = <span class="hljs-built_in">asfloat</span>(global_vertex_uv_buffer.<span class="hljs-built_in">Load2</span>((start_vertex_location + indices.x) * <span class="hljs-number">2</span> * <span class="hljs-number">4</span> <span class="hljs-comment">/* 2 * sizeof(float)*/</span>));<br>        float2 vertex_uv_b = <span class="hljs-built_in">asfloat</span>(global_vertex_uv_buffer.<span class="hljs-built_in">Load2</span>((start_vertex_location + indices.y) * <span class="hljs-number">2</span> * <span class="hljs-number">4</span> <span class="hljs-comment">/* 2 * sizeof(float)*/</span>));<br>        float2 vertex_uv_c = <span class="hljs-built_in">asfloat</span>(global_vertex_uv_buffer.<span class="hljs-built_in">Load2</span>((start_vertex_location + indices.z) * <span class="hljs-number">2</span> * <span class="hljs-number">4</span> <span class="hljs-comment">/* 2 * sizeof(float)*/</span>));<br><br>        float2 pix_uv = vertex_uv_a * barycentric.x + vertex_uv_b * barycentric.y + vertex_uv_c * barycentric.z;<br>        float4 baseColor = baseColorTexture.<span class="hljs-built_in">Sample</span>(baseColorSampler, pix_uv);<br>        output_color = <span class="hljs-built_in">float4</span>(baseColor.xyz, <span class="hljs-number">1.0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Bellow is the SimNanite final result:</p><p align="center">    <img src="/resource/simnanite/image/final0.png" width="50%" height="50%"></p><p align="center">    <img src="/resource/simnanite/image/final1.png" width="50%" height="50%"></p><p><a href="https://github.com/ShawnTSH1229/SimNanite"><u><strong>simplified nanite code</strong></u></a></p>]]></content>
    
    
    <categories>
      
      <category>My Projects</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sky Atmosphere In XEngine</title>
    <link href="/2024/05/05/Sky-Atmosphere-In-XEngine/"/>
    <url>/2024/05/05/Sky-Atmosphere-In-XEngine/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Note</strong> that this <a href="https://github.com/lvcheng1229/XEnigine/blob/main/Source/Shaders/SkyAtmosphere.hlsl"><u><strong>Project</strong></u></a>  was written during my undergraduate studies. Some points may be incorrect.</p></blockquote><h1 id="Brief-Introduction-to-UE’s-Implementation"><a href="#Brief-Introduction-to-UE’s-Implementation" class="headerlink" title="Brief Introduction to UE’s Implementation"></a>Brief Introduction to UE’s Implementation</h1><p>This project is based on the implementation of the <strong>unreal engine</strong>. I assume that you have a basic knowledge of volume rendering and will <strong>not go into detail</strong> about it. If you are interested, you can read my blog about <a href="https://shawntsh1229.github.io/2024/05/05/Volume-Rendering-In-Offline-Rendering/"><u><strong>Volume Rendering In Offline Rendering</strong></u></a>.<br>Here are some basic terms about the sky atmosphere rendering:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: absorption coefficient, the probability density that light is absorbed per unit distance traveled in the medium.<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: scattering coefficient, the probability of an out-scattering event occurring per unit distance.<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: attenuation coefficient, the sum of the absorption coefficient and the scattering coefficient, describes the combined effect of the absorption and out scattering.<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>t</mi></msub><mo>=</mo><msub><mi>σ</mi><mi>a</mi></msub><mo>+</mo><msub><mi>σ</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_{t} = \sigma_{a} + \sigma_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>: transmittance, the fraction of radiance that is transmitted between two points<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><msub><mi>σ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>s</mi></mrow></msup></mrow><annotation encoding="application/x-tex">T(a,b)=e^{-\int_{a}^{b}\sigma_{t}(h)\mathrm{d}s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0358em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0358em;"><span style="top:-3.072em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9482em;"><span style="top:-2.1225em;margin-left:-0.1945em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-2.9521em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3775em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2963em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span><span class="mord mathrm mtight">d</span><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">\phi_{u}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: phase function, the angular distribution of scattered radiation at a point<br><p><strong>Volume Rendering Euqation</strong>:<br>The lighting result at the point x from direct v equals the combination of single scattering and multi-scattering:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>L</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>L</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(x,v) = L_{1}(x,v) + L_{n}(x,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span><br><p>The single scattering result at point x from point p in direction v is the sum of the transmitted radiance reflected from the ground and the integration of the radiance from the view point to the ground or sky:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>p</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><msub><mi>L</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo>+</mo><msub><mi>t</mi><mrow><mi>a</mi><mi>t</mi><mi>m</mi><mi>o</mi></mrow></msub><msub><mi>l</mi><mi>i</mi></msub><mo stretchy="false">)</mo><msub><mi>ϕ</mi><mi>u</mi></msub><msub><mi>E</mi><mi>i</mi></msub><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">L_{1}(x,p,v) = T(x,p)L_{0}(p,v)+\int_{t=0}^{||p-x||}\sigma_{s}T(x,x-tv)T(x-tv,x-tv+t_{atmo}l_{i})\phi_{u}E_{i}\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6984em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span><br><p>N-bounce multi-scattering (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">L_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) integrate the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">G_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in the point along the view direction, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">G_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is the integration of the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">L_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> scattering result from the direction on the sphere. Multi-Scattering is difficult to calculate compared to Single-Scattering. There are many simplifications that are made in UE’s sky-atmosphere for multi-scattering, we will be introducing it later.</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><msub><mi>G</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo separator="true">,</mo><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">L_{n}(x,v) = \int_{t=0}^{||p-x||}\sigma_{s}(x)T(x,x-tv)G_{n}(x-tv,-v)\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>L</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><msub><mi>ϕ</mi><mi>u</mi></msub><mi mathvariant="normal">d</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">G_{n}(x,v)=\int_{\Omega}L_{n-1}(x,-v)\phi_{u}\mathrm{d}w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span><h1 id="Transmittance-LUT"><a href="#Transmittance-LUT" class="headerlink" title="Transmittance LUT"></a>Transmittance LUT</h1><p>There are two important properties of beam transmittance. The first property is that the transmittance between two points is the same in both directions if the attenuation coefficient satisfies the directional symmetry <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>σ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mo>−</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{t}(w) = \sigma_{t}(-w) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(a,b) = T(b,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span><p>Another important property, true in all media, is that transmittance is multiplicative along points on a ray:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(a,b) = T(a,c) T(c,b) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span><p>This property enables us to calculate the transmittance between any two points quickly by precalculating the transmittance between these two points and the boundary of the sky atmosphere:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mi>n</mi><mi>a</mi><mi>r</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>b</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mi>n</mi><mi>a</mi><mi>r</mi><mi>y</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">T(a,b) = \frac{T(a,boundnary)} {T(b,boundnary)} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">b</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">na</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ry</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">na</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ry</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> is a 3-dimensional function of the dimension x,y and z. We can convert this function to a 2-dimensional function of the view height and view zenith angle, since the earth is symmetric horizontally.<p align="center">    <img src="/resource/skyatmosphere/image/lut_104.png" width="64%" height="64%"></p><p>Transmittance lut’s u coordinate is view zenith cosine angle ranging from -1 to 1. In addition, the v coordinate is mapped to the view height ranging from the bottom radius to the top radius. Bruneton’s paper use a generic mapping, working for any atmosphere, but still providing an increased sampling rate near the horizon. In the following figure, the red curve represents Bruneton’s implementation, while the purple curve represents a linear interpolation.</p><p align="center">    <img src="/resource/skyatmosphere/image/view_height.png" width="50%" height="50%"></p><p>We can get the world position and world direction from the view height and the view zenith angle mapped from the texture coordinates.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float2 UV = (PixPos) * SkyAtmosphere_TransmittanceLutSizeAndInvSize.zw;<br><br><span class="hljs-type">float</span> ViewHeight;<br><span class="hljs-type">float</span> ViewZenithCosAngle;<br><span class="hljs-built_in">UvToLutTransmittanceParams</span>(ViewHeight, ViewZenithCosAngle, UV);<br><br>float3 WorldPos = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0.0f</span>, ViewHeight, <span class="hljs-number">0</span>);<br>float3 WorldDir = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0.0f</span>, ViewZenithCosAngle,<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0f</span> - ViewZenithCosAngle * ViewZenithCosAngle));<br></code></pre></td></tr></table></figure><p>The next step is to calculate optical depth. It is an intergal along the direction of view from the point of view to the boundary of the atmosphere:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><msubsup><mo>∫</mo><mn>0</mn><mi>p</mi></msubsup><msub><mi>σ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mi>d</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\tau(s)= -\int_{0}^{p} \sigma_{t}(s)ds</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2151em;vertical-align:-0.3558em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8593em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span></span></span></span><p>This equation is viewed as a ray marching from the view point to the boundary for coding:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> dt = tMax / SampleCount;<br>float3 OpticalDepth = <span class="hljs-number">0.0f</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">float</span> SampleI = <span class="hljs-number">0.0f</span>; SampleI &lt; SampleCount; SampleI += <span class="hljs-number">1.0f</span>)<br>&#123;<br>    t = tMax * (SampleI + DEFAULT_SAMPLE_OFFSET) / SampleCount;<br>float3 P = WorldPos + t * WorldDir;<br>MediumSampleRGB Medium = <span class="hljs-built_in">SampleMediumRGB</span>(P);<br>    <span class="hljs-type">const</span> float3 SampleOpticalDepth = Medium.Extinction * dt;<br>OpticalDepth += SampleOpticalDepth;<br>&#125;<br><span class="hljs-keyword">return</span> OpticalDepth;<br></code></pre></td></tr></table></figure><p>The medium extinction contains two parts: mie extinction and rayleigh extinction, which is a expontial function of the view height:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>σ</mi><mrow><mi>t</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>σ</mi><mrow><mi>t</mi><mi mathvariant="normal">_</mi><mi>r</mi><mi>a</mi><mi>y</mi><mi>l</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow></msub><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{t}(h) = \sigma_{t\_mi}(h) + \sigma_{t\_rayleigh}(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.117em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight">mi</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.117em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span><p>Participating media following the Rayleigh and Mie theories have an altitude density distribution of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi><mfrac><mrow><mo>−</mo><mi>h</mi></mrow><mrow><mn>8</mn><mi>k</mi><mi>m</mi></mrow></mfrac></msup></mrow><annotation encoding="application/x-tex">d_{t\_mi}(h) = e^{\frac{-h}{8km}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.117em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight">mi</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.979em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.979em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.88em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">8</span><span class="mord mathnormal mtight">km</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi mathvariant="normal">_</mi><mi>r</mi><mi>a</mi><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi><mfrac><mrow><mo>−</mo><mi>h</mi></mrow><mrow><mn>1.2</mn><mi>k</mi><mi>m</mi></mrow></mfrac></msup></mrow><annotation encoding="application/x-tex">d_{t\_ray}(h) = e^{\frac{-h}{1.2km}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.117em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.979em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.979em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.88em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1.2</span><span class="mord mathnormal mtight">km</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span> , respectively.<br>Rayleigh participation media components have different coefficients, which results in a blue sky at noon and a red sky at dusk.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">MediumSampleRGB <span class="hljs-title">SampleMediumRGB</span><span class="hljs-params">(in float3 WorldPos)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> SampleHeight = <span class="hljs-built_in">max</span>(<span class="hljs-number">0.0</span>, (<span class="hljs-built_in">length</span>(WorldPos) - Atmosphere_BottomRadiusKm));<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> DensityMie = <span class="hljs-built_in">exp</span>(Atmosphere_MieDensityExpScale * SampleHeight);<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> DensityRay = <span class="hljs-built_in">exp</span>(Atmosphere_RayleighDensityExpScale * SampleHeight);<br><br>    MediumSampleRGB s;<br><br>    s.ScatteringMie = DensityMie * Atmosphere_MieScattering.rgb;<br>    s.AbsorptionMie = DensityMie * Atmosphere_MieAbsorption.rgb;<br>    s.ExtinctionMie = DensityMie * Atmosphere_MieExtinction.rgb; <span class="hljs-comment">// equals to  ScatteringMie + AbsorptionMie</span><br><br>    s.ScatteringRay = DensityRay * Atmosphere_RayleighScattering.rgb;<br>    s.AbsorptionRay = <span class="hljs-number">0.0f</span>;<br>    s.ExtinctionRay = s.ScatteringRay + s.AbsorptionRay;<br><br>    s.Scattering = s.ScatteringMie + s.ScatteringRay;<br>    s.Absorption = s.AbsorptionMie + s.AbsorptionRay;<br>    s.Extinction = s.ExtinctionMie + s.ExtinctionRay;<br>    s.Albedo = <span class="hljs-built_in">GetAlbedo</span>(s.Scattering, s.Extinction);<br><br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>Here is the transmittance LUT result. We ignore the ozone’s contribution, which results in the absence of the purple region in the LUT:</p><p align="center">    <img src="/resource/skyatmosphere/image/lut_visualize.png" width="75%" height="75%"></p><h1 id="Multi-Scattering"><a href="#Multi-Scattering" class="headerlink" title="Multi-Scattering"></a>Multi-Scattering</h1><p>As we mentioned above, it’s difficult to calculate the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">G_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, unreal engine makes two simplification for this part.<br>The first simplification is:</p><blockquote><p>Scattering events with order greater or equal to 2 are executed using an isotropic phase function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">\phi_{u}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></blockquote><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>L</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><msub><mi>ϕ</mi><mi>u</mi></msub><mi mathvariant="normal">d</mi><mi>w</mi><mo>≈</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>L</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">G_{n}(x,v)=\int_{\Omega}L_{n-1}(x,-v)\phi_{u}\mathrm{d}w\approx \frac{1}{4\pi}\int_{\Omega}L_{n-1}(x,-v)\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2009em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span><br><br><p>The second simplification is:</p><blockquote><p>All points within the neighborhood of the position we currently shade receive the same amount of second order scattered light</p></blockquote><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo separator="true">,</mo><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi><mo>≈</mo><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">L_{n-1}(x,v) = \int_{t=0}^{||p-x||}\sigma_{s}(x)T(x,x-tv)G_{n-1}(x-tv,-v)\mathrm{d}t\approx G_{n-1}\int_{t=0}^{||p-x||}\sigma_{s}(x)T(x,x-tv)\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span><br><br><p>Combine these equation together, we get:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>≈</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>L</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>w</mi><mo>≈</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi><mi mathvariant="normal">d</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">G_{n}(x,v)\approx \frac{1}{4\pi}\int_{\Omega}L_{n-1}(x,-v)\mathrm{d}w\approx \frac{1}{4\pi} G_{n-1}\int_{\Omega}\int_{t=0}^{||p-x||}\sigma_{s}(x)T(x,x-tv)\mathrm{d}t\mathrm{d}w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2009em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span><br><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><msub><mi>G</mi><mi>n</mi></msub><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi><mi mathvariant="normal">d</mi><mi>w</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mi mathvariant="normal">d</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\frac{G_{n}}{G_{n-1}} = \frac{1}{4\pi}\int_{\Omega}\int_{t=0}^{||p-x||}\sigma_{s}(x)T(x,x-tv)\mathrm{d}t\mathrm{d}w = \frac{1}{4\pi}\int_{\Omega}f_{ms}\mathrm{d}w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3752em;vertical-align:-0.4868em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2025em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4868em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2009em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span><br><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mo>=</mo><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">f_{ms}=\int_{t=0}^{||p-x||}\sigma_{s}(x)T(x,x-tv)\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span><br><p>Our next step is to precompute the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mi mathvariant="normal">d</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\frac{1}{4\pi}\int_{\Omega}f_{ms}\mathrm{d}w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2009em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> value and store it in the two-dimensional LUT table.UE’s sky atmosphere has three different integration methods for different quality levels. The first implementation is to integrate the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{ms}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> on the uniform sphere, which is expensive and only used in case of high quality.The second one is to integrate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{ms}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 8 times with the following ray direction:</p><p align="center">    <img src="/resource/skyatmosphere/image/ray_dir.png" width="50%" height="50%"></p><p>What we employed in the xengine is the last approach: sample twice from the view direction and negative direction:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><msub><mi>G</mi><mi>n</mi></msub><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mi mathvariant="normal">d</mi><mi>w</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><mo stretchy="false">(</mo><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>∗</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\frac{G_{n}}{G_{n-1}}=\frac{1}{4\pi}\int_{\Omega}f_{ms}\mathrm{d}w=\frac{1}{4\pi}(f_{ms}(x,v) + f_{ms}(x,-v)) * 0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3752em;vertical-align:-0.4868em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2025em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4868em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2009em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.5</span></span></span></span><br><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mo>=</mo><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">f_{ms}=\int_{t=0}^{||p-x||}\sigma_{s}(x)T(x,x-tv)\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> dt = tMax / SampleCount;<br>float3 Throughput = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">float</span> SampleI = <span class="hljs-number">0.0f</span>; SampleI &lt; SampleCount; SampleI += <span class="hljs-number">1.0f</span>)<br>&#123;<br>    t = tMax * (SampleI + DEFAULT_SAMPLE_OFFSET) / SampleCount;<br>    float3 P = WorldPos + t * WorldDir;<br>    <span class="hljs-type">float</span> PHeight = <span class="hljs-built_in">length</span>(P);<br><br>MediumSampleRGB Medium = <span class="hljs-built_in">SampleMediumRGB</span>(P);<br>    <span class="hljs-type">const</span> float3 SampleOpticalDepth = Medium.Extinction * dt * <span class="hljs-number">1.0f</span>;<br>    <span class="hljs-type">const</span> float3 SampleTransmittance = <span class="hljs-built_in">exp</span>(-SampleOpticalDepth);<br><br>MultiScatAs1 += Throughput * Medium.Scattering * <span class="hljs-number">1.0f</span> * dt;<br><br>    Throughput *= SampleTransmittance;<br>&#125;<br>OutMultiScatAs1=MultiScatAs1;<br></code></pre></td></tr></table></figure><p>With <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{ms}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, we can precompute the multi-scattering result in arbitray rorder.</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>2</mn></msub><mo>=</mo><msub><mi>G</mi><mn>1</mn></msub><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mo>=</mo><msub><mi>L</mi><mn>1</mn></msub><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">G_{2}=G_{1}f_{ms}=L_{1}\frac{1}{4\pi}f_{ms}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>3</mn></msub><mo>=</mo><msub><mi>G</mi><mn>2</mn></msub><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mo>=</mo><msub><mi>G</mi><mn>1</mn></msub><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mo>=</mo><msub><mi>L</mi><mn>1</mn></msub><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msubsup><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">G_{3}=G_{2}f_{ms}=G_{1}\frac{1}{4\pi}f_{ms}f_{ms}=L_{1}\frac{1}{4\pi}f_{ms}^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub><mo>=</mo><msub><mi>L</mi><mn>1</mn></msub><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msubsup><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">G_{n}=L_{1}\frac{1}{4\pi}f_{ms}^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub><mo>+</mo><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>G</mi><mn>1</mn></msub><mo>=</mo><msub><mi>L</mi><mn>1</mn></msub><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><mo stretchy="false">(</mo><msubsup><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo>+</mo><msubsup><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msubsup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>L</mi><mn>1</mn></msub><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><mo stretchy="false">(</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G_{n}+G_{n-1}+ ... +G_{1}=L_{1}\frac{1}{4\pi}(f_{ms}^{n-1} +f_{ms}^{n-2}+ ... +1)=L_{1}\frac{1}{4\pi}(\frac{1}{1-f_{ms}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0611em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3262em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.1076em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span><br><p>The single scattering result <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is required to compute by the time of the  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{ms}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>  calculation.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 OutL_0, OutMultiScatAs1_0, OutL_1, OutMultiScatAs1_1;<br><span class="hljs-built_in">ComputeScattedLightLuminanceAndMultiScatAs1in</span>(<br>    WorldPos, WorldDir, LightDir, OneIlluminance,<br>    SkyAtmosphere_MultiScatteringSampleCount, OutL_0, OutMultiScatAs1_0);<br><span class="hljs-built_in">ComputeScattedLightLuminanceAndMultiScatAs1in</span>(<br>    WorldPos, -WorldDir, LightDir, OneIlluminance,<br>    SkyAtmosphere_MultiScatteringSampleCount, OutL_1, OutMultiScatAs1_1);<br><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> SphereSolidAngle = <span class="hljs-number">4.0f</span> * PI;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> IsotropicPhase = <span class="hljs-number">1.0f</span> / SphereSolidAngle;<br><br>float3 IntegratedIlluminance = (SphereSolidAngle / <span class="hljs-number">2.0f</span>) * (OutL_0 + OutL_1);<br>float3 MultiScatAs1 = (<span class="hljs-number">1.0f</span> / <span class="hljs-number">2.0f</span>) * (OutMultiScatAs1_0 + OutMultiScatAs1_1);<br>float3 InScatteredLuminance = IntegratedIlluminance * IsotropicPhase;<br><br><span class="hljs-comment">// For a serie, sum_&#123;n=0&#125;^&#123;n=+inf&#125; = 1 + r + r^2 + r^3 + ... + r^n = 1 / (1.0 - r)</span><br><span class="hljs-type">const</span> float3 R = MultiScatAs1;<br><span class="hljs-type">const</span> float3 SumOfAllMultiScatteringEventsContribution = <span class="hljs-number">1.0f</span> / (<span class="hljs-number">1.0f</span> - R);<br>float3 L = InScatteredLuminance * SumOfAllMultiScatteringEventsContribution;<br></code></pre></td></tr></table></figure><h1 id="Sky-View-LUT"><a href="#Sky-View-LUT" class="headerlink" title="Sky-View LUT"></a>Sky-View LUT</h1><p>With the precomputed transmittance LUT and the multi-scattering result, it’s enough to ray marhcing the sky atmosphere with a low number of samples: </p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi>b</mi></msubsup><mo stretchy="false">(</mo><msub><mi>L</mi><mn>1</mn></msub><mo>+</mo><msub><mi>σ</mi><mi>s</mi></msub><msub><mi>G</mi><mrow><mi>a</mi><mi>l</mi><mi>l</mi></mrow></msub><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">L = \int_{0}^{b}(L_{1} + \sigma_{s}G_{all})\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3998em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">ll</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span><br><br><p>We can get the multi-scattering term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mrow><mi>a</mi><mi>l</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">G_{all}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">ll</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> by looking up the LUT precomputed before.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 MultiScatteredLuminance0 = MultiScatteredLuminanceLutTexture.<span class="hljs-built_in">SampleLevel</span>(gsamLinearClamp, MultiSactterUV, <span class="hljs-number">0</span>).rgb;<br></code></pre></td></tr></table></figure><p>The remaining single scattering term is the integration along the view direction:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi>b</mi></msubsup><mo stretchy="false">(</mo><mi>V</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>σ</mi><mrow><mi>s</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>i</mi><mi>e</mi></mrow></msub><msub><mi>ϕ</mi><mrow><mi>m</mi><mi>i</mi><mi>e</mi></mrow></msub><mo>+</mo><msub><mi>σ</mi><mrow><mi>s</mi><mi mathvariant="normal">_</mi><mi>r</mi><mi>a</mi><mi>y</mi></mrow></msub><msub><mi>ϕ</mi><mrow><mi>r</mi><mi>a</mi><mi>y</mi></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>σ</mi><mi>s</mi></msub><msub><mi>G</mi><mrow><mi>a</mi><mi>l</mi><mi>l</mi></mrow></msub><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">L = \int_{0}^{b}(Vis(p,v)T(p,v)(\sigma_{s\_mie}\phi_{mie}+ \sigma_{s\_ray}\phi_{ray})+\sigma_{s}G_{all})\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.411em;vertical-align:-0.367em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">Vi</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight">mi</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">mi</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.117em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">ll</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span>, where Vis is the shadow term in this position and the transmittance term is obtained from transmittance lut.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 TransmittanceToLight0 = TransmittanceLutTexture.<span class="hljs-built_in">SampleLevel</span>(gsamLinearClamp, UV, <span class="hljs-number">0</span>).rgb;<br>float3 PhaseTimesScattering0 = Medium.ScatteringMie * MiePhaseValueLight0 + Medium.ScatteringRay * RayleighPhaseValueLight0;<br><br><span class="hljs-type">float</span> tPlanet0 = <span class="hljs-built_in">RaySphereIntersectNearest</span>(P, Light0Dir, PlanetO + PLANET_RADIUS_OFFSET * UpVector, Atmosphere_BottomRadiusKm);<br><span class="hljs-type">float</span> PlanetShadow0 = tPlanet0 &gt;= <span class="hljs-number">0.0f</span> ? <span class="hljs-number">0.0f</span> : <span class="hljs-number">1.0f</span>;<br>float3 S = Light0Illuminance * (PlanetShadow0 * TransmittanceToLight0 * PhaseTimesScattering0 + MultiScatteredLuminance0 * Medium.Scattering);<br></code></pre></td></tr></table></figure><p>Another important term is the phase function term, which indicates the relative ratio of light lost in a particular direction after a scattering event. Here is the rayleigh phase function. The <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>3</mn><mrow><mn>16</mn><mi>π</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{3}{16\pi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> coefficient serves as a normalisation factor, so that the integral over a unit sphere is 1:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mrow><mi>r</mi><mi>a</mi><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>3</mn><mrow><mn>16</mn><mi>π</mi></mrow></mfrac><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>c</mi><mi>o</mi><msup><mi>s</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi_{ray}(\theta)=\frac{3}{16\pi}(1+cos^{2}(\theta))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">))</span></span></span></span><br><br><p>We use the simpler Henyey-Greenstein phase function for mie scattering:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">HgPhase</span><span class="hljs-params">(<span class="hljs-type">float</span> G, <span class="hljs-type">float</span> CosTheta)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> Numer = <span class="hljs-number">1.0f</span> - G * G;<br>    <span class="hljs-type">float</span> Denom = <span class="hljs-number">1.0f</span> + G * G + <span class="hljs-number">2.0f</span> * G * CosTheta;<br>    <span class="hljs-keyword">return</span> Numer / (<span class="hljs-number">4.0f</span> * PI * Denom * <span class="hljs-built_in">sqrt</span>(Denom));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Latitude-Longtitude-Texture"><a href="#Latitude-Longtitude-Texture" class="headerlink" title="Latitude&#x2F;Longtitude Texture"></a>Latitude&#x2F;Longtitude Texture</h2><p>UE’s implementation renders the distant sky into a latitude&#x2F;longtitude sky-view LUT texture in a low resolution and upscales the texture on the lighting pass.In order to better represent the high-frequency visual features toward the horizon, unreal engine applies a non-linear transformation to the latitude l when computing the texture coordinate v in [0,1] that will compress more texels near the horizon:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>=</mo><mn>0.5</mn><mo>+</mo><mn>0.5</mn><mo>∗</mo><mi>s</mi><mi>i</mi><mi>g</mi><mi>n</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo>∗</mo><msqrt><mfrac><mrow><mi mathvariant="normal">∣</mi><mi>l</mi><mi mathvariant="normal">∣</mi></mrow><mrow><mi>π</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mfrac></msqrt></mrow><annotation encoding="application/x-tex">v = 0.5 + 0.5 * sign(l) * \sqrt{\frac{|l|}{\pi/2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.61em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.23em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight">/2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.19em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.88em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.88em" viewBox="0 0 400000 1944" preserveAspectRatio="xMinYMin slice"><path d="M983 90l0 -0c4,-6.7,10,-10,18,-10 H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5zM1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.61em;"><span></span></span></span></span></span></span></span></span><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> Vhorizon = <span class="hljs-built_in">sqrt</span>(ViewHeight * ViewHeight - BottomRadius * BottomRadius);<br><span class="hljs-type">float</span> CosBeta = Vhorizon / ViewHeight;<br><span class="hljs-type">float</span> Beta = <span class="hljs-built_in">acosFast4</span>(CosBeta);<br><span class="hljs-type">float</span> ZenithHorizonAngle = PI - Beta;<br><span class="hljs-type">float</span> ViewZenithAngle = <span class="hljs-built_in">acosFast4</span>(ViewZenithCosAngle);<br><br><span class="hljs-keyword">if</span> (!IntersectGround)<br>&#123;<br>    <span class="hljs-type">float</span> Coord = ViewZenithAngle / ZenithHorizonAngle;<br>    Coord = <span class="hljs-number">1.0f</span> - Coord;<br>    Coord = <span class="hljs-built_in">sqrt</span>(Coord);<br>    Coord = <span class="hljs-number">1.0f</span> - Coord;<br>    UV.y = Coord * <span class="hljs-number">0.5f</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-type">float</span> Coord = (ViewZenithAngle - ZenithHorizonAngle) / Beta;<br>    Coord = <span class="hljs-built_in">sqrt</span>(Coord);<br>    UV.y = Coord * <span class="hljs-number">0.5f</span> + <span class="hljs-number">0.5f</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Combine-Light"><a href="#Combine-Light" class="headerlink" title="Combine Light"></a>Combine Light</h1><p>Sky-View LUT doesn’t calculate sun disk luminance, since it is high-frequency lighting, which should be computed at full resolution in the lighting pass based on the view direction and the light direction. The rest low-frequency part can be obtained by looking up the sky-view LUT directly. Below is the result of our implementation in XEngine.</p><p align="center">    <img src="/resource/skyatmosphere/image/result.png" width="80%" height="80%"></p><p><a href="https://github.com/ShawnTSH1229/XEngine"><u><strong>sky atmosphere source code</strong></u></a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Offline Volume Rendering</title>
    <link href="/2024/05/05/Offline-Volume-Rendering/"/>
    <url>/2024/05/05/Offline-Volume-Rendering/</url>
    
    <content type="html"><![CDATA[<p>Note that this blog is just a <span style="color:red"><strong>copy</strong></span> and <span style="color:red"><strong>translation</strong></span> of my <a href="https://blog.csdn.net/u010669231/article/details/107851266"><u><strong>Chinese Blog</strong></u></a> that I wrote during my undergraduate studies. Some points may be incorrect.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Virtual Shadow Map In XEngine</title>
    <link href="/2024/05/01/Virtual-Shadow-Map-In-XEngine/"/>
    <url>/2024/05/01/Virtual-Shadow-Map-In-XEngine/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Virtual Shadow Maps (VSMs) is the new shadow mapping method used in Unreal Engine 5. I implemented a <strong>simplified virtual shadow maps</strong> in my <strong>personal game engine</strong>. Here is a brief introduction from the official unreal engine 5 documentation:</p><blockquote><p>Virtual Shadow Maps have been developed with the following goals:</p><ul><li>Significantly increase shadow resolution to match highly detailed Nanite geometry</li><li>Plausible soft shadows with reasonable, controllable performance costs</li><li>Provide a simple solution that works by default with limited amounts of adjustment needed</li><li>Replace the many Stationary Light shadowing techniques with a single, unified path</li></ul><p>Conceptually, virtual shadow maps are just very <strong>high-resolution</strong> shadow maps. In their current implementation, they have a <strong>virtual resolution</strong> of 16k x 16k pixels. <strong>Clipmaps</strong> are used to increase resolution further for Directional Lights. To keep performance high at reasonable memory cost, VSMs split the &gt;shadow map into tiles (or Pages) that are 128x128 each. Pages are allocated and rendered only as needed to shade <strong>on-screen pixels</strong> based on an analysis of the depth buffer. The pages are <strong>cached</strong> between frames unless they are invalidated by moving objects or light, which further improves performance.</p></blockquote><p>According to the Unreal Engine VSMs documentation, VSMs have four key features: virtual high-resolution texture, clipmaps, only shade on-screen pixels and page cache. We have implemented the four features listed above in the simplified virtual shadow map project. Here is the low-level architecture of our simplified VSMs:</p><p align="center">    <img src="/resource/vsm_project/image/low_level_architecture.png" width="70%" height="70%"></p><p>In XEngine’s simplified virtual shadow map, each directional light has a clip map with 3 levels: clip map level 6, clip map level 7 and clip map level 8. In addition, the maximum clip map level consists of 8 x 8 tiles, with the next clip map level having twice the number of tiles as the previous clip map level. The total tile number is 1344 (32 x 32 + 16 x 16 + 8 x 8), which corresponds to 8K x 8K virtual texture size. Each tile have the same physical size with 256 x 256 pixels. The physical tile pool’s size is 2K x 2K.</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>Note: To achieve the <strong>highest possible performance</strong>, it is recommended that combining the virtual shadow map with a <strong>Nanite-like</strong> technique which divides the mesh into clusters. Otherwise, <strong>fine-grained tile splitting</strong> could result in significant increases in the draw call and the mesh face number.</p><p align="center">    <img src="/resource/vsm_project/image/renderdoc.png" width="64%" height="64%"></p><p>Simplified VSMs classify the tiles into different states based on the scene depth and the mesh bound box. It contains four tile states: shaded, not visible, cache miss and newly added tile state. VSMs performs different action for each tile with its tile state, such as update the physical tile content, allocate or remove the tile in the physical tile pool. Next, cull and build the mesh draw command for those tiles that need to be updated in the current frame. Finally, dispatch a set of indirect draw commands and compute the shadow mask using the shadow depth map rendered by indirect draw:</p><p align="center">    <img src="/resource/vsm_project/image/pass_overview.png" width="64%" height="64%"></p><h1 id="Mark-Tile-State"><a href="#Mark-Tile-State" class="headerlink" title="Mark Tile State"></a>Mark Tile State</h1><h2 id="Mark-Tiles-Used"><a href="#Mark-Tiles-Used" class="headerlink" title="Mark Tiles Used"></a>Mark Tiles Used</h2><p>Only the tiles that affect objects in the camera view are processed by VSMs. In order to achieve this goal, VSMs analyze the scene depth buffer by convert the pixels from camera projection space to shadow view space to find which tile this pixel corresponds to. Moreover, VSMs calculate the clip map level this pixel belongs to based on its distance from world space to the camera. As shown in the following image, the green blocks are marked as used tiles in VSMs, while the red blocks are not used.</p><p align="center">    <img src="/resource/vsm_project/image/vsm_tile_mark_drawio.png" width="50%" height="50%"></p><p>Simplified VSMs have 3 clip map levels. The ranges of each mip level are 2^(6 + 1) ,2^(7 + 1)  and 2^(8 + 1). The first level is 6, which means that the pixels distance to the camera ranging from 0 to 2^6 are belong to this level. Based on the mip level, shadow space UV, and mip size, we can determine which tile this pixel belongs to.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> Distance = <span class="hljs-built_in">length</span>(WorldCameraPosition - WorldPosition.xyz);<br><span class="hljs-type">float</span> Log2Distance = <span class="hljs-built_in">log2</span>(Distance + <span class="hljs-number">1</span>);<br> <br><span class="hljs-type">int</span> MipLevel = <span class="hljs-built_in">clamp</span>(Log2Distance - VSM_CLIPMAP_MIN_LEVEL, <span class="hljs-number">0</span>, VSM_MIP_NUM - <span class="hljs-number">1</span>);<br>uint2 VSMTileIndex = <span class="hljs-built_in">uint2</span>(UVOut * MipLevelSize[MipLevel]);<br><br><span class="hljs-type">int</span> DestTileInfoIndex = MipLevelOffset[MipLevel] + VSMTileIndex.y * MipLevelSize[MipLevel] + VSMTileIndex.x;<br><br>VirtualShadowMapTileState[DestTileInfoIndex] = TILE_STATE_USED;<br></code></pre></td></tr></table></figure><p>Here is a visualization of the mip level for the scene. The Mip Levels 6 &#x2F; 7 &#x2F; 8 correspond to the colors red, green, and blue, respectively. </p><p align="center">    <img src="/resource/vsm_project/image/vsm_tile_mark_visualize.png" width="80%" height="80%"></p><h2 id="Mark-Cache-Miss-Tiles"><a href="#Mark-Cache-Miss-Tiles" class="headerlink" title="Mark Cache Miss Tiles"></a>Mark Cache Miss Tiles</h2><p>VSMs only update the tiles that have changed compared to previous frame. This reduces the number of draw calls since we can reuse the previous frame data in the cached virtual shadow map texture. To find all of the tiles that changed in this frame, simplified VSMs project the bound boxes of the dynamic objects into the shadow view space. Following that, the VSM iterates and marks all tiles within these bound boxes projected range. The VSMs only mark tiles as cache misses for <strong>those tiles that were rendered in this frame</strong>. All of the mip levels covered are conservatively marked as cache miss. In the following gif image, we can see that the cache missed tile with yellow color is updated every frame:</p><p align="center">    <img src="/resource/vsm_project/gif/tile_cache_miss.gif" width="80%" height="80%"></p><h1 id="Update-Tile-Action"><a href="#Update-Tile-Action" class="headerlink" title="Update Tile Action"></a>Update Tile Action</h1><p>In the tile action update pass, VSMs compare the current tile state with the previous frame’s tile state. A ping-pong buffer is used to store the previous’s tile state buffer and tile table buffer. The tile table buffer stores the index to the physical tile texture.</p><p align="center">    <img src="/resource/vsm_project/image/update_tile_action.png" width="50%" height="50%"></p><p>Newly added tiles in this frame will allocate a new physical tile and update the shadow rendering. For cached tiles, we only update the tile shadow rendering. There is no need to allocate an extra physical tile for the cached tile. We reuse the cached tile by assign it with the index copyed from the corresponding position in the previoues tile table.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> bTileUsed = (TileState == TILE_STATE_USED);<br><span class="hljs-type">bool</span> bPreTileUsed = (PreTileState == TILE_STATE_USED);<br><span class="hljs-type">bool</span> bNewTile = (TileState == TILE_STATE_USED) &amp;&amp; (PreTileState == TILE_STATE_UNUSED);<br><span class="hljs-type">bool</span> bCacheMissTile = (CacheMissAction == TILE_STATE_CACHE_MISS) &amp;&amp; (PreTileState == TILE_STATE_USED);<br><span class="hljs-type">bool</span> bTileRemove = (TileState == TILE_STATE_UNUSED) &amp;&amp; (PreTileState == TILE_STATE_USED);<br><span class="hljs-type">bool</span> bTileActionCached = (bPreTileUsed) &amp;&amp; (bTileUsed) &amp;&amp; (!bCacheMissTile);<br><span class="hljs-type">bool</span> bTileActionNeedRemove = bTileRemove;<br><br>uint TileAction = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span>(bTileActionCached)<br>&#123;<br>    VirtualShadowMapTileTable[GlobalTileIndex] = VirtualShadowMapPreTileTable[GlobalTileIndex];<br>    TileAction = TILE_ACTION_CACHED;<br>&#125;<br><br><span class="hljs-keyword">if</span>(bCacheMissTile)<br>&#123;<br>    VirtualShadowMapTileTable[GlobalTileIndex] = VirtualShadowMapPreTileTable[GlobalTileIndex];<br>    TileAction = TILE_ACTION_NEED_UPDATE;       <br>&#125;<br><br><span class="hljs-keyword">if</span>(bNewTile)<br>&#123;<br>    TileAction = TILE_ACTION_NEED_ALLOCATE | TILE_ACTION_NEED_UPDATE;<br>&#125;<br><br><span class="hljs-keyword">if</span>(bTileActionNeedRemove)<br>&#123;<br>    TileAction = TILE_ACTION_NEED_REMOVE;<br>&#125;<br><br>VirtualShadowMapTileAction[GlobalTileIndex] = TileAction;<br></code></pre></td></tr></table></figure><h1 id="Physical-Tile-Management"><a href="#Physical-Tile-Management" class="headerlink" title="Physical Tile Management"></a>Physical Tile Management</h1><p>VSMs maintain a list of available physical tiles. An extra counter buffer records the free list header node. The physical tile manager allocates a free tile from the free tile list when the tile action equals TILE_ACTION_NEED_ALLOCATE and assigns the tile index to the corresponding position of the current frame virtual tile table when the tile action equals TILE_ACTION_NEED_ALLOCATE. The physical tile manager will obtain the released tile index from the previous frame tile table and push it to the back of the free tile list if the tile action is TILE_ACTION_NEED_REMOVE.</p><p align="center">    <img src="/resource/vsm_project/image/physical_tile_manage.png" width="80%" height="80%"></p><p>We move the counter forward or backward by InterlockedAdd instruction. The tile realse and tile allocate action are performed in separate compute pass. VSMs in UE5 maintain a LRU list in the physical tile manager. For simplicity, we release the tile buffer immediately after the tiles are marked as TILE_ACTION_NEED_REMOVE.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(VirtualShadowMapAction &amp; TILE_ACTION_NEED_ALLOCATE)<br>&#123;<br>    uint FreeListIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">InterlockedAdd</span>(VirtualShadowMapFreeListStart[<span class="hljs-number">0</span>],<span class="hljs-number">1</span>,FreeListIndex);<br>    <span class="hljs-keyword">if</span>(FreeListIndex &lt; VSM_TEX_PHYSICAL_WH * VSM_TEX_PHYSICAL_WH)<br>    &#123;<br>        VirtualShadowMapTileTable[GlobalTileIndex] = VirtualShadowMapFreeTileList[FreeListIndex];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(VirtualShadowMapAction &amp; TILE_ACTION_NEED_REMOVE)<br>&#123;<br>    <span class="hljs-type">int</span> FreeListIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">InterlockedAdd</span>(VirtualShadowMapFreeListStart[<span class="hljs-number">0</span>],<span class="hljs-number">-1</span>,FreeListIndex);<br>    <span class="hljs-keyword">if</span>(FreeListIndex &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        uint RemoveTileIndex = VirtualShadowMapPreTileTable[GlobalTileIndex];<br>        VirtualShadowMapFreeTileList[FreeListIndex - <span class="hljs-number">1</span>] = RemoveTileIndex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>When rotating the camera, we can see that the free tiles (red blocks in the top-right corner) are changed:</p><p align="center">    <img src="/resource/vsm_project/gif/physical_tile_allocation.gif" width="64%" height="64%"></p><h1 id="Cull-And-Build-The-Shadow-Draw-Command"><a href="#Cull-And-Build-The-Shadow-Draw-Command" class="headerlink" title="Cull And Build The Shadow Draw Command"></a>Cull And Build The Shadow Draw Command</h1><h2 id="Allocate-The-Shadow-Commands"><a href="#Allocate-The-Shadow-Commands" class="headerlink" title="Allocate The Shadow Commands"></a>Allocate The Shadow Commands</h2><p>VSMs build the command on the GPU and render the shadow map by indirect draw command. Here is the indirect command layout specified on the application side: constant buffer view for per-object transform information, tile info cbv, vertex buffer view, index buffer view and indirect argument desc.</p><p align="center">    <img src="/resource/vsm_project/image/indirect_cmd_layout.png" width="50%" height="50%"></p><p>After that, we allocate the command data on the application side. It contains the GPU address of the buffer, information about the vertex buffer and index buffer, as well as information about the object mesh. In the final step, initialize the scene command buffer with the data allocated above and create an empty culled command buffer with the same size as the scene command buffer. The culled command buffer is a collection of commands used in shadow map rendering after GPU culling.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;XRHICommandData&gt; RHICmdData;<br>RHICmdData.<span class="hljs-built_in">resize</span>(RenderGeos.<span class="hljs-built_in">size</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; RenderGeos.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">auto</span>&amp; it = RenderGeos[i];<br>RHICmdData[i].CBVs.<span class="hljs-built_in">push_back</span>(it-&gt;<span class="hljs-built_in">GetAndUpdatePerObjectVertexCBuffer</span>().<span class="hljs-built_in">get</span>());<br>RHICmdData[i].CBVs.<span class="hljs-built_in">push_back</span>(VirtualShadowMapResource.LightSubProjectMatrix.<span class="hljs-built_in">get</span>());<br>RHICmdData[i].CBVs.<span class="hljs-built_in">push_back</span>(VirtualShadowMapResource.LightSubProjectMatrix.<span class="hljs-built_in">get</span>());<br><br><span class="hljs-keyword">auto</span> VertexBufferPtr = it-&gt;<span class="hljs-built_in">GetRHIVertexBuffer</span>();<br><span class="hljs-keyword">auto</span> IndexBufferPtr = it-&gt;<span class="hljs-built_in">GetRHIIndexBuffer</span>();<br>RHICmdData[i].VB = VertexBufferPtr.<span class="hljs-built_in">get</span>();<br>RHICmdData[i].IB = IndexBufferPtr.<span class="hljs-built_in">get</span>();<br>RHICmdData[i].IndexCountPerInstance = it-&gt;<span class="hljs-built_in">GetIndexCount</span>();<br>RHICmdData[i].InstanceCount = <span class="hljs-number">1</span>;<br>RHICmdData[i].StartIndexLocation = <span class="hljs-number">0</span>;<br>RHICmdData[i].BaseVertexLocation = <span class="hljs-number">0</span>;<br>RHICmdData[i].StartInstanceLocation = <span class="hljs-number">0</span>;<br>&#125;<br><br>uint32 OutCmdDataSize;<br><span class="hljs-type">void</span>* DataPtrret = <span class="hljs-built_in">RHIGetCommandDataPtr</span>(RHICmdData, OutCmdDataSize);<br></code></pre></td></tr></table></figure><h2 id="Build-Indirect-Shadow-Command"><a href="#Build-Indirect-Shadow-Command" class="headerlink" title="Build Indirect Shadow Command"></a>Build Indirect Shadow Command</h2><p>For each tile, we dispatch 50 threads to process the mesh batch. Each mesh batch has 1 &#x2F; 50 mesh draw commands. Simplified VSMs cull the mesh draw command from the mesh bounding box. We project the box into the shadow view space, and push the command to the output command queue by InterLockedAdd when the mesh is not culled by the tile.</p><p align="center">    <img src="/resource/vsm_project/image/build_shadow_command.png" width="75%" height="75%"></p><h2 id="GPU-“Pointer”"><a href="#GPU-“Pointer”" class="headerlink" title="GPU “Pointer”"></a>GPU “Pointer”</h2><p>It is necessary to create a bridge between the indirect draw command and the virtual tile table in order to obtain tile information. UE5’s VSMs use InstanceID to index the virtual tile table. The solution requires recording an extra InstanceOffset variable for each mesh, since the StartInstanceLocation cannot be obtained from the vertex shader if the shading language is beyond SM 6.8. In Simplified VSMs, we use <strong>“GPU Pointer”</strong> to point the GPU address of the tile information buffer.</p><p align="center">    <img src="/resource/vsm_project/image/gpu_pointer.png" width="75%" height="75%"></p><p>For each tile, simplified VSMs generate information including a view-proj matrix, mip level, and tile indexes. We can calculate the GPU address of each tile with the tile index and the base GPU address recorded on the application side.</p><p>Another problem is that the GPU pointer is 64 bits in size, and HLSL does not support additions of 64 bits. Therefore, it is necessary to implement a custom 64 bit addition for the GPU pointer:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UINT64</span><br>&#123;<br>    uint LowAddress;<br>    uint HighAddress;<br>&#125;;<br><br><span class="hljs-function">UINT64 <span class="hljs-title">UINT64_ADD</span><span class="hljs-params">(UINT64 InValue , uint InAdd)</span></span><br><span class="hljs-function"></span>&#123;<br>    UINT64 Ret = InValue;<br>    uint C= InValue.LowAddress + InAdd;<br>    <span class="hljs-type">bool</span> OverFlow = (C &lt; InValue.HighAddress) || (C &lt; InAdd);<br>    <span class="hljs-keyword">if</span>(OverFlow)<br>    &#123;<br>        Ret.HighAddress += <span class="hljs-number">1</span>;<br>    &#125;<br>    Ret.LowAddress = C;<br>    <span class="hljs-keyword">return</span> Ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>A tile’s GPU address is simply the sum of the tile offset and the base address.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint2 TileIndexMin = <span class="hljs-built_in">uint2</span>( UVMin * MipLevelSize[MipLevel]);<br>uint2 TileIndexMax = <span class="hljs-built_in">uint2</span>( UVMax * MipLevelSize[MipLevel]);<br><br><span class="hljs-keyword">if</span>(TileIndexMin.x &lt;= MipTileIndexXY.x &amp;&amp; TileIndexMin.y &lt;= MipTileIndexXY.y &amp;&amp; TileIndexMax.x &gt;= MipTileIndexXY.x &amp;&amp; TileIndexMax.y &gt;= MipTileIndexXY.y)<br>&#123;<br>    uint PointerOffset = GlobalTileIndex * ( <span class="hljs-number">4</span> * <span class="hljs-number">4</span> * <span class="hljs-number">4</span> + <span class="hljs-number">4</span> * <span class="hljs-number">4</span>); <span class="hljs-comment">// float4x4 + uint4</span><br>    ShadowIndirectCommand InputCommand = InputCommands[Index];<br>    InputCommand.CbGlobalShadowViewProjectAddressVS = <span class="hljs-built_in">UINT64_ADD</span>(GPUStartAddress,PointerOffset);<br>    InputCommand.CbGlobalShadowViewProjectAddressPS = InputCommand.CbGlobalShadowViewProjectAddressVS;<br>    InputCommand.StartInstanceLocation = GlobalTileIndex;<br>    <br>    uint OriginalValue = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">InterlockedAdd</span>(CommandCounterBuffer[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, OriginalValue);<br>    OutputCommands[OriginalValue] = InputCommand;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Shadow-Map-Rendering"><a href="#Shadow-Map-Rendering" class="headerlink" title="Shadow Map Rendering"></a>Shadow Map Rendering</h1><p>After all pre-requirements have been met, shadow map rendering is an easy task-just clear the physical tiles that need to be updated and dispatch an indirect draw pass.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RHICmdList.<span class="hljs-built_in">RHIExecuteIndirect</span>(VirtualShadowMapResource.RHIShadowCommandSignature.<span class="hljs-built_in">get</span>(), RenderGeos.<span class="hljs-built_in">size</span>() * <span class="hljs-number">16</span>,<br>VirtualShadowMapResource.VirtualShadowMapCommnadBufferCulled.<span class="hljs-built_in">GetBuffer</span>().<span class="hljs-built_in">get</span>(), <span class="hljs-number">0</span>,<br>VirtualShadowMapResource.VirtualShadowMapCommnadCounter.<span class="hljs-built_in">GetBuffer</span>().<span class="hljs-built_in">get</span>(), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>By calculating the MIP level based on the world position and calculating the virtual table index based on the GPU pointer, we can determine destination pixel writen position.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint TableIndex = MipLevelOffset[MipLevel] + VirtualTableIndexY * MipLevelSize[MipLevel] + VirtualTableIndexX;<br>uint TileInfo = VirtualShadowMapTileTable[TableIndex];<br>uint PhysicalTileIndexX = (TileInfo &gt;&gt;  <span class="hljs-number">0</span>) &amp; <span class="hljs-number">0xFFFF</span>;<br>uint PhysicalTileIndexY = (TileInfo &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFFFF</span>;<br><br>float2 IndexXY = <span class="hljs-built_in">uint2</span>(PhysicalTileIndexX, PhysicalTileIndexY) * VSM_TILE_TEX_PHYSICAL_SIZE;<br>float2 WritePos = IndexXY + PositionIn.xy;<br><span class="hljs-type">float</span> FixedPointDepth = <span class="hljs-built_in">float</span>(PositionIn.z) * <span class="hljs-built_in">uint</span>(<span class="hljs-number">0xFFFFFFFF</span>);<br>uint UintDepth = FixedPointDepth;<br><br><span class="hljs-built_in">InterlockedMax</span>(PhysicalShadowDepthTexture[<span class="hljs-built_in">uint2</span>(WritePos)],UintDepth);<br></code></pre></td></tr></table></figure><p>Here is the visualization of the physical shadow depth texture:</p><p align="center">    <img src="/resource/vsm_project/image/sub_tile.png" width="64%" height="64%"></p><p align="center">    <img src="/resource/vsm_project/image/physical_tile_visualize.png" width="64%" height="64%"></p><h1 id="Generate-The-Shadow-Mask-Texture"><a href="#Generate-The-Shadow-Mask-Texture" class="headerlink" title="Generate The Shadow Mask Texture"></a>Generate The Shadow Mask Texture</h1><p>By calculating the virtual table index from the pixel position, calculating the physical shadow depth position from the table index, and comparing the result to the pixel’s shadow space depth, we can finally determine whether this pixel is shadowed.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> Total = <span class="hljs-number">0.0f</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>    Total += <span class="hljs-built_in">ComputeShadowFactor</span>(UVShadowSpace + UVOffset[i] * MipLevelVirtualTextureSize[MipLevel], ObjectShadowDepth,Bias, MipLevel);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">ComputeShadowFactor</span><span class="hljs-params">(float2 UVShadowSpace ,uint ObjectShadowDepth, uint Bias, uint MipLevel)</span></span><br><span class="hljs-function"></span>&#123;<br>    uint2 VSMTileIndex = <span class="hljs-built_in">uint2</span>(UVShadowSpace * MipLevelSize[MipLevel]);<br>    <span class="hljs-type">int</span> TableIndex = MipLevelOffset[MipLevel] + VSMTileIndex.y * MipLevelSize[MipLevel] + VSMTileIndex.x;<br>    uint TileInfo = VirtualShadowMapTileTable[TableIndex];<br>    uint PhysicalTileIndexX = (TileInfo &gt;&gt;  <span class="hljs-number">0</span>) &amp; <span class="hljs-number">0xFFFF</span>;<br>    uint PhysicalTileIndexY = (TileInfo &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFFFF</span>;<br><br>    float2 IndexXY = <span class="hljs-built_in">uint2</span>(PhysicalTileIndexX, PhysicalTileIndexY) * VSM_TILE_TEX_PHYSICAL_SIZE;<br>    float2 SubTileIndex = (<span class="hljs-built_in">float2</span>(UVShadowSpace * MipLevelSize[MipLevel]) - VSMTileIndex) * VSM_TILE_TEX_PHYSICAL_SIZE;<br>    float2 ReadPos = IndexXY + SubTileIndex;<br><br>    uint ShadowDepth = PhysicalShadowDepthTexture[<span class="hljs-built_in">uint2</span>(ReadPos)].x;<br><br>    <span class="hljs-keyword">if</span>((ObjectShadowDepth + Bias ) &lt; ShadowDepth) <br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1.0f</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p align="center">    <img src="/resource/vsm_project/image/scene_depth.png" width="64%" height="64%"></p><p align="center">    <img src="/resource/vsm_project/image/shadow_mask.png" width="64%" height="64%"></p><p align="center">    <img src="/resource/vsm_project/gif/final_result_visualize.gif" width="64%" height="64%"></p><p><a href="https://github.com/ShawnTSH1229/XEngine"><u><strong>source code can be found here.</strong></u></a></p>]]></content>
    
    
    <categories>
      
      <category>My Projects</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>

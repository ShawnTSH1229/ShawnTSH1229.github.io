<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Simplified Lumen GI In MiniEngine</title>
    <link href="/2024/05/18/Simplified-Lumen-GI-In-MiniEngine/"/>
    <url>/2024/05/18/Simplified-Lumen-GI-In-MiniEngine/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h1 id="Fast-Ray-Tracing"><a href="#Fast-Ray-Tracing" class="headerlink" title="Fast Ray Tracing"></a>Fast Ray Tracing</h1><p>SimLumen uses signed distance fields to trace the ray with the mesh. SDF is a uniform mesh representation. What’s more, it is differentiable, which means we can calculate the normal at the ray hit position. SimLumen precomputes the mesh SDF and the scene global SDF. GI nearby camera employs mesh SDF to accelerate ray-mesh intersection. Global SDF is used in distant GI and surface cache indirect lighting calculation.</p><h2 id="Build-Mesh-SDF-Offline"><a href="#Build-Mesh-SDF-Offline" class="headerlink" title="Build Mesh SDF Offline"></a>Build Mesh SDF Offline</h2><p>The mesh SDF volume has different size based on the mesh bounding box. To pack these mesh SDF into a single 3D texture, we split the volume into bricks. Brick size is the same for mesh SDFs.</p><p align="center">    <img src="/resource/simlumen/image/build_mesh_sdf.drawio.png" width="60%" height="60%"></p><p>SimLumen use Embree to calculate the mesh SDF, which is the same as Unreal does. For each voxel, we traces 512 ray samples to intersect with the mesh and finds the closest hit position between these samples. A voxel is considered within the mesh if more than 25% of the 512 ray samples hit the triangle backface. We take the negative value of the closest hit distance.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (hit_num &gt; <span class="hljs-number">0</span> &amp;&amp; hit_back_num &gt; <span class="hljs-number">0.25f</span> * samples0.<span class="hljs-built_in">size</span>())<br>&#123;<br>min_distance *= <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Then, scale and quantify the closest distance to uint8 format, and store the result into brick sdf data.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> scaled_min_distance = min_distance / max_distance;<span class="hljs-comment">// -1-&gt;1</span><br><span class="hljs-type">float</span> clamed_min_distance = Math::<span class="hljs-built_in">Clamp</span>(scaled_min_distance * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//0 - 1</span><br><span class="hljs-type">uint8_t</span> normalized_min_distance = <span class="hljs-built_in">uint8_t</span>(<span class="hljs-built_in">int32_t</span>(clamed_min_distance * <span class="hljs-number">255.0f</span> + <span class="hljs-number">0.5</span>));<br><br><span class="hljs-type">int</span> brick_index = brick_index_z * volume_brick_num_y * volume_brick_num_x + brick_index_y * volume_brick_num_x + brick_index_x;<br>volumeData.distance_filed_volume[brick_index].m_brick_data[brick_vol_idx_x][brick_vol_idx_y][brick_vol_idx_z] = normalized_min_distance;<br></code></pre></td></tr></table></figure><h2 id="Trace-Mesh-SDF"><a href="#Trace-Mesh-SDF" class="headerlink" title="Trace Mesh SDF"></a>Trace Mesh SDF</h2><p>At runtime, we copy and upload each mesh’s brick texture to the global mesh SDF brick texture and record the brick texture offset. We can find any SDF value at a given position in the mesh volume for each mesh by global brick texture and brick offset.</p><p align="center">    <img src="/resource/simlumen/image/build_scene_mesh_sdf.png" width="80%" height="80%"></p><p>The GI nearby camera uses mesh SDF to trace rays. In this case, we calculate the possible meshes that can be intersected in the ray tracing direction. Then, we perform SDF tracing for each mesh and find the closest hit position.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[loop]<br><span class="hljs-keyword">for</span>(uint mesh_idx = <span class="hljs-number">0</span>; mesh_idx &lt; scene_mesh_sdf_num; mesh_idx++)<br>&#123;<br>    <span class="hljs-built_in">RayTraceSingleMeshSDF</span>(world_position, ray_direction, <span class="hljs-number">1000</span>, mesh_idx, trace_result);<br>&#125;<br></code></pre></td></tr></table></figure><p>At first, SimNanite transform the ray from the world position into sdf volume position. If the ray intersects the volume bound box, we trace the ray from the intersection position. When the sphere trace step is over 64 or the closest distance in the sample position is closer than on voxel size, it means that we hit the mesh surface and should stop the sphere trace.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float2 volume_space_intersection_times = <span class="hljs-built_in">LineBoxIntersect</span>(volume_ray_start, volume_ray_end, volume_min_pos, volume_max_pos);<br><br>......<br>volume_space_intersection_times *= volume_max_trace_distance;<br><br><span class="hljs-keyword">if</span>((volume_space_intersection_times.x &lt; volume_space_intersection_times.y) &amp;&amp; (volume_space_intersection_times.x &lt; trace_result.hit_distance))<br>&#123;<br>    <span class="hljs-type">float</span> <span class="hljs-type">sample_ray_t</span> = volume_space_intersection_times.x;<br><br>    uint max_step = <span class="hljs-number">64</span>;<br>    <span class="hljs-type">bool</span> bhit = <span class="hljs-literal">false</span>;<br>    uint step_idx = <span class="hljs-number">0</span>;<br><br>    [loop]<br>    <span class="hljs-keyword">for</span>( ; step_idx &lt; max_step; step_idx++)<br>    &#123;<br>        float3 sample_volume_position = volume_ray_start + volume_ray_direction * <span class="hljs-type">sample_ray_t</span>;<br>        <span class="hljs-type">float</span> distance_filed = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(sample_volume_position, mesh_sdf_info);<br>        <span class="hljs-type">float</span> min_hit_distance = mesh_sdf_info.volume_brick_size * <span class="hljs-number">0.125</span> * <span class="hljs-number">1.0</span>; <span class="hljs-comment">// 1 voxel</span><br><br>        <span class="hljs-keyword">if</span>(distance_filed &lt; min_hit_distance)<br>        &#123;<br>            bhit = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">sample_ray_t</span> = <span class="hljs-built_in">clamp</span>(<span class="hljs-type">sample_ray_t</span> + distance_filed - min_hit_distance, volume_space_intersection_times.x, volume_space_intersection_times.y);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-type">sample_ray_t</span> += distance_filed;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-type">sample_ray_t</span> &gt; volume_space_intersection_times.y + min_hit_distance)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(step_idx == max_step)<br>    &#123;<br>        bhit = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(bhit &amp;&amp; <span class="hljs-type">sample_ray_t</span> &lt; trace_result.hit_distance)<br>    &#123;<br>        trace_result.is_hit = <span class="hljs-literal">true</span>;   <br>        trace_result.hit_distance = <span class="hljs-type">sample_ray_t</span>;<br>        trace_result.hit_mesh_index = object_index;<br>        trace_result.hit_mesh_sdf_card_index = mesh_sdf_info.mesh_card_start_index;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SDF-Normal"><a href="#SDF-Normal" class="headerlink" title="SDF Normal"></a>SDF Normal</h2><p>We can calculate the normal at any sample position by calculating the closest distance gradient of the voxels around it.</p><p align="center">    <img src="/resource/simlumen/image/sdf_normal.png" width="70%" height="70%"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">float3 <span class="hljs-title">CalculateMeshSDFGradient</span><span class="hljs-params">(float3 sample_volume_position, SMeshSDFInfo mesh_sdf_info)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> voxel_offset = mesh_sdf_info.volume_brick_size * <span class="hljs-number">0.125</span>;<br><br>    <span class="hljs-type">float</span> R = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x + voxel_offset, sample_volume_position.y, sample_volume_position.z),mesh_sdf_info);<br>    <span class="hljs-type">float</span> L = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x - voxel_offset, sample_volume_position.y, sample_volume_position.z),mesh_sdf_info);<br><br>    <span class="hljs-type">float</span> F = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x, sample_volume_position.y + voxel_offset, sample_volume_position.z),mesh_sdf_info);<br>    <span class="hljs-type">float</span> B = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x, sample_volume_position.y - voxel_offset, sample_volume_position.z),mesh_sdf_info);<br><br>    <span class="hljs-type">float</span> U = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x, sample_volume_position.y, sample_volume_position.z + voxel_offset),mesh_sdf_info);<br>    <span class="hljs-type">float</span> D = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x, sample_volume_position.y, sample_volume_position.z - voxel_offset),mesh_sdf_info);<br><br>    float3 gradiance = <span class="hljs-built_in">float3</span>(R - L, F - B, U - D);<br><span class="hljs-keyword">return</span> gradiance;<br>&#125;<br></code></pre></td></tr></table></figure><p>Below is a SDF ray-tracing visualization.  In this example, the ray-tracing direction for each cube is determined by its offset from the center cube. RGB colors represent the hit position’s normal. X is represented by red color, Y by green color, and Z by blue color.</p><p align="center">    <img src="/resource/simlumen/image/sdf_normal_visualize.png" width="80%" height="80%"></p><h2 id="Global-SDF"><a href="#Global-SDF" class="headerlink" title="Global SDF"></a>Global SDF</h2><p>The global signed distance field is a low resolution SDF of the whole scene. We precompute the global SDF offline. Global SDF differs from scene mesh SDF in that the scene mesh SDF is stored in brick textures with fixed z-dimensions, whereas global SDF is stored in a size-scalable volume texture based on the scene bounding box.</p><h1 id="Surface-Cache"><a href="#Surface-Cache" class="headerlink" title="Surface Cache"></a>Surface Cache</h1><p>The mesh SDF trace allows us to determine the hit position of a ray, however it does not provide information regarding the material attributes (albedo, normal, etc.) at the hit position. Unreal Lumen uses mesh cards to capture these material attributs runtime. </p><p>Mesh cars describe the material attributes capture infomation. It can be generated offline. However, material attributes capture must be performed at runtime, since occlusion between scene meshes can’t be determined offline.</p><h2 id="SimLumen-Card-Generation"><a href="#SimLumen-Card-Generation" class="headerlink" title="SimLumen Card Generation"></a>SimLumen Card Generation</h2><p><strong>In Unreal, a mesh may have many mesh cards based on mesh complexity.</strong> SimLumen simplifies mesh card generation: generates a fixed number mesh card (6 direction) based on the mesh bounding box.  </p><p align="center">    <img src="/resource/simlumen/image/mesh_card.png" width="40%" height="40%"></p><p>We can calculate the capture position and direction from the bounding box directly. The mesh card depth is determined by software raytracing. For each texel in the mesh card, we trace a ray in the mesh card direction, calculate the ray-mesh intersection and find the furthest intersection distance.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> max_depth = <span class="hljs-number">2.0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x_idx = <span class="hljs-number">0</span>; x_idx &lt; <span class="hljs-number">128</span>; x_idx++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y_idx = <span class="hljs-number">0</span>; y_idx &lt; <span class="hljs-number">128</span>; y_idx++)<br>&#123;<br>XMFLOAT3 trace_position = palne_start_trace_pos;<br><span class="hljs-built_in">AddFloatComponent</span>(trace_position, dimension_x, (x_idx + <span class="hljs-number">0.5</span>) * x_stride);<br><span class="hljs-built_in">AddFloatComponent</span>(trace_position, dimension_y, (y_idx + <span class="hljs-number">0.5</span>) * y_stride);<br><br>RTCRayHit embree_ray;<br>......<br><span class="hljs-built_in">rtcIntersect1</span>(m_rt_scene, &amp;embree_ray, &amp;args);<br><br><span class="hljs-keyword">if</span> ((embree_ray.ray.tfar != <span class="hljs-number">1e30</span>f) &amp;&amp; embree_ray.hit.geomID != RTC_INVALID_GEOMETRY_ID &amp;&amp; embree_ray.hit.primID != RTC_INVALID_GEOMETRY_ID)<br>&#123;<br><span class="hljs-function">Math::Vector3 <span class="hljs-title">hit_normal</span><span class="hljs-params">(embree_ray.hit.Ng_x, embree_ray.hit.Ng_y, embree_ray.hit.Ng_z)</span></span>;<br>hit_normal = Math::<span class="hljs-built_in">Normalize</span>(hit_normal);<br><span class="hljs-type">float</span> dot_value = Math::<span class="hljs-built_in">Dot</span>(trace_dir, hit_normal);<br><br><span class="hljs-keyword">if</span> (dot_value &lt; <span class="hljs-number">0</span> &amp;&amp; max_depth &lt; embree_ray.ray.tfar)<br>&#123;<br>max_depth = embree_ray.ray.tfar;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br>XMFLOAT3 points[<span class="hljs-number">4</span>];<br>points[<span class="hljs-number">0</span>] = palne_start_trace_pos;<br>points[<span class="hljs-number">1</span>] = plane_end_trace_pos;<br><br>points[<span class="hljs-number">2</span>] = palne_start_trace_pos;<br>points[<span class="hljs-number">2</span>].x += trace_dir.x * max_depth;<br>points[<span class="hljs-number">2</span>].y += trace_dir.y * max_depth;<br>points[<span class="hljs-number">2</span>].z += trace_dir.z * max_depth;<br><br>points[<span class="hljs-number">3</span>] = plane_end_trace_pos;<br>points[<span class="hljs-number">3</span>].x += trace_dir.x * max_depth;<br>points[<span class="hljs-number">3</span>].y += trace_dir.y * max_depth;<br>points[<span class="hljs-number">3</span>].z += trace_dir.z * max_depth;<br><br>Math::BoundingBox RetBound;<br>Math::BoundingBox::<span class="hljs-built_in">CreateFromPoints</span>(RetBound, <span class="hljs-number">4</span>, points, <span class="hljs-built_in">sizeof</span>(XMFLOAT3));<br><span class="hljs-keyword">return</span> RetBound;<br></code></pre></td></tr></table></figure><h2 id="Material-Attributes-Capture"><a href="#Material-Attributes-Capture" class="headerlink" title="Material Attributes Capture"></a>Material Attributes Capture</h2><p>SimLumen captures the mesh card at runtime. After the mesh card capture is completed, we copy these mesh card attribute textures into a global card atlas.</p><p align="center">    <img src="/resource/simlumen/image/mat_attributes_alebedo.png" width="35%" height="35%"></p><p align="center">    <img src="/resource/simlumen/image/mat_attributes_normal.png" width="35%" height="35%"></p><p>Below is a visualization of the mesh card’s normal and albedo for a scene:</p><p align="center">    <img src="/resource/simlumen/image/scene_attributes_alebedo.png" width="50%" height="50%"></p><p align="center">    <img src="/resource/simlumen/image/scene_attributes_normal.png" width="50%" height="50%"></p><h2 id="Surface-Cache-Lighting"><a href="#Surface-Cache-Lighting" class="headerlink" title="Surface Cache Lighting"></a>Surface Cache Lighting</h2><p>Unreal Lumen has implemented an <strong>infinity bounce</strong> lighting by the combination of the surface cache lighting and voxel lighting. Here is the surface cache flow graph:</p><p>Step 1: Calculate direct lighting with surface cache attributes (albedo &#x2F; normal).</p><p>Step 2: Combine direct lighting and indirect lighting together. In the first frame, direct lighting results in black, since no light has been injected into the scene voxel.</p><p>Step 3: Inject the combined light into the scene voxel.</p><p>Step 4: Calculate indirect lighting used in the next frame.</p><p align="center">    <img src="/resource/simlumen/image/surface_cache_lighting_flow.png" width="75%" height="75%"></p><h2 id="Surface-Cache-Direct-Lighting"><a href="#Surface-Cache-Direct-Lighting" class="headerlink" title="Surface Cache Direct Lighting"></a>Surface Cache Direct Lighting</h2><p>The world position of a mesh card pixel is calculated by the card rotation matrix and card depth. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 local_position;<br>local_position.xy = (card_uv * (<span class="hljs-number">2.0f</span>) - <span class="hljs-number">1.0f</span>) * card_info.rotated_extents.xy;<br>local_position.z = -(depth * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0f</span>)  * card_info.rotated_extents.z;<br>float3 rotate_back_pos = <span class="hljs-built_in">mul</span>((float3x3)card_info.rotate_back_matrix, local_position);<br>rotate_back_pos += card_info.bound_center;;<br></code></pre></td></tr></table></figure><p>After that, SimLumen transforms the world position into shadow space in order to determine whether the pixel is inside or outside the shadow.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> shadow = <span class="hljs-number">0.0</span>;<br>&#123;<br>    float4 shadow_screen_pos = <span class="hljs-built_in">mul</span>(ShadowViewProjMatrix, <span class="hljs-built_in">float4</span>(card_data.world_position,<span class="hljs-number">1.0</span>));<br>    float2 shadow_uv = shadow_screen_pos.xy;<br>    shadow_uv = shadow_uv * <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">-0.5</span>) + <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);<br>    float2 shadow_pixel_pos = shadow_uv.xy * <span class="hljs-number">2048</span>;<br><br>    <span class="hljs-type">float</span> shadow_depth_value = shadow_depth_buffer.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(shadow_pixel_pos.xy,<span class="hljs-number">0</span>)).x;;<br>    shadow = ((shadow_screen_pos.z + <span class="hljs-number">0.0005</span>) &lt; shadow_depth_value ) ? <span class="hljs-number">0.0</span> :<span class="hljs-number">1.0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>We calculate the direct lighting for each light source and accumulate them if the scene has many light sources.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 directional_lighting = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#123;<br>    float3 light_direction = SunDirection;<br>    <span class="hljs-type">float</span> NoL = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(light_direction, card_data.world_normal));<br>    directional_lighting = SunIntensity * NoL * card_data.albedo * shadow;<br>&#125;<br><br>float3 point_lighting = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#123;<br>    float3 point_light_direction = point_light_world_pos - card_data.world_position;<br>    float3 light_dist = <span class="hljs-built_in">length</span>(point_light_direction);<br>    <span class="hljs-type">float</span> attenuation = <span class="hljs-built_in">saturate</span>((point_light_radius - light_dist) / point_light_radius);   <br>    <span class="hljs-type">float</span> NoL = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(<span class="hljs-built_in">normalize</span>(point_light_direction), card_data.world_normal));<br>    point_lighting = NoL * card_data.albedo * attenuation * attenuation;<br>&#125;<br>surface_cache_direct_lighting[<span class="hljs-built_in">int2</span>(pixel_pos.xy)] = <span class="hljs-built_in">float4</span>(point_lighting + directional_lighting, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure><p>surface cache direct lighting visualization:</p><p align="center">    <img src="/resource/simlumen/image/scache_direct_lighting.png" width="64%" height="64%"></p><h2 id="Voxel-Visibility-Buffer"><a href="#Voxel-Visibility-Buffer" class="headerlink" title="Voxel Visibility Buffer"></a>Voxel Visibility Buffer</h2><p>Voxel visibility buffer stores the hit mesh index and hit distance in x&#x2F;y&#x2F;z direction. As a persistent data, it is only updated when the meshes’ positions change. SDF traces are performed for each voxel along the xyz direction for meshes that are possibly intersected with its center. If the ray from the voxel center along the x&#x2F;y&#x2F;z direction hit a mesh, we store the mesh index in the voxel. This will be used in the next light injection pass.</p><p align="center">    <img src="/resource/simlumen/image/voxel_vis_info.png" width="60%" height="60%"></p><h2 id="Lighting-Injection"><a href="#Lighting-Injection" class="headerlink" title="Lighting Injection"></a>Lighting Injection</h2><p>We can obtain the intersection mesh and intersection position directly from the voxel visibility buffer. After that, we transform the hit world position into mesh card space location and calculate the final light atlas UV. The final light is the combination of the direct light and indirect light. However, the indirect lighting remains black until the second frame as it is dependent on voxel illumination.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint direction_idx = group_idx.y;<br>SVoxelVisibilityInfo voxel_vis_info = scene_voxel_visibility_buffer[voxel_index_1d];<br><span class="hljs-type">int</span> mesh_index = voxel_vis_info.voxel_vis_info[direction_idx].mesh_index;<br><span class="hljs-keyword">if</span>(mesh_index != <span class="hljs-number">-1</span>)<br>&#123;<br>    SMeshSDFInfo mesh_info = scene_sdf_infos[mesh_index];<br>    uint card_index = direction_idx; <br>    uint global_card_index = mesh_info.mesh_card_start_index + card_index;<br><br>    SCardInfo card_info = scene_card_infos[global_card_index];<br><br>    <span class="hljs-type">float</span> hit_distance = voxel_vis_info.voxel_vis_info[direction_idx].hit_distance;<br>    float3 light_direction = voxel_light_direction[direction_idx];<br>    float3 hit_world_pos = voxel_world_pos + light_direction * hit_distance;<br><br>    float2 uv = <span class="hljs-built_in">GetCardUVFromWorldPos</span>(card_info, hit_world_pos);<br><br>    uint2 card_index_xy = <span class="hljs-built_in">uint2</span>((global_card_index % card_num_xy), (global_card_index / card_num_xy));<br>    uint2 pixel_pos = card_index_xy * <span class="hljs-number">128</span> + <span class="hljs-built_in">float2</span>(uv * <span class="hljs-number">128</span>);<br>    pixel_pos.y = SURFACE_CACHE_TEX_SIZE - pixel_pos.y;<br>    float3 final_lighting = final_lighting_tex.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(pixel_pos,<span class="hljs-number">0</span>)).xyz;<br><br>    scene_voxel_lighting[voxel_index_1d].final_lighting[direction_idx] = final_lighting;<br>&#125;<br></code></pre></td></tr></table></figure><p>voxel lighting visualization:</p><p align="center">    <img src="/resource/simlumen/image/voxel_lighting_visualize.png" width="60%" height="60%"></p><h2 id="Surface-Cache-Indirect-Lighting"><a href="#Surface-Cache-Indirect-Lighting" class="headerlink" title="Surface Cache Indirect Lighting"></a>Surface Cache Indirect Lighting</h2><p>The first step is to calculate the radiance of the current surface cache pixel using global SDF, filter, and store the radiance in a radiance atlas. We then convert radiance into SH, which allows us to perform probe interpolation to reduce lighting noise.<br>The irradiance in a unit area is the integral of the f(x) over the half sphere:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><mi>L</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>⋅</mo><mi>i</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">E(p) = \int_{\Omega}L(p,i)max(0,n\cdot i )\mathrm{d}i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">i</span></span></span></span><br><p>F(x) can be split into two parts: the lighting function and the diffuse transfer function:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>H</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">E(p) = \int_{\Omega}L(i)\cdot H(i)\mathrm{d}i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">i</span></span></span></span><br><p>L(i) is reconstructed from the spherical harmonic by SH factors and biasis function:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>≈</mo><mi mathvariant="normal">Σ</mi><msub><mi>l</mi><mi>k</mi></msub><msub><mi>B</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(i) \approx \Sigma l_{k}B_{k}(i) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span><br><p>We project the radiance into the basis function to get the SH factors in Convert SH pass:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mi>k</mi></msub><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mi>B</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">l_{k} = \int_{\Omega}L(i)B(i)\mathrm{d}i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">i</span></span></span></span><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(<span class="hljs-built_in">SHBasisFunction</span>(world_ray), trace_irradiance / pdf));<br></code></pre></td></tr></table></figure><p>If we project both the illumination and transfer functions into SH coefficients then orthogonality guarantees that the integral of the function’s products is the same as the dot product of their coefficients:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><msup><mi>n</mi><mn>2</mn></msup></msubsup><msub><mi>l</mi><mi>k</mi></msub><msub><mi>h</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">E(p) = \Sigma_{k=0}^{n^{2}} l_{k}h_{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.27em;vertical-align:-0.2831em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9869em;"><span style="top:-2.4169em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>⋅</mo><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(i) = max(0,n\cdot l) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span><br><p>The irradiance of a pixel is calculated in the integrate pass:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FTwoBandSHVector diffuse_transfer_sh = <span class="hljs-built_in">CalcDiffuseTransferSH</span>(card_data.world_normal, <span class="hljs-number">1.0f</span>);<br>float3 texel_irradiance = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">float3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>), <span class="hljs-built_in">DotSH</span>(irradiance_sh, diffuse_transfer_sh));<br></code></pre></td></tr></table></figure><p align="center">    <img src="/resource/simlumen/image/scache_indirect_lighting.png" width="40%" height="40%"></p><h3 id="Radiosity-Trace"><a href="#Radiosity-Trace" class="headerlink" title="Radiosity Trace"></a>Radiosity Trace</h3><p>SimLumen split the atlas space surface cache into 8x8 tiles. Each tile place 2x2 probes. </p><p align="center">    <img src="/resource/simlumen/image/scache_radiosity_trace_probe.png" width="30%" height="30%"></p><p>Each probe performs 16 ray tracings in the hemisphere direction.</p><p align="center">    <img src="/resource/simlumen/image/radiosity_probe_ray.png" width="30%" height="30%"></p><p>To accelerate the speed of convergence of the integrate, the probe center is jittered according to the tile index and the frame index.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint2 probe_jitter = <span class="hljs-built_in">GetProbeJitter</span>(indirect_lighting_temporal_index);<br></code></pre></td></tr></table></figure><p>For each direction, we trace a ray from the probe center and find the world space hit position by global SDF.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 world_ray;<br><span class="hljs-type">float</span> pdf;<br><span class="hljs-built_in">GetRadiosityRay</span>(tile_idx, sub_tile_pos, card_data.world_normal, world_ray, pdf);<br><br>SGloablSDFHitResult hit_result = (SGloablSDFHitResult)<span class="hljs-number">0</span>;<br><span class="hljs-built_in">TraceGlobalSDF</span>(card_data.world_position + card_data.world_normal * gloabl_sdf_voxel_size * <span class="hljs-number">2.0</span>, world_ray, hit_result);<br></code></pre></td></tr></table></figure><p>Finally, fetch the voxel lighting at the hit position and accumulate the weighted lighting results in the x&#x2F;y&#x2F;z direction.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint voxel_index_1d = <span class="hljs-built_in">GetVoxelIndexFromWorldPos</span>(hit_world_position);<br><br>SVoxelLighting voxel_lighting = scene_voxel_lighting[voxel_index_1d];<br>float3 voxel_lighting_x = voxel_lighting.final_lighting[x_dir];<br>float3 voxel_lighting_y = voxel_lighting.final_lighting[y_dir];<br>float3 voxel_lighting_z = voxel_lighting.final_lighting[z_dir];<br><br><span class="hljs-type">float</span> weight_x = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(world_ray, voxel_light_direction[x_dir]));<br><span class="hljs-type">float</span> weight_y = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(world_ray, voxel_light_direction[y_dir]));<br><span class="hljs-type">float</span> weight_z = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(world_ray, voxel_light_direction[z_dir]));<br><br>radiance += voxel_lighting_x * weight_x;<br>radiance += voxel_lighting_y * weight_y;<br>radiance += voxel_lighting_z * weight_z;<br><br>radiance /= (weight_x + weight_y + weight_z);<br></code></pre></td></tr></table></figure><p>radiance trace result:</p><p align="center">    <img src="/resource/simlumen/image/scache_radiosity_atlas.png" width="60%" height="60%"></p><p>radiance trace visualization:</p><p align="center">    <img src="/resource/simlumen/image/scache_radiosity_vis.png" width="60%" height="60%"></p><h3 id="Radiosity-Filter"><a href="#Radiosity-Filter" class="headerlink" title="Radiosity Filter"></a>Radiosity Filter</h3><p>In this pass, SimLumen filters the radiance atlas to reduce the noise. We sample the radiance around the current texel and accumulate weighted samples. Radiance sample weights in Unreal Lumen are dependent upon a number of factors, including the texel’s World space plane and the distance between the planes.</p><p>filtered radiance atlas:</p><p align="center">    <img src="/resource/simlumen/image/scache_radiosity_atlas_filtered.png" width="60%" height="60%"></p><h3 id="Convert-To-SH"><a href="#Convert-To-SH" class="headerlink" title="Convert To SH"></a>Convert To SH</h3><p>Radiance atlas results are still noisy after filtering, since we only have 16 samples per probe. We solve this problem by converting the tile radiance into two bands SH, which allows us to interpolate the probes more easily. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(uint trace_idx_x = <span class="hljs-number">0</span>; trace_idx_x &lt; SURFACE_CACHE_PROBE_TEXELS_SIZE; trace_idx_x++)<br>&#123;<br>    <span class="hljs-keyword">for</span>(uint trace_idx_y = <span class="hljs-number">0</span>; trace_idx_y &lt; SURFACE_CACHE_PROBE_TEXELS_SIZE; trace_idx_y++)<br>    &#123;<br>        ......<br>        float3 trace_irradiance = trace_radiance_atlas.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(pixel_atlas_pos.xy, <span class="hljs-number">0</span>)).xyz;<br>        irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(<span class="hljs-built_in">SHBasisFunction</span>(world_ray), trace_irradiance / pdf));<br>num_valid_sample += <span class="hljs-number">1.0f</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (num_valid_sample &gt; <span class="hljs-number">0</span>)<br>&#123;<br>irradiance_sh = <span class="hljs-built_in">MulSH</span>(irradiance_sh, <span class="hljs-number">1.0f</span> / num_valid_sample);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Radiosity-Integrate"><a href="#Radiosity-Integrate" class="headerlink" title="Radiosity Integrate"></a>Radiosity Integrate</h3><p>Finally, sample the probes around the current pixel and calculate the weights based on the atlas position. Then, accumulate the SH weights and weighted SH, calculate the basis function using the current pixel’s world normal, and dot product the basis function with the SH result.  By dividing it by the total sum of SH weights, we get the final radiance value for the current pixel.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FTwoBandSHVectorRGB irradiance_sh = (FTwoBandSHVectorRGB)<span class="hljs-number">0</span>;<br><br>FTwoBandSHVectorRGB sub_irradiance_sh00 = <span class="hljs-built_in">GetRadiosityProbeSH</span>(ProbeCoord00);<br>FTwoBandSHVectorRGB sub_irradiance_sh01 = <span class="hljs-built_in">GetRadiosityProbeSH</span>(ProbeCoord01);<br>FTwoBandSHVectorRGB sub_irradiance_sh10 = <span class="hljs-built_in">GetRadiosityProbeSH</span>(ProbeCoord10);<br>FTwoBandSHVectorRGB sub_irradiance_sh11 = <span class="hljs-built_in">GetRadiosityProbeSH</span>(ProbeCoord11);<br><br>irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(sub_irradiance_sh00, weights.x));<br>irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(sub_irradiance_sh01, weights.y));<br>irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(sub_irradiance_sh10, weights.z));<br>irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(sub_irradiance_sh11, weights.w));<br><br>uint card_index_1d = card_idx_2d.y * SURFACE_CACHE_CARD_NUM_XY + card_idx_2d.x;<br>SCardInfo card_info = scene_card_infos[card_index_1d];<br>SCardData card_data = <span class="hljs-built_in">GetSurfaceCardData</span>(card_info, <span class="hljs-built_in">float2</span>(<span class="hljs-built_in">uint2</span>(thread_index.xy % <span class="hljs-number">128u</span>)) / <span class="hljs-number">128.0f</span>, pixel_atlas_pos.xy);<br>FTwoBandSHVector diffuse_transfer_sh = <span class="hljs-built_in">CalcDiffuseTransferSH</span>(card_data.world_normal, <span class="hljs-number">1.0f</span>);<br><br>float3 texel_irradiance = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">float3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>), <span class="hljs-built_in">DotSH</span>(irradiance_sh, diffuse_transfer_sh));<br>irtexel_radiance = texel_irradiance / (weights.x + weights.y + weights.z + weights.w);<br></code></pre></td></tr></table></figure><p>indirect lighting visualization:</p><p align="center">    <img src="/resource/simlumen/image/indirect_lighting_vis.png" width="60%" height="60%"></p><p>combined lighting visualization:</p><p align="center">    <img src="/resource/simlumen/image/combined_lighting_vis.png" width="60%" height="60%"></p><h1 id="Final-Gather"><a href="#Final-Gather" class="headerlink" title="Final Gather"></a>Final Gather</h1><h2 id="Screen-Space-Probe"><a href="#Screen-Space-Probe" class="headerlink" title="Screen Space Probe"></a>Screen Space Probe</h2><h2 id="Importance-Sampling"><a href="#Importance-Sampling" class="headerlink" title="Importance Sampling"></a>Importance Sampling</h2><p>It’s too noisy if we employ uniform sampling rather than importance sampling.<br>without importance sampling Vs with importance sampling:</p><p align="center">    <img src="/resource/simlumen/image/is_vs_no_is.png" width="60%" height="60%"></p><p>What we do in the importance sampling part is searching the rays that orientates to the lighting source and world normal. That is to say, we peroform importance sampling for BRDF(fs) term and input radiance(Li) term:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>N</mi></mfrac><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mfrac><mrow><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><msub><mi>f</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>l</mi><mo>−</mo><mo>&gt;</mo><mi>v</mi><mo stretchy="false">)</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>θ</mi><mi>l</mi><mo stretchy="false">)</mo></mrow><msub><mi>P</mi><mi>k</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{N}\Sigma_{k=1}^{N}\frac{L_{i}(l)f_{s}(l-&gt;v)cos(\theta l)}{P_{k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4609em;vertical-align:-0.4509em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.4169em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.1076em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mtight">−</span><span class="mrel mtight">&gt;</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span><span class="mord mathnormal mtight">cos</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">θl</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4509em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br><h3 id="BRDF-PDF"><a href="#BRDF-PDF" class="headerlink" title="BRDF PDF"></a>BRDF PDF</h3><p>In this step, SimLumen generate the three band sphere harmonic factors for the BRDF function. We sample the screen pixels around the screen probe and compute the influence weight on the probe. If the weight is over the threshold, convert the BRDF to SH and accumulate the SH. Then write the result to the BRDF SH buffer.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 pixel_world_position = <span class="hljs-built_in">GetWorldPosByDepth</span>(thread_depth, piexl_tex_uv);<br>float3 probe_world_position = <span class="hljs-built_in">GetWorldPosByDepth</span>(probe_depth, ss_probe_atlas_pos / global_thread_size);<br><br>float4 pixel_world_plane = <span class="hljs-built_in">float4</span>(thread_world_normal, <span class="hljs-built_in">dot</span>(thread_world_normal,pixel_world_position));<br><span class="hljs-type">float</span> plane_distance = <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">dot</span>(<span class="hljs-built_in">float4</span>(probe_world_position, <span class="hljs-number">-1</span>), pixel_world_plane));<br><br><span class="hljs-type">float</span> probe_view_dist = <span class="hljs-built_in">length</span>(probe_world_position - CameraPos);<br><span class="hljs-type">float</span> relative_depth_diff = plane_distance / probe_view_dist;<br><span class="hljs-type">float</span> depth_weight = <span class="hljs-built_in">exp2</span>(<span class="hljs-number">-10000.0f</span> * (relative_depth_diff * relative_depth_diff));<br><span class="hljs-keyword">if</span>(depth_weight &gt; <span class="hljs-number">0.1f</span>)<br>&#123;<br>    uint write_index;<br>    <span class="hljs-built_in">InterlockedAdd</span>(group_num_sh, <span class="hljs-number">1</span>, write_index);<br><br>    FThreeBandSHVector brdf = <span class="hljs-built_in">CalcDiffuseTransferSH3</span>(thread_world_normal, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-built_in">WriteGroupSharedSH</span>(brdf, write_index);<br>&#125;<br></code></pre></td></tr></table></figure><p>The pixel normal may be located in a different plane from the probe. Therefore, we compute the plane weight for the given pixel and reject the pixel if the depth weight is over the threshold. Then, store the results of those valid pixels in a <strong>group shared</strong> array.</p><p align="center">    <img src="/resource/simlumen/image/brdf_depth_weight.png" width="60%" height="60%"></p><p>After that, perform a parallel reduction to accumulate these SH factors.</p><p align="center">    <img src="/resource/simlumen/image/acc_brdf_pdf.png" width="60%" height="60%"></p><p>Finally, the first nine threads store the 9 SH factors in output BRDF SH buffer.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (thread_index &lt; <span class="hljs-number">9</span> &amp;&amp; group_num_sh &gt; <span class="hljs-number">0</span>)<br>&#123;<br>    uint write_index = (ss_probe_idx_xy.y * screen_probe_size_x + ss_probe_idx_xy.x) * <span class="hljs-number">9</span> + thread_index;<br>    <span class="hljs-type">float</span> normalize_weight = <span class="hljs-number">1.0f</span> / (<span class="hljs-type">float</span>)(group_num_sh);<br>    brdf_pdf_sh[write_index] = pdf_sh[offset][thread_index] * normalize_weight;<br>&#125;<br></code></pre></td></tr></table></figure><p>brdf pdf visualization:</p><p align="center">    <img src="/resource/simlumen/image/brdf_pdf_vis.png" width="60%" height="60%"></p><h3 id="Lighting-PDF"><a href="#Lighting-PDF" class="headerlink" title="Lighting PDF"></a>Lighting PDF</h3><p>The light source direction in the current frame is unknown. In order to search the light direction, we assume lighting changes slightly and reuse the previous frame’s lighting result.</p><p align="center">    <img src="/resource/simlumen/image/ss_light_is.png" width="60%" height="60%"></p><p>Then, reproject the probe into the previous frame screen position and find the corresponding direction texel.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> float2 global_thread_size = <span class="hljs-built_in">float2</span>(is_pdf_thread_size_x,is_pdf_thread_size_y);<br>float3 probe_world_position = gbuffer_c.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(ss_probe_atlas_pos.xy,<span class="hljs-number">0</span>)).xyz;<br><br>float4 pre_view_pos = <span class="hljs-built_in">mul</span>(PreViewProjMatrix,<span class="hljs-built_in">float4</span>(probe_world_position, <span class="hljs-number">1.0</span>));<br>float2 pre_view_screen_pos = (<span class="hljs-built_in">float2</span>(pre_view_pos.xy / pre_view_pos.w) * <span class="hljs-number">0.5</span> + <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>));<br>pre_view_screen_pos.y = (<span class="hljs-number">1.0</span> - pre_view_screen_pos.y);<br>pre_view_screen_pos = pre_view_screen_pos * global_thread_size;<br>uint2 pre_probe_pos = <span class="hljs-built_in">uint2</span>(pre_view_screen_pos) / <span class="hljs-built_in">uint2</span>(PROBE_SIZE_2D,PROBE_SIZE_2D);<br>uint2 pre_texel_pos = pre_probe_pos * <span class="hljs-built_in">uint2</span>(PROBE_SIZE_2D,PROBE_SIZE_2D) + group_thread_idx.xy;<br><br>lighting = sspace_composited_radiance.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(pre_texel_pos.xy,<span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>lighting importance sampling pdf visualization:</p><p align="center">    <img src="/resource/simlumen/image/lighting_is_pdf_vis.png" width="60%" height="60%"></p><h3 id="Structured-Importance-Sampling"><a href="#Structured-Importance-Sampling" class="headerlink" title="Structured Importance Sampling"></a>Structured Importance Sampling</h3>]]></content>
    
    
    <categories>
      
      <category>My Projects</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Simplified Nanite In MiniEngine</title>
    <link href="/2024/05/08/Simplified-Nanite-Virtualized-Geometry-In-MiniEngine/"/>
    <url>/2024/05/08/Simplified-Nanite-Virtualized-Geometry-In-MiniEngine/</url>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>This is a simplified Nanite implementation (SimNanite) based on Unreal’s Nanite virtual geometry. We have implemented most of Unreal Nanite’s features.</p><p>In offline, we partition the triangles into clusters with the Metis graph partition library. Then, SimNanite partitions the clusters into cluster groups, builds the DAG (Directed Acyclic Graph) and BVH tree based on the cluster groups. In order to avoid the LOD crack, SimNanite simplify the mesh globally rather than simplifying the triangles per cluster.</p><p>At runtime, we implement a three-level GPU culling pipeline: instance culling, BVH node culling and cluster culling. In the BVH node culling pass, we use the MPMC ( Multiple Producers, Single Consumer ) model to transverse the BVH structure and integrate the cluster culling into the BVH culling shader for work balance.</p><p>We generate an indirect draw or indirect dispatch command for those clusters that pass the culling. If the cluster is small enough, we employ the software rasterization with compute shader.</p><p>During the rasterization pass, we write the cluster index and triangle index to the visibility buffer. In the next base pass or GBuffer rendering, we fetch these indices from the visibility buffer, calculate the pixel attributes (UV and normal) by barycentric coordinates and render the scene with these attributes.</p><h1 id="Nanite-Builder"><a href="#Nanite-Builder" class="headerlink" title="Nanite Builder"></a>Nanite Builder</h1><h2 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h2><p>SimNanite (Simplified Nanite) building is an offline mesh processing during mesh import. It splits the mesh into <strong>clusters</strong> to provide a fine-grained mesh culling with a graph partition algorithm. Beyond the cluster level, SimNanite partitions the cluster into <strong>groups</strong> to accelerate mesh culling. Cluster groups are the leaf nodes of the <strong>BVH structure</strong>. In addtion, SimNanite <strong>simplifies the merged clusters</strong> at the current level rather than separate clusters in order to avoid the Lod crack artifact without boundnary edge locking.</p><p align="center">    <img src="/resource/simnanite/image/nanite_builder_overview.png" width="60%" height="60%"></p><h2 id="Triangle-Partition"><a href="#Triangle-Partition" class="headerlink" title="Triangle Partition"></a>Triangle Partition</h2><p>SimNanite partitions the mesh into clusters in order to perform fine-grained GPU culling. Meshes can be viewed as graphs, whose nodes are vertex points and edges are mesh topology. With the graph representation, we can partition it with the Metis graph library. </p><p>Given a mesh without an index buffer, SimNanite processes the mesh triangles sequentially. For each triangle, SimNanite hash the vertex position to find the vertex index of the adjacent list array. Each vertex in the triangle has 6 edges. We add these edge points into the coresponding vertex adjacent unordered_set. </p><p align="center">    <img src="/resource/simnanite/image/find_vertex_adjacent.png" width="50%" height="50%"></p><p>The Metis library’s graph partition function input has two parts: vertex adjacent list array and vertex adjacent offsets. Vertex adjacent offsets record the offsets of each vertex in the vertex adjacent list.</p><p align="center">    <img src="/resource/simnanite/image/metis_input_format.png" width="60%" height="60%"></p><p>With the adjacent vertex list for each vertex, we can pack them into an array and record their offsets.</p><p align="center">    <img src="/resource/simnanite/image/metis_input.png" width="60%" height="60%"></p><p>After the triangle partition, Metis outputs an array containing the partition index of each vertex. The next step is to batch the triangles into clusters with the partition result and find out the linked clusters for each cluster. If the vertices of one triangle belong to different partitions, this triangle can be viewed as an “edge-cluster”. We add these clusters to the linked clusters array in order to partition the clusters in the next step.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">idx_t</span> tri_parts[<span class="hljs-number">3</span>];<br>tri_parts[<span class="hljs-number">0</span>] = part_a;<br><br><span class="hljs-type">int</span> triangle_part_num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (part_b != part_a)<br>&#123;<br>tri_parts[triangle_part_num] = part_b;<br>triangle_part_num++;<br>&#125;<br><br><span class="hljs-keyword">if</span> ((part_c != part_a) &amp;&amp; (part_c != part_b))<br>&#123;<br>tri_parts[triangle_part_num] = part_c;<br>triangle_part_num++;<br>&#125;<br><br><span class="hljs-keyword">if</span> (triangle_part_num == <span class="hljs-number">2</span>)<br>&#123;<br>out_clusters[tri_parts[<span class="hljs-number">0</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">1</span>]);<br>out_clusters[tri_parts[<span class="hljs-number">1</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">0</span>]);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (triangle_part_num == <span class="hljs-number">3</span>)<br>&#123;<br>out_clusters[tri_parts[<span class="hljs-number">0</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">1</span>]);<br>out_clusters[tri_parts[<span class="hljs-number">0</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">2</span>]);<br><br>out_clusters[tri_parts[<span class="hljs-number">1</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">0</span>]);<br>out_clusters[tri_parts[<span class="hljs-number">1</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">2</span>]);<br><br>out_clusters[tri_parts[<span class="hljs-number">2</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">0</span>]);<br>out_clusters[tri_parts[<span class="hljs-number">2</span>]].m_linked_cluster.<span class="hljs-built_in">insert</span>(tri_parts[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Cluster-Partition"><a href="#Cluster-Partition" class="headerlink" title="Cluster Partition"></a>Cluster Partition</h2><p>With clusters and linked clusters, we can partition them into cluster groups as we do in the triangle partition pass. Cluster group is the leaf node in BVH acceleration structure. Usually, it consists of four to eight clusters.</p><p align="center">    <img src="/resource/simnanite/image/vtx_clu_grp_map.png" width="50%" height="50%"></p><p>Below is the cluster visualization at LOD level 0, 1 and 2 in SimNanite:</p><p align="center">    <img src="/resource/simnanite/image/vis_clu_0.png" width="50%" height="50%"></p><p align="center">    <img src="/resource/simnanite/image/vis_clu_1.png" width="50%" height="50%"></p><p align="center">    <img src="/resource/simnanite/image/vis_clu_2.png" width="50%" height="50%"></p><h2 id="Mesh-Simplification"><a href="#Mesh-Simplification" class="headerlink" title="Mesh Simplification"></a>Mesh Simplification</h2><p>We simplify the mesh until the cluster number is less than 24 or fails to simplify the mesh. The mesh simplification library is Meshoptimizer. It employs the QEM method to simplify the mesh, which is similar to what the Unreal Engine does. Another important point is that we simplify the global mesh rather than the cluster, as the latter method causes the <strong>LOD crack</strong> whitout boundnary edge locking. </p><p align="center">    <img src="/resource/simnanite/image/mesh_simplify.png" width="50%" height="50%"></p><h2 id="Build-DAG"><a href="#Build-DAG" class="headerlink" title="Build DAG"></a>Build DAG</h2><p>In the DAG (Directed Acyclic Graph) building pass, we organize the data and translate it into a GPU-friendly structure to acclerate to GPU-culling performed later. </p><p align="center">    <img src="/resource/simnanite/image/adg_structure.png" width="70%" height="70%"></p><p>SimNanite merges the resources of all lod level into a global resource array. That is to say, a simnanite mesh resource only has one vertex buffer, one index buffer, one cluster group array and one cluster array. UE’s Nanite performs an additional compression process after mesh building. We ignore compression for simplicity.</p><p align="center">    <img src="/resource/simnanite/image/dag_data.png" width="50%" height="50%"></p><p>A nanite mesh resource contains several lod resources. Each LOD resource stores cluster group indices in the current level. The max cluster group number per LOD is 8.  It stores the vertex and index location in the mesh vertex buffer. Nanite mesh building consume a lot of time. To accelerate programming efficiency, we serialize the DAG structure on the disk and load it without building at the next launch.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSimNaniteClusterResource</span><br>&#123;<br>DirectX::BoundingBox m_bouding_box;<br><br><span class="hljs-type">int</span> m_index_count;<br><span class="hljs-type">int</span> m_start_index_location;<br><span class="hljs-type">int</span> m_start_vertex_location;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSimNaniteClusterGrpupResource</span><br>&#123;<br>DirectX::BoundingBox m_bouding_box;<br><span class="hljs-type">float</span> cluster_next_lod_dist;<br><span class="hljs-type">int</span> m_child_group_num;<br><span class="hljs-type">int</span> m_cluster_num;<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt;m_child_group_indices;<br>std::vector&lt;<span class="hljs-type">int</span>&gt;m_clusters_indices;<br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*group_serialize_fun)</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">void</span>* streaming)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Serialize</span><span class="hljs-params">(group_serialize_fun func, <span class="hljs-type">void</span>* streaming)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSimNaniteLodResource</span><br>&#123;<br><span class="hljs-type">int</span> m_cluster_group_num;<br><span class="hljs-type">int</span> m_cluster_group_index[<span class="hljs-number">8</span>];<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSimNaniteMeshResource</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>SSimNaniteMeshHeader m_header;<br><br>DirectX::BoundingBox m_bouding_box;<br><br>std::vector&lt;DirectX::XMFLOAT3&gt; m_positions;<br>std::vector&lt;DirectX::XMFLOAT3&gt; m_normals;<br>std::vector&lt;DirectX::XMFLOAT2&gt; m_uvs;<br>std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt; m_indices;<br><br>std::vector&lt;CSimNaniteClusterGrpupResource&gt; m_cluster_groups;<br>std::vector&lt;CSimNaniteClusterResource&gt;m_clusters;<br>std::vector&lt;CSimNaniteLodResource&gt; m_nanite_lods;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LoadFrom</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; source_file_an, <span class="hljs-type">const</span> std::wstring&amp; source_file, <span class="hljs-type">bool</span> bforce_rebuild = <span class="hljs-literal">false</span>)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Build-BVH"><a href="#Build-BVH" class="headerlink" title="Build BVH"></a>Build BVH</h2><p>UE’s nanite use BVH to acclerate the GPU cluster group culling and LOD selection. In the offline, UE builds the BVH by SAH (Surface Area Heuristic) method. In SimNanite, we find the maximum dimension of the bound box extents and sort the cluster goups based on the position distribution in the maximum dimension. After that, we split the cluster groups into 4 nodes and build the whole BVH tree bottom-up. Each LOD has a root BVH node. For example, the mesh that has four LOD contains four root nodes.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;SClusterGroupBVHNode&gt; leaf_nodes;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> clu_grp_idx = <span class="hljs-number">0</span>; clu_grp_idx &lt; lod_resource.m_cluster_group_num; clu_grp_idx++)<br>&#123;<br><span class="hljs-type">uint32_t</span> global_clu_grp_idx = lod_resource.m_cluster_group_start + clu_grp_idx;<br>SClusterGroupBVHNode leaf_node;<br>leaf_node.m_is_leaf_node = <span class="hljs-literal">true</span>;<br>leaf_node.m_cluster_group_index = global_clu_grp_idx;<br>leaf_node.m_bouding_box = out_nanite_reousource.m_cluster_groups[global_clu_grp_idx].m_bouding_box;<br>leaf_nodes.<span class="hljs-built_in">push_back</span>(leaf_node);<br>&#125;<br><br><span class="hljs-type">uint32_t</span> max_dimension_index = (bbox.Extents.x &gt; bbox.Extents.y) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br><span class="hljs-type">float</span> max_dimension = (bbox.Extents.x &gt; bbox.Extents.y) ? bbox.Extents.x : bbox.Extents.y;<br>max_dimension_index = (max_dimension &gt; bbox.Extents.z) ? max_dimension_index : <span class="hljs-number">2</span>;<br>max_dimension = (max_dimension &gt; bbox.Extents.z) ? max_dimension : bbox.Extents.z;<br>SCustomLess custom_less;<br>custom_less.m_split_dimension = max_dimension_index;<br><br>std::<span class="hljs-built_in">sort</span>(leaf_nodes.<span class="hljs-built_in">begin</span>(), leaf_nodes.<span class="hljs-built_in">end</span>(), custom_less);<br><br><span class="hljs-type">uint32_t</span> offset = bvh_nodes.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">uint32_t</span> level_node_num = leaf_nodes.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> leaf_idx = <span class="hljs-number">0</span>; leaf_idx &lt; leaf_nodes.<span class="hljs-built_in">size</span>(); leaf_idx++)<br>&#123;<br>bvh_nodes.<span class="hljs-built_in">push_back</span>(leaf_nodes[leaf_idx]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Culling"><a href="#Culling" class="headerlink" title="Culling"></a>Culling</h1><h2 id="Instance-Culling"><a href="#Instance-Culling" class="headerlink" title="Instance Culling"></a>Instance Culling</h2><p>This step performs instance-level GPU-Culling, which is easy to implement and not necessary to detail it. The input of this step is the scene instance data and the output is the instance culled by the camera.</p><p>scene instance data:</p><p align="center">    <img src="/resource/simnanite/image/ins_cull_scene.png" width="50%" height="50%"></p><p>instances viewed by camera:</p><p align="center">    <img src="/resource/simnanite/image/ins_cull_view.png" width="50%" height="50%"></p><p>instances culled by camera:</p><p align="center">    <img src="/resource/simnanite/image/ins_cull_scene_view.png" width="50%" height="50%"></p><h2 id="Persistent-Culling"><a href="#Persistent-Culling" class="headerlink" title="Persistent Culling"></a>Persistent Culling</h2><p>I tried to implement a DAG transversal at first. But I found it was too complicated to traverse to DAG in the compute shader. So I finally use the <strong>BVH structure</strong> to traverse the cluster group on GPU, which is same as the unreal does.</p><p>UE’s Nanite use the MPMC ( Multiple Producers, Single Consumer ) model to transverse the BVH structure. What’s more, it integrates the cluster culling into BVH culling shader for work balance. <strong>In SimNanite, we have implemented the two features (MPMC and integrate cluster culling) mentioned above.</strong></p><p align="center">    <img src="/resource/simnanite/image/persistent_cull_work_flow.png" width="80%" height="80%"></p><p>SimNanite processes the node culling tasks at first. After the previous node culling task has completed, the first thread in the group fetches the node tasks from the node MPMC culling task queue.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(node_processed_size == GROUP_PROCESS_NODE_NUM)<br>&#123;<br>    <span class="hljs-keyword">if</span>(group_index == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">InterlockedAdd</span>(queue_pass_state[<span class="hljs-number">0</span>].node_task_read_offset, GROUP_PROCESS_NODE_NUM, group_start_node_idx);<br>    &#125;<br>    <span class="hljs-built_in">GroupMemoryBarrierWithGroupSync</span>();<br><br>    node_processed_size = <span class="hljs-number">0</span>;<br>    node_start_idx = group_start_node_idx;<br>&#125;<br></code></pre></td></tr></table></figure><p>Then, the compute group counts the node tasks ready to process.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(is_node_ready)<br>&#123;<br>    <span class="hljs-built_in">InterlockedOr</span>(group_node_processed_mask, <span class="hljs-number">1u</span> &lt;&lt; group_index);<br>&#125;<br><span class="hljs-built_in">AllMemoryBarrierWithGroupSync</span>();<br></code></pre></td></tr></table></figure><p>We start the node culling task when at least one node is ready in the group. SimNanite generates cluster culling tasks and pushes these tasks to the cluster culling queue if a node is a leaf node and its cluster group error is small enough. Otherwise, SimNanite generates BVH node culling tasks and push these to the BVH node culling queue.</p><p align="center">    <img src="/resource/simnanite/image/process_node.png" width="70%" height="70%"></p><h2 id="Cluster-Culling"><a href="#Cluster-Culling" class="headerlink" title="Cluster Culling"></a>Cluster Culling</h2><p>Cluster culling is a two-pass process. The first pass is performed at the persistent culling stage. It will process the cluster culling task if there are no node culling tasks for the compute group to process. SimNanite dispatches an additional cluster culling pass after the persistent culling stage to process tasks that were not handled in the previous stage.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(clu_task_start_index == <span class="hljs-number">0xFFFFFFFF</span>u)<br>&#123;<br>    <span class="hljs-keyword">if</span>(group_index == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">InterlockedAdd</span>(queue_pass_state[<span class="hljs-number">0</span>].cluster_task_read_offset, <span class="hljs-number">1</span>, group_start_clu_index);<br>    &#125;<br>    <span class="hljs-built_in">GroupMemoryBarrierWithGroupSync</span>();<br>    clu_task_start_index = group_start_clu_index;<br>&#125;<br><br><span class="hljs-keyword">if</span> (group_index == <span class="hljs-number">0</span>)<br>&#123;<br>    group_node_task_num = queue_pass_state[<span class="hljs-number">0</span>].node_num;<br>    group_clu_task_size = cluster_task_batch_size.<span class="hljs-built_in">Load</span>(clu_task_start_index * <span class="hljs-number">4</span> <span class="hljs-comment">/*sizeof uint*/</span>);<br>&#125;<br><span class="hljs-built_in">GroupMemoryBarrierWithGroupSync</span>();<br><br>uint clu_task_ready_size = group_clu_task_size;<br><span class="hljs-keyword">if</span>(!has_node_task &amp;&amp; clu_task_ready_size == <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(clu_task_ready_size &gt; <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span>(group_index &lt; clu_task_ready_size)<br>    &#123;<br>        <span class="hljs-type">const</span> uint2 cluster_task = cluster_task_queue.<span class="hljs-built_in">Load2</span>(clu_task_start_index * <span class="hljs-number">8</span> <span class="hljs-comment">/*sizeof(uint2)*/</span>);<br>        <span class="hljs-type">const</span> uint cluster_task_instance_index = cluster_task.x;<br>        <span class="hljs-type">const</span> uint cluster_task_clu_start_index = cluster_task.y;<br>        <span class="hljs-built_in">ProcessCluster</span>(cluster_task_instance_index, cluster_task_clu_start_index + group_index);<br>    &#125;<br>    clu_task_start_index = <span class="hljs-number">0xFFFFFFFF</span>u;<br>&#125;<br><br><span class="hljs-type">int</span> node_task_num = group_node_task_num;<br><span class="hljs-keyword">if</span> (has_node_task &amp;&amp; node_task_num == <span class="hljs-number">0</span>)<br>&#123;<br>    has_node_task = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Generate-Indirect-Draw-Command"><a href="#Generate-Indirect-Draw-Command" class="headerlink" title="Generate Indirect Draw Command"></a>Generate Indirect Draw Command</h1><p>An indirect draw command is generated during cluster culling. SimNanite uses <strong>software rasterization</strong> for those clusters that are small enough, which is the same as UE’s Nanite solution.</p><p align="center">    <img src="/resource/simnanite/image/generate_indirect_draw.png" width="70%" height="70%"></p><p>SimNanite uses instance ID to index the cluster buffer for hardware rasterization. For software rasterization, SimNanite uses group ID to index the cluster buffer. Each compute group processes one cluster triangle.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SIndirectDrawParameters indirect_draw_parameters;<br>indirect_draw_parameters.vertex_count = <span class="hljs-number">1701</span>;<br>indirect_draw_parameters.instance_count = hardware_indirect_draw_num.<span class="hljs-built_in">Load</span>(<span class="hljs-number">0</span>);<br>indirect_draw_parameters.start_vertex_location = <span class="hljs-number">0</span>;<br>indirect_draw_parameters.start_instance_location = <span class="hljs-number">0</span>;<br>hardware_draw_indirect[<span class="hljs-number">0</span>] = indirect_draw_parameters;<br><br>SIndirectDispatchCmd indirect_dispatch_parameters;<br>indirect_dispatch_parameters.thread_group_count_x = software_indirect_draw_num.<span class="hljs-built_in">Load</span>(<span class="hljs-number">0</span>);<br>indirect_dispatch_parameters.thread_group_count_y = <span class="hljs-number">1</span>;<br>indirect_dispatch_parameters.thread_group_count_z = <span class="hljs-number">1</span>;<br>software_draw_indirect[<span class="hljs-number">0</span>] = indirect_dispatch_parameters;<br></code></pre></td></tr></table></figure><h1 id="Hardware-Rasterization"><a href="#Hardware-Rasterization" class="headerlink" title="Hardware Rasterization"></a>Hardware Rasterization</h1><p>SimNanite uses indirect draw instances for hardware rasterization clusters. Vertex shaders index clusters by instance ID. Clusters store the information about the vertex buffer range. It should be noticed that all vertex buffers in the <strong>scene are merged into a global single buffer</strong>. Otherwise, we can rasterize the scene only with an indirect draw call if we don’t merge buffers together. UE’s Nanite also implement a complicated steaming solution for the global scene vertex buffer mannagement.</p><p align="center">    <img src="/resource/simnanite/image/hardware_indirect_draw.png" width="70%" height="70%"></p><p>We load the vertex position data indexed by scene index buffer and culled from cluster buffer. After MVP transform, we store the cluster index and triangle index into the visibility buffer. In additional, we store the material index to the material ID buffer, which will be used as depth test buffer in the latter rendering pass.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(vertex_id &lt; index_count)<br>&#123;<br>    uint index_read_pos = start_index_location + vertex_id;<br><br>    uint vertex_index_idx = global_index_buffer.<span class="hljs-built_in">Load</span>(index_read_pos * <span class="hljs-number">4</span><span class="hljs-comment">/*sizeof int*/</span>);<br>    uint vertex_idx = vertex_index_idx + start_vertex_location;<br><br>    float3 vertex_position = <span class="hljs-built_in">asfloat</span>(global_vertex_pos_buffer.<span class="hljs-built_in">Load3</span>((vertex_idx * <span class="hljs-number">3</span>)* <span class="hljs-number">4</span><span class="hljs-comment">/*sizeof int*/</span>));<br><br>    uint triangle_id = vertex_id / <span class="hljs-number">3</span>;<br>    uint visibility_value = triangle_id &amp; <span class="hljs-number">0x0000FFFF</span>u;<br>    visibility_value = visibility_value | <span class="hljs-built_in">uint</span>(instance_id &lt;&lt; <span class="hljs-number">16u</span>);<br><br>    float4 position = <span class="hljs-built_in">float4</span>(vertex_position, <span class="hljs-number">1.0</span>);<br>    float3 worldPos = <span class="hljs-built_in">mul</span>(cluster_draw.world_matrix, position).xyz;<br>    vsOutput.position = <span class="hljs-built_in">mul</span>(ViewProjMatrix, <span class="hljs-built_in">float4</span>(worldPos, <span class="hljs-number">1.0</span>));<br>    vsOutput.visibility_value = visibility_value;<br>    vsOutput.material_idx = cluster_draw.material_idx;<br>&#125;<br></code></pre></td></tr></table></figure><p>Bellow is the visibility buffer visualization:</p><p align="center">    <img src="/resource/simnanite/image/visibility_buffer.png" width="100%" height="100%"></p><h1 id="Software-Rasterization"><a href="#Software-Rasterization" class="headerlink" title="Software Rasterization"></a>Software Rasterization</h1><p>In cases of triangles that are small enough, we use software rasterization by the compute shader. Each thread in the compute group processes one triangle. First, load the vertex position buffer based on the triangle index and the cluster index.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint start_index_this_triangle = start_index_location + triangle_index * <span class="hljs-number">3</span>;<br>uint3 indices = global_index_buffer.<span class="hljs-built_in">Load3</span>((start_index_this_triangle / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> * <span class="hljs-number">4</span> <span class="hljs-comment">/* 3 * sizeof(uint) */</span>);<br><br>float3 vertex_pos_a = <span class="hljs-built_in">asfloat</span>(global_vertex_pos_buffer.<span class="hljs-built_in">Load3</span>((start_vertex_location + indices.x) * <span class="hljs-number">3</span> * <span class="hljs-number">4</span> <span class="hljs-comment">/* 3 * sizeof(float)*/</span>));<br>float3 vertex_pos_b = <span class="hljs-built_in">asfloat</span>(global_vertex_pos_buffer.<span class="hljs-built_in">Load3</span>((start_vertex_location + indices.y) * <span class="hljs-number">3</span> * <span class="hljs-number">4</span> <span class="hljs-comment">/* 3 * sizeof(float)*/</span>));<br>float3 vertex_pos_c = <span class="hljs-built_in">asfloat</span>(global_vertex_pos_buffer.<span class="hljs-built_in">Load3</span>((start_vertex_location + indices.z) * <span class="hljs-number">3</span> * <span class="hljs-number">4</span> <span class="hljs-comment">/* 3 * sizeof(float)*/</span>));<br></code></pre></td></tr></table></figure><p>Then, calculate the screen position based on the cluster instance world matrix and view projection matrix.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float4x4 world_matrix = cluster_draw.world_matrix;<br>        <br>float4 worldPos_a = <span class="hljs-built_in">mul</span>(world_matrix, position_a).xyzw;<br>float4 worldPos_b = <span class="hljs-built_in">mul</span>(world_matrix, position_b).xyzw;<br>float4 worldPos_c = <span class="hljs-built_in">mul</span>(world_matrix, position_c).xyzw;<br><br>float4 clip_pos_a = <span class="hljs-built_in">mul</span>(ViewProjMatrix, worldPos_a);<br>float4 clip_pos_b = <span class="hljs-built_in">mul</span>(ViewProjMatrix, worldPos_b);<br>float4 clip_pos_c = <span class="hljs-built_in">mul</span>(ViewProjMatrix, worldPos_c);<br><br>float3 ndc_pos_a = <span class="hljs-built_in">float3</span>(clip_pos_a.xyz / clip_pos_a.w);<br>float3 ndc_pos_b = <span class="hljs-built_in">float3</span>(clip_pos_b.xyz / clip_pos_b.w);<br>float3 ndc_pos_c = <span class="hljs-built_in">float3</span>(clip_pos_c.xyz / clip_pos_c.w);<br><br>float4 screen_pos_a = <span class="hljs-built_in">float4</span>((ndc_pos_a.x + <span class="hljs-number">1.0f</span>) * <span class="hljs-number">0.5f</span> * rendertarget_size.x, (ndc_pos_a.y + <span class="hljs-number">1.0f</span>) * <span class="hljs-number">0.5f</span> * rendertarget_size.y, ndc_pos_a.z, clip_pos_a.w); <br>float4 screen_pos_b = <span class="hljs-built_in">float4</span>((ndc_pos_b.x + <span class="hljs-number">1.0f</span>) * <span class="hljs-number">0.5f</span> * rendertarget_size.x, (ndc_pos_b.y + <span class="hljs-number">1.0f</span>) * <span class="hljs-number">0.5f</span> * rendertarget_size.y, ndc_pos_b.z, clip_pos_b.w); <br>float4 screen_pos_c = <span class="hljs-built_in">float4</span>((ndc_pos_c.x + <span class="hljs-number">1.0f</span>) * <span class="hljs-number">0.5f</span> * rendertarget_size.x, (ndc_pos_c.y + <span class="hljs-number">1.0f</span>) * <span class="hljs-number">0.5f</span> * rendertarget_size.y, ndc_pos_c.z, clip_pos_c.w); <br></code></pre></td></tr></table></figure><p>Execute the back face culling process.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">IsBackFace</span>(ndc_pos_a, ndc_pos_b, ndc_pos_c))<br>&#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Rasterize the screen pixels covered by triangles. This is the simplest implementation and can be optimized in the future.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">int2 bbox_min = (int2)<span class="hljs-built_in">min</span>(screen_pos_a.xy,  <span class="hljs-built_in">min</span>(screen_pos_b.xy, screen_pos_c.xy));<br>int2 bbox_max = (int2)<span class="hljs-built_in">max</span>(screen_pos_a.xy,  <span class="hljs-built_in">max</span>(screen_pos_b.xy, screen_pos_c.xy));<br><br><span class="hljs-keyword">if</span>(bbox_max.x &gt; <span class="hljs-number">0</span> &amp;&amp; bbox_max.y &gt; <span class="hljs-number">0</span> &amp;&amp; bbox_min.x &lt; rendertarget_size.x &amp;&amp; bbox_min.y &lt; rendertarget_size.y)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = bbox_min.y; y &lt;= bbox_max.y; y++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = bbox_min.x; x &lt;= bbox_max.x; x++)<br>        &#123;<br>            ......<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Finally, we calculate the barycentric coordinates and screen depth of this pixel. The compute shader is not able to perform a hardware depth test, so we convert the depth value type from float to int and use <strong>InterlockedMax</strong> to perform a software depth test.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 barycentric = <span class="hljs-built_in">BarycentricCoordinate</span>(<span class="hljs-built_in">float2</span>(x, y), screen_pos_a.xy, screen_pos_b.xy, screen_pos_c.xy);<br><span class="hljs-keyword">if</span>(barycentric.x &gt;= <span class="hljs-number">0</span> &amp;&amp; barycentric.y &gt;= <span class="hljs-number">0</span> &amp;&amp; barycentric.z &gt;= <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-type">float</span> depth = barycentric.x * screen_pos_a.z + barycentric.y * screen_pos_b.z + barycentric.z * screen_pos_c.z;<br><br>    uint depth_uint = depth * <span class="hljs-number">0x7FFFFFFF</span>u;<br>    uint2 pixel_pos = <span class="hljs-built_in">uint2</span>(x, rendertarget_size.y - y);<br>    uint pre_depth;<br>    <span class="hljs-built_in">InterlockedMax</span>(intermediate_depth_buffer[pixel_pos], depth_uint, pre_depth);<br>    <span class="hljs-keyword">if</span> (depth_uint &gt; pre_depth)<br>    &#123;<br>        uint triangle_id = triangle_index;<br>        uint visibility_value = triangle_id &amp; <span class="hljs-number">0x0000FFFF</span>u;<br>        visibility_value = visibility_value | <span class="hljs-built_in">uint</span>(instance_id &lt;&lt; <span class="hljs-number">16u</span>);<br><br>        out_vis_buffer[pixel_pos] = visibility_value;<br>        out_mat_id_buffer[pixel_pos] = cluster_draw.material_idx;<br>        visualize_softrasterization[pixel_pos] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Below is a visualization of the software rasterization process. The <strong>green</strong> area is rasterized by the software compute shader.</p><p>Hardware Rasterization Part:</p><p align="center">    <img src="/resource/simnanite/image/vis_softraster_hard.png" width="70%" height="70%"></p><p>Software Rasterization Part:</p><p align="center">    <img src="/resource/simnanite/image/vis_softraster_soft.png" width="70%" height="70%"></p><p>Visualize Visibility Buffer:</p><p align="center">    <img src="/resource/simnanite/image/vis_softraster_visbuffer.png" width="70%" height="70%"></p><h1 id="BasePass-or-GBuffer-Pass"><a href="#BasePass-or-GBuffer-Pass" class="headerlink" title="BasePass or GBuffer Pass"></a>BasePass or GBuffer Pass</h1><p>With the visibility buffer, we can finally render the scene. First, SimNanite transfers the material index to the depth buffer, which will be used in the next pass’s depth test operation.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">ps_main</span><span class="hljs-params">(in float2 tex: TexCoord0)</span>: SV_Depth</span><br><span class="hljs-function">&#123;</span><br>    uint2 load_pos = tex * rendertarget_size;<br>    uint material_index = mat_id_buffer.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(load_pos.xy, <span class="hljs-number">0</span>));<br>    <span class="hljs-type">float</span> depth = <span class="hljs-built_in">float</span>(material_index) / <span class="hljs-number">1024.0</span>;<br>    <span class="hljs-keyword">return</span> depth;<br>&#125;<br></code></pre></td></tr></table></figure><p>Then we draw a full screen quad for each material. The depth of this quad equals to material index.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vs_main</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    in uint VertID : SV_VertexID,</span></span><br><span class="hljs-params"><span class="hljs-function">    out float2 Tex : TexCoord0,</span></span><br><span class="hljs-params"><span class="hljs-function">    out float4 Pos : SV_Position)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> depth = <span class="hljs-built_in">float</span>(material_index) / <span class="hljs-number">1024.0</span>;<br><br>    Tex = <span class="hljs-built_in">float2</span>(<span class="hljs-built_in">uint2</span>(VertID, VertID &lt;&lt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">2</span>);<br>    Pos = <span class="hljs-built_in">float4</span>(<span class="hljs-built_in">lerp</span>(<span class="hljs-built_in">float2</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>), <span class="hljs-built_in">float2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>), Tex), depth, <span class="hljs-number">1</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>Unreal’s Nanite dipatches an additional material classify pass to split the screen into tiles. Then Unreal uses indirect draw to draw the tiles generated in the previous pass, which reduces quad overdraw. In SimNanite, we remove the classify pass and draw the screen quad directly. For each material quad, we only render pixels that pass the material index depth test. Below are two material quad depth test figures. The first one is bunny material and the second one is teapot material.</p><p align="center">    <img src="/resource/simnanite/image/depth_test_0.png" width="50%" height="50%"></p><p align="center">    <img src="/resource/simnanite/image/depth_test_1.png" width="50%" height="50%"></p><p>For each pixel, SimNanite fetches the cluster index and triangle index from the visibility buffer. Then, we calculate the barycentric coordinates based on the vertex position buffer. Finally, SimNanite calculates the vertex attributes, such as pixel UV and pixel normal by barycentric coordnates. The render the material with these attributes.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">float4 <span class="hljs-title">ps_main</span><span class="hljs-params">(in float2 tex: TexCoord0)</span>: SV_Target0</span><br><span class="hljs-function">&#123;</span><br>    uint2 load_pos = tex * rendertarget_size;<br>    uint depth_buffer = in_depth_buffer.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(load_pos.xy,<span class="hljs-number">0</span>));<br>    float4 output_color = <span class="hljs-built_in">float4</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(depth_buffer != <span class="hljs-number">0</span>)<br>    &#123;<br>        uint visibility_value = in_vis_buffer.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(load_pos.xy,<span class="hljs-number">0</span>));<br>        uint cluster_index = visibility_value &gt;&gt; <span class="hljs-number">16</span>;<br>        uint triangle_index = visibility_value &amp; <span class="hljs-number">0x0000FFFF</span>u;<br><br>        <span class="hljs-comment">// calculate vertex attributes</span><br>        <span class="hljs-comment">// ......</span><br><br>        float3 barycentric = <span class="hljs-built_in">BarycentricCoordinate</span>(<span class="hljs-built_in">float2</span>(load_pos.x, rendertarget_size.y - load_pos.y), screen_pos_a.xy, screen_pos_b.xy, screen_pos_c.xy);<br>        <span class="hljs-type">float</span> z = <span class="hljs-number">1</span> / (barycentric.x / position_a.w + barycentric.y / position_b.w + barycentric.z / position_c.w);<br>        barycentric = barycentric / <span class="hljs-built_in">float3</span>(position_a.w, position_b.w, position_c.w) * z;<br><br>        float2 vertex_uv_a = <span class="hljs-built_in">asfloat</span>(global_vertex_uv_buffer.<span class="hljs-built_in">Load2</span>((start_vertex_location + indices.x) * <span class="hljs-number">2</span> * <span class="hljs-number">4</span> <span class="hljs-comment">/* 2 * sizeof(float)*/</span>));<br>        float2 vertex_uv_b = <span class="hljs-built_in">asfloat</span>(global_vertex_uv_buffer.<span class="hljs-built_in">Load2</span>((start_vertex_location + indices.y) * <span class="hljs-number">2</span> * <span class="hljs-number">4</span> <span class="hljs-comment">/* 2 * sizeof(float)*/</span>));<br>        float2 vertex_uv_c = <span class="hljs-built_in">asfloat</span>(global_vertex_uv_buffer.<span class="hljs-built_in">Load2</span>((start_vertex_location + indices.z) * <span class="hljs-number">2</span> * <span class="hljs-number">4</span> <span class="hljs-comment">/* 2 * sizeof(float)*/</span>));<br><br>        float2 pix_uv = vertex_uv_a * barycentric.x + vertex_uv_b * barycentric.y + vertex_uv_c * barycentric.z;<br>        float4 baseColor = baseColorTexture.<span class="hljs-built_in">Sample</span>(baseColorSampler, pix_uv);<br>        output_color = <span class="hljs-built_in">float4</span>(baseColor.xyz, <span class="hljs-number">1.0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Bellow is the SimNanite final result:</p><p align="center">    <img src="/resource/simnanite/image/final0.png" width="50%" height="50%"></p><p align="center">    <img src="/resource/simnanite/image/final1.png" width="50%" height="50%"></p><p><a href="https://github.com/ShawnTSH1229/SimNanite"><u><strong>simplified nanite code</strong></u></a></p>]]></content>
    
    
    <categories>
      
      <category>My Projects</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sky Atmosphere In XEngine</title>
    <link href="/2024/05/05/Sky-Atmosphere-In-XEngine/"/>
    <url>/2024/05/05/Sky-Atmosphere-In-XEngine/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Note</strong> that this <a href="https://github.com/lvcheng1229/XEnigine/blob/main/Source/Shaders/SkyAtmosphere.hlsl"><u><strong>Project</strong></u></a>  was written during my undergraduate studies. Some points may be incorrect.</p></blockquote><h1 id="Brief-Introduction-to-UE’s-Implementation"><a href="#Brief-Introduction-to-UE’s-Implementation" class="headerlink" title="Brief Introduction to UE’s Implementation"></a>Brief Introduction to UE’s Implementation</h1><p>This project is based on the implementation of the <strong>unreal engine</strong>. I assume that you have a basic knowledge of volume rendering and will <strong>not go into detail</strong> about it. If you are interested, you can read my blog about <a href="https://shawntsh1229.github.io/2024/05/05/Volume-Rendering-In-Offline-Rendering/"><u><strong>Volume Rendering In Offline Rendering</strong></u></a>.<br>Here are some basic terms about the sky atmosphere rendering:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: absorption coefficient, the probability density that light is absorbed per unit distance traveled in the medium.<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: scattering coefficient, the probability of an out-scattering event occurring per unit distance.<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: attenuation coefficient, the sum of the absorption coefficient and the scattering coefficient, describes the combined effect of the absorption and out scattering.<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>t</mi></msub><mo>=</mo><msub><mi>σ</mi><mi>a</mi></msub><mo>+</mo><msub><mi>σ</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_{t} = \sigma_{a} + \sigma_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>: transmittance, the fraction of radiance that is transmitted between two points<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><msub><mi>σ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>s</mi></mrow></msup></mrow><annotation encoding="application/x-tex">T(a,b)=e^{-\int_{a}^{b}\sigma_{t}(h)\mathrm{d}s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0358em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0358em;"><span style="top:-3.072em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9482em;"><span style="top:-2.1225em;margin-left:-0.1945em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-2.9521em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3775em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2963em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span><span class="mord mathrm mtight">d</span><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">\phi_{u}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: phase function, the angular distribution of scattered radiation at a point<br><p><strong>Volume Rendering Euqation</strong>:<br>The lighting result at the point x from direct v equals the combination of single scattering and multi-scattering:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>L</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>L</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(x,v) = L_{1}(x,v) + L_{n}(x,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span><br><p>The single scattering result at point x from point p in direction v is the sum of the transmitted radiance reflected from the ground and the integration of the radiance from the view point to the ground or sky:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>p</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><msub><mi>L</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo>+</mo><msub><mi>t</mi><mrow><mi>a</mi><mi>t</mi><mi>m</mi><mi>o</mi></mrow></msub><msub><mi>l</mi><mi>i</mi></msub><mo stretchy="false">)</mo><msub><mi>ϕ</mi><mi>u</mi></msub><msub><mi>E</mi><mi>i</mi></msub><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">L_{1}(x,p,v) = T(x,p)L_{0}(p,v)+\int_{t=0}^{||p-x||}\sigma_{s}T(x,x-tv)T(x-tv,x-tv+t_{atmo}l_{i})\phi_{u}E_{i}\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6984em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span><br><p>N-bounce multi-scattering (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">L_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) integrate the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">G_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in the point along the view direction, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">G_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is the integration of the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">L_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> scattering result from the direction on the sphere. Multi-Scattering is difficult to calculate compared to Single-Scattering. There are many simplifications that are made in UE’s sky-atmosphere for multi-scattering, we will be introducing it later.</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><msub><mi>G</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo separator="true">,</mo><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">L_{n}(x,v) = \int_{t=0}^{||p-x||}\sigma_{s}(x)T(x,x-tv)G_{n}(x-tv,-v)\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>L</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><msub><mi>ϕ</mi><mi>u</mi></msub><mi mathvariant="normal">d</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">G_{n}(x,v)=\int_{\Omega}L_{n-1}(x,-v)\phi_{u}\mathrm{d}w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span><h1 id="Transmittance-LUT"><a href="#Transmittance-LUT" class="headerlink" title="Transmittance LUT"></a>Transmittance LUT</h1><p>There are two important properties of beam transmittance. The first property is that the transmittance between two points is the same in both directions if the attenuation coefficient satisfies the directional symmetry <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>σ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mo>−</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{t}(w) = \sigma_{t}(-w) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(a,b) = T(b,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span><p>Another important property, true in all media, is that transmittance is multiplicative along points on a ray:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(a,b) = T(a,c) T(c,b) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span><p>This property enables us to calculate the transmittance between any two points quickly by precalculating the transmittance between these two points and the boundary of the sky atmosphere:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mi>n</mi><mi>a</mi><mi>r</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>b</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mi>n</mi><mi>a</mi><mi>r</mi><mi>y</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">T(a,b) = \frac{T(a,boundnary)} {T(b,boundnary)} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">b</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">na</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ry</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">na</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ry</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> is a 3-dimensional function of the dimension x,y and z. We can convert this function to a 2-dimensional function of the view height and view zenith angle, since the earth is symmetric horizontally.<p align="center">    <img src="/resource/skyatmosphere/image/lut_104.png" width="64%" height="64%"></p><p>Transmittance lut’s u coordinate is view zenith cosine angle ranging from -1 to 1. In addition, the v coordinate is mapped to the view height ranging from the bottom radius to the top radius. Bruneton’s paper use a generic mapping, working for any atmosphere, but still providing an increased sampling rate near the horizon. In the following figure, the red curve represents Bruneton’s implementation, while the purple curve represents a linear interpolation.</p><p align="center">    <img src="/resource/skyatmosphere/image/view_height.png" width="50%" height="50%"></p><p>We can get the world position and world direction from the view height and the view zenith angle mapped from the texture coordinates.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float2 UV = (PixPos) * SkyAtmosphere_TransmittanceLutSizeAndInvSize.zw;<br><br><span class="hljs-type">float</span> ViewHeight;<br><span class="hljs-type">float</span> ViewZenithCosAngle;<br><span class="hljs-built_in">UvToLutTransmittanceParams</span>(ViewHeight, ViewZenithCosAngle, UV);<br><br>float3 WorldPos = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0.0f</span>, ViewHeight, <span class="hljs-number">0</span>);<br>float3 WorldDir = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0.0f</span>, ViewZenithCosAngle,<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0f</span> - ViewZenithCosAngle * ViewZenithCosAngle));<br></code></pre></td></tr></table></figure><p>The next step is to calculate optical depth. It is an intergal along the direction of view from the point of view to the boundary of the atmosphere:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><msubsup><mo>∫</mo><mn>0</mn><mi>p</mi></msubsup><msub><mi>σ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mi>d</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\tau(s)= -\int_{0}^{p} \sigma_{t}(s)ds</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2151em;vertical-align:-0.3558em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8593em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span></span></span></span><p>This equation is viewed as a ray marching from the view point to the boundary for coding:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> dt = tMax / SampleCount;<br>float3 OpticalDepth = <span class="hljs-number">0.0f</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">float</span> SampleI = <span class="hljs-number">0.0f</span>; SampleI &lt; SampleCount; SampleI += <span class="hljs-number">1.0f</span>)<br>&#123;<br>    t = tMax * (SampleI + DEFAULT_SAMPLE_OFFSET) / SampleCount;<br>float3 P = WorldPos + t * WorldDir;<br>MediumSampleRGB Medium = <span class="hljs-built_in">SampleMediumRGB</span>(P);<br>    <span class="hljs-type">const</span> float3 SampleOpticalDepth = Medium.Extinction * dt;<br>OpticalDepth += SampleOpticalDepth;<br>&#125;<br><span class="hljs-keyword">return</span> OpticalDepth;<br></code></pre></td></tr></table></figure><p>The medium extinction contains two parts: mie extinction and rayleigh extinction, which is a expontial function of the view height:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>σ</mi><mrow><mi>t</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>σ</mi><mrow><mi>t</mi><mi mathvariant="normal">_</mi><mi>r</mi><mi>a</mi><mi>y</mi><mi>l</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow></msub><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{t}(h) = \sigma_{t\_mi}(h) + \sigma_{t\_rayleigh}(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.117em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight">mi</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.117em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span><p>Participating media following the Rayleigh and Mie theories have an altitude density distribution of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi><mfrac><mrow><mo>−</mo><mi>h</mi></mrow><mrow><mn>8</mn><mi>k</mi><mi>m</mi></mrow></mfrac></msup></mrow><annotation encoding="application/x-tex">d_{t\_mi}(h) = e^{\frac{-h}{8km}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.117em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight">mi</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.979em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.979em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.88em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">8</span><span class="mord mathnormal mtight">km</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi mathvariant="normal">_</mi><mi>r</mi><mi>a</mi><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi><mfrac><mrow><mo>−</mo><mi>h</mi></mrow><mrow><mn>1.2</mn><mi>k</mi><mi>m</mi></mrow></mfrac></msup></mrow><annotation encoding="application/x-tex">d_{t\_ray}(h) = e^{\frac{-h}{1.2km}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.117em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.979em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.979em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.88em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1.2</span><span class="mord mathnormal mtight">km</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span> , respectively.<br>Rayleigh participation media components have different coefficients, which results in a blue sky at noon and a red sky at dusk.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">MediumSampleRGB <span class="hljs-title">SampleMediumRGB</span><span class="hljs-params">(in float3 WorldPos)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> SampleHeight = <span class="hljs-built_in">max</span>(<span class="hljs-number">0.0</span>, (<span class="hljs-built_in">length</span>(WorldPos) - Atmosphere_BottomRadiusKm));<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> DensityMie = <span class="hljs-built_in">exp</span>(Atmosphere_MieDensityExpScale * SampleHeight);<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> DensityRay = <span class="hljs-built_in">exp</span>(Atmosphere_RayleighDensityExpScale * SampleHeight);<br><br>    MediumSampleRGB s;<br><br>    s.ScatteringMie = DensityMie * Atmosphere_MieScattering.rgb;<br>    s.AbsorptionMie = DensityMie * Atmosphere_MieAbsorption.rgb;<br>    s.ExtinctionMie = DensityMie * Atmosphere_MieExtinction.rgb; <span class="hljs-comment">// equals to  ScatteringMie + AbsorptionMie</span><br><br>    s.ScatteringRay = DensityRay * Atmosphere_RayleighScattering.rgb;<br>    s.AbsorptionRay = <span class="hljs-number">0.0f</span>;<br>    s.ExtinctionRay = s.ScatteringRay + s.AbsorptionRay;<br><br>    s.Scattering = s.ScatteringMie + s.ScatteringRay;<br>    s.Absorption = s.AbsorptionMie + s.AbsorptionRay;<br>    s.Extinction = s.ExtinctionMie + s.ExtinctionRay;<br>    s.Albedo = <span class="hljs-built_in">GetAlbedo</span>(s.Scattering, s.Extinction);<br><br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>Here is the transmittance LUT result. We ignore the ozone’s contribution, which results in the absence of the purple region in the LUT:</p><p align="center">    <img src="/resource/skyatmosphere/image/lut_visualize.png" width="75%" height="75%"></p><h1 id="Multi-Scattering"><a href="#Multi-Scattering" class="headerlink" title="Multi-Scattering"></a>Multi-Scattering</h1><p>As we mentioned above, it’s difficult to calculate the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">G_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, unreal engine makes two simplification for this part.<br>The first simplification is:</p><blockquote><p>Scattering events with order greater or equal to 2 are executed using an isotropic phase function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">\phi_{u}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></blockquote><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>L</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><msub><mi>ϕ</mi><mi>u</mi></msub><mi mathvariant="normal">d</mi><mi>w</mi><mo>≈</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>L</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">G_{n}(x,v)=\int_{\Omega}L_{n-1}(x,-v)\phi_{u}\mathrm{d}w\approx \frac{1}{4\pi}\int_{\Omega}L_{n-1}(x,-v)\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2009em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span><br><br><p>The second simplification is:</p><blockquote><p>All points within the neighborhood of the position we currently shade receive the same amount of second order scattered light</p></blockquote><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo separator="true">,</mo><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi><mo>≈</mo><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">L_{n-1}(x,v) = \int_{t=0}^{||p-x||}\sigma_{s}(x)T(x,x-tv)G_{n-1}(x-tv,-v)\mathrm{d}t\approx G_{n-1}\int_{t=0}^{||p-x||}\sigma_{s}(x)T(x,x-tv)\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span><br><br><p>Combine these equation together, we get:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>≈</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>L</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>w</mi><mo>≈</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi><mi mathvariant="normal">d</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">G_{n}(x,v)\approx \frac{1}{4\pi}\int_{\Omega}L_{n-1}(x,-v)\mathrm{d}w\approx \frac{1}{4\pi} G_{n-1}\int_{\Omega}\int_{t=0}^{||p-x||}\sigma_{s}(x)T(x,x-tv)\mathrm{d}t\mathrm{d}w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2009em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span><br><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><msub><mi>G</mi><mi>n</mi></msub><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi><mi mathvariant="normal">d</mi><mi>w</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mi mathvariant="normal">d</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\frac{G_{n}}{G_{n-1}} = \frac{1}{4\pi}\int_{\Omega}\int_{t=0}^{||p-x||}\sigma_{s}(x)T(x,x-tv)\mathrm{d}t\mathrm{d}w = \frac{1}{4\pi}\int_{\Omega}f_{ms}\mathrm{d}w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3752em;vertical-align:-0.4868em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2025em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4868em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2009em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span><br><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mo>=</mo><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">f_{ms}=\int_{t=0}^{||p-x||}\sigma_{s}(x)T(x,x-tv)\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span><br><p>Our next step is to precompute the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mi mathvariant="normal">d</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\frac{1}{4\pi}\int_{\Omega}f_{ms}\mathrm{d}w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2009em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> value and store it in the two-dimensional LUT table.UE’s sky atmosphere has three different integration methods for different quality levels. The first implementation is to integrate the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{ms}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> on the uniform sphere, which is expensive and only used in case of high quality.The second one is to integrate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{ms}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 8 times with the following ray direction:</p><p align="center">    <img src="/resource/skyatmosphere/image/ray_dir.png" width="50%" height="50%"></p><p>What we employed in the xengine is the last approach: sample twice from the view direction and negative direction:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><msub><mi>G</mi><mi>n</mi></msub><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mi mathvariant="normal">d</mi><mi>w</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><mo stretchy="false">(</mo><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>∗</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\frac{G_{n}}{G_{n-1}}=\frac{1}{4\pi}\int_{\Omega}f_{ms}\mathrm{d}w=\frac{1}{4\pi}(f_{ms}(x,v) + f_{ms}(x,-v)) * 0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3752em;vertical-align:-0.4868em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2025em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4868em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2009em;vertical-align:-0.3558em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathrm">d</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.5</span></span></span></span><br><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mo>=</mo><msubsup><mo>∫</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo>−</mo><mi>x</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></msubsup><msub><mi>σ</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mi>t</mi><mi>v</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">f_{ms}=\int_{t=0}^{||p-x||}\sigma_{s}(x)T(x,x-tv)\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4387em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0829em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">x</span><span class="mord mtight">∣∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> dt = tMax / SampleCount;<br>float3 Throughput = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">float</span> SampleI = <span class="hljs-number">0.0f</span>; SampleI &lt; SampleCount; SampleI += <span class="hljs-number">1.0f</span>)<br>&#123;<br>    t = tMax * (SampleI + DEFAULT_SAMPLE_OFFSET) / SampleCount;<br>    float3 P = WorldPos + t * WorldDir;<br>    <span class="hljs-type">float</span> PHeight = <span class="hljs-built_in">length</span>(P);<br><br>MediumSampleRGB Medium = <span class="hljs-built_in">SampleMediumRGB</span>(P);<br>    <span class="hljs-type">const</span> float3 SampleOpticalDepth = Medium.Extinction * dt * <span class="hljs-number">1.0f</span>;<br>    <span class="hljs-type">const</span> float3 SampleTransmittance = <span class="hljs-built_in">exp</span>(-SampleOpticalDepth);<br><br>MultiScatAs1 += Throughput * Medium.Scattering * <span class="hljs-number">1.0f</span> * dt;<br><br>    Throughput *= SampleTransmittance;<br>&#125;<br>OutMultiScatAs1=MultiScatAs1;<br></code></pre></td></tr></table></figure><p>With <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{ms}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, we can precompute the multi-scattering result in arbitray rorder.</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>2</mn></msub><mo>=</mo><msub><mi>G</mi><mn>1</mn></msub><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mo>=</mo><msub><mi>L</mi><mn>1</mn></msub><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">G_{2}=G_{1}f_{ms}=L_{1}\frac{1}{4\pi}f_{ms}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>3</mn></msub><mo>=</mo><msub><mi>G</mi><mn>2</mn></msub><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mo>=</mo><msub><mi>G</mi><mn>1</mn></msub><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub><mo>=</mo><msub><mi>L</mi><mn>1</mn></msub><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msubsup><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">G_{3}=G_{2}f_{ms}=G_{1}\frac{1}{4\pi}f_{ms}f_{ms}=L_{1}\frac{1}{4\pi}f_{ms}^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub><mo>=</mo><msub><mi>L</mi><mn>1</mn></msub><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><msubsup><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">G_{n}=L_{1}\frac{1}{4\pi}f_{ms}^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub><mo>+</mo><msub><mi>G</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>G</mi><mn>1</mn></msub><mo>=</mo><msub><mi>L</mi><mn>1</mn></msub><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><mo stretchy="false">(</mo><msubsup><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo>+</mo><msubsup><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msubsup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>L</mi><mn>1</mn></msub><mfrac><mn>1</mn><mrow><mn>4</mn><mi>π</mi></mrow></mfrac><mo stretchy="false">(</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G_{n}+G_{n-1}+ ... +G_{1}=L_{1}\frac{1}{4\pi}(f_{ms}^{n-1} +f_{ms}^{n-2}+ ... +1)=L_{1}\frac{1}{4\pi}(\frac{1}{1-f_{ms}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0611em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3262em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.1076em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span><br><p>The single scattering result <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is required to compute by the time of the  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{ms}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>  calculation.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 OutL_0, OutMultiScatAs1_0, OutL_1, OutMultiScatAs1_1;<br><span class="hljs-built_in">ComputeScattedLightLuminanceAndMultiScatAs1in</span>(<br>    WorldPos, WorldDir, LightDir, OneIlluminance,<br>    SkyAtmosphere_MultiScatteringSampleCount, OutL_0, OutMultiScatAs1_0);<br><span class="hljs-built_in">ComputeScattedLightLuminanceAndMultiScatAs1in</span>(<br>    WorldPos, -WorldDir, LightDir, OneIlluminance,<br>    SkyAtmosphere_MultiScatteringSampleCount, OutL_1, OutMultiScatAs1_1);<br><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> SphereSolidAngle = <span class="hljs-number">4.0f</span> * PI;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> IsotropicPhase = <span class="hljs-number">1.0f</span> / SphereSolidAngle;<br><br>float3 IntegratedIlluminance = (SphereSolidAngle / <span class="hljs-number">2.0f</span>) * (OutL_0 + OutL_1);<br>float3 MultiScatAs1 = (<span class="hljs-number">1.0f</span> / <span class="hljs-number">2.0f</span>) * (OutMultiScatAs1_0 + OutMultiScatAs1_1);<br>float3 InScatteredLuminance = IntegratedIlluminance * IsotropicPhase;<br><br><span class="hljs-comment">// For a serie, sum_&#123;n=0&#125;^&#123;n=+inf&#125; = 1 + r + r^2 + r^3 + ... + r^n = 1 / (1.0 - r)</span><br><span class="hljs-type">const</span> float3 R = MultiScatAs1;<br><span class="hljs-type">const</span> float3 SumOfAllMultiScatteringEventsContribution = <span class="hljs-number">1.0f</span> / (<span class="hljs-number">1.0f</span> - R);<br>float3 L = InScatteredLuminance * SumOfAllMultiScatteringEventsContribution;<br></code></pre></td></tr></table></figure><h1 id="Sky-View-LUT"><a href="#Sky-View-LUT" class="headerlink" title="Sky-View LUT"></a>Sky-View LUT</h1><p>With the precomputed transmittance LUT and the multi-scattering result, it’s enough to ray marhcing the sky atmosphere with a low number of samples: </p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi>b</mi></msubsup><mo stretchy="false">(</mo><msub><mi>L</mi><mn>1</mn></msub><mo>+</mo><msub><mi>σ</mi><mi>s</mi></msub><msub><mi>G</mi><mrow><mi>a</mi><mi>l</mi><mi>l</mi></mrow></msub><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">L = \int_{0}^{b}(L_{1} + \sigma_{s}G_{all})\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3998em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">ll</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span><br><br><p>We can get the multi-scattering term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mrow><mi>a</mi><mi>l</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">G_{all}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">ll</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> by looking up the LUT precomputed before.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 MultiScatteredLuminance0 = MultiScatteredLuminanceLutTexture.<span class="hljs-built_in">SampleLevel</span>(gsamLinearClamp, MultiSactterUV, <span class="hljs-number">0</span>).rgb;<br></code></pre></td></tr></table></figure><p>The remaining single scattering term is the integration along the view direction:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi>b</mi></msubsup><mo stretchy="false">(</mo><mi>V</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>σ</mi><mrow><mi>s</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>i</mi><mi>e</mi></mrow></msub><msub><mi>ϕ</mi><mrow><mi>m</mi><mi>i</mi><mi>e</mi></mrow></msub><mo>+</mo><msub><mi>σ</mi><mrow><mi>s</mi><mi mathvariant="normal">_</mi><mi>r</mi><mi>a</mi><mi>y</mi></mrow></msub><msub><mi>ϕ</mi><mrow><mi>r</mi><mi>a</mi><mi>y</mi></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>σ</mi><mi>s</mi></msub><msub><mi>G</mi><mrow><mi>a</mi><mi>l</mi><mi>l</mi></mrow></msub><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">L = \int_{0}^{b}(Vis(p,v)T(p,v)(\sigma_{s\_mie}\phi_{mie}+ \sigma_{s\_ray}\phi_{ray})+\sigma_{s}G_{all})\mathrm{d}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.411em;vertical-align:-0.367em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">Vi</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight">mi</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">mi</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.117em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">ll</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">t</span></span></span></span>, where Vis is the shadow term in this position and the transmittance term is obtained from transmittance lut.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 TransmittanceToLight0 = TransmittanceLutTexture.<span class="hljs-built_in">SampleLevel</span>(gsamLinearClamp, UV, <span class="hljs-number">0</span>).rgb;<br>float3 PhaseTimesScattering0 = Medium.ScatteringMie * MiePhaseValueLight0 + Medium.ScatteringRay * RayleighPhaseValueLight0;<br><br><span class="hljs-type">float</span> tPlanet0 = <span class="hljs-built_in">RaySphereIntersectNearest</span>(P, Light0Dir, PlanetO + PLANET_RADIUS_OFFSET * UpVector, Atmosphere_BottomRadiusKm);<br><span class="hljs-type">float</span> PlanetShadow0 = tPlanet0 &gt;= <span class="hljs-number">0.0f</span> ? <span class="hljs-number">0.0f</span> : <span class="hljs-number">1.0f</span>;<br>float3 S = Light0Illuminance * (PlanetShadow0 * TransmittanceToLight0 * PhaseTimesScattering0 + MultiScatteredLuminance0 * Medium.Scattering);<br></code></pre></td></tr></table></figure><p>Another important term is the phase function term, which indicates the relative ratio of light lost in a particular direction after a scattering event. Here is the rayleigh phase function. The <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>3</mn><mrow><mn>16</mn><mi>π</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{3}{16\pi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> coefficient serves as a normalisation factor, so that the integral over a unit sphere is 1:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mrow><mi>r</mi><mi>a</mi><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>3</mn><mrow><mn>16</mn><mi>π</mi></mrow></mfrac><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>c</mi><mi>o</mi><msup><mi>s</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi_{ray}(\theta)=\frac{3}{16\pi}(1+cos^{2}(\theta))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">))</span></span></span></span><br><br><p>We use the simpler Henyey-Greenstein phase function for mie scattering:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">HgPhase</span><span class="hljs-params">(<span class="hljs-type">float</span> G, <span class="hljs-type">float</span> CosTheta)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> Numer = <span class="hljs-number">1.0f</span> - G * G;<br>    <span class="hljs-type">float</span> Denom = <span class="hljs-number">1.0f</span> + G * G + <span class="hljs-number">2.0f</span> * G * CosTheta;<br>    <span class="hljs-keyword">return</span> Numer / (<span class="hljs-number">4.0f</span> * PI * Denom * <span class="hljs-built_in">sqrt</span>(Denom));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Latitude-Longtitude-Texture"><a href="#Latitude-Longtitude-Texture" class="headerlink" title="Latitude&#x2F;Longtitude Texture"></a>Latitude&#x2F;Longtitude Texture</h2><p>UE’s implementation renders the distant sky into a latitude&#x2F;longtitude sky-view LUT texture in a low resolution and upscales the texture on the lighting pass.In order to better represent the high-frequency visual features toward the horizon, unreal engine applies a non-linear transformation to the latitude l when computing the texture coordinate v in [0,1] that will compress more texels near the horizon:</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>=</mo><mn>0.5</mn><mo>+</mo><mn>0.5</mn><mo>∗</mo><mi>s</mi><mi>i</mi><mi>g</mi><mi>n</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo>∗</mo><msqrt><mfrac><mrow><mi mathvariant="normal">∣</mi><mi>l</mi><mi mathvariant="normal">∣</mi></mrow><mrow><mi>π</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mfrac></msqrt></mrow><annotation encoding="application/x-tex">v = 0.5 + 0.5 * sign(l) * \sqrt{\frac{|l|}{\pi/2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.61em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.23em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight">/2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.19em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.88em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.88em" viewBox="0 0 400000 1944" preserveAspectRatio="xMinYMin slice"><path d="M983 90l0 -0c4,-6.7,10,-10,18,-10 H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5zM1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.61em;"><span></span></span></span></span></span></span></span></span><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> Vhorizon = <span class="hljs-built_in">sqrt</span>(ViewHeight * ViewHeight - BottomRadius * BottomRadius);<br><span class="hljs-type">float</span> CosBeta = Vhorizon / ViewHeight;<br><span class="hljs-type">float</span> Beta = <span class="hljs-built_in">acosFast4</span>(CosBeta);<br><span class="hljs-type">float</span> ZenithHorizonAngle = PI - Beta;<br><span class="hljs-type">float</span> ViewZenithAngle = <span class="hljs-built_in">acosFast4</span>(ViewZenithCosAngle);<br><br><span class="hljs-keyword">if</span> (!IntersectGround)<br>&#123;<br>    <span class="hljs-type">float</span> Coord = ViewZenithAngle / ZenithHorizonAngle;<br>    Coord = <span class="hljs-number">1.0f</span> - Coord;<br>    Coord = <span class="hljs-built_in">sqrt</span>(Coord);<br>    Coord = <span class="hljs-number">1.0f</span> - Coord;<br>    UV.y = Coord * <span class="hljs-number">0.5f</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-type">float</span> Coord = (ViewZenithAngle - ZenithHorizonAngle) / Beta;<br>    Coord = <span class="hljs-built_in">sqrt</span>(Coord);<br>    UV.y = Coord * <span class="hljs-number">0.5f</span> + <span class="hljs-number">0.5f</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Combine-Light"><a href="#Combine-Light" class="headerlink" title="Combine Light"></a>Combine Light</h1><p>Sky-View LUT doesn’t calculate sun disk luminance, since it is high-frequency lighting, which should be computed at full resolution in the lighting pass based on the view direction and the light direction. The rest low-frequency part can be obtained by looking up the sky-view LUT directly. Below is the result of our implementation in XEngine.</p><p align="center">    <img src="/resource/skyatmosphere/image/result.png" width="80%" height="80%"></p><p><a href="https://github.com/ShawnTSH1229/XEngine"><u><strong>sky atmosphere source code</strong></u></a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Volume Rendering In Offline Rendering</title>
    <link href="/2024/05/05/Volume-Rendering-In-Offline-Rendering/"/>
    <url>/2024/05/05/Volume-Rendering-In-Offline-Rendering/</url>
    
    <content type="html"><![CDATA[<p>Note!! This is just a <span style="color:red"><strong>copy</strong></span> and <span style="color:red"><strong>translation</strong></span> of my <a href="https://blog.csdn.net/u010669231/article/details/107851266"><u><strong>Chinese Blog</strong></u></a> that I wrote during my second year of undergraduate studies in <span style="color:red"><strong>2020</strong></span>.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Virtual Shadow Map In XEngine</title>
    <link href="/2024/05/01/Virtual-Shadow-Map-In-XEngine/"/>
    <url>/2024/05/01/Virtual-Shadow-Map-In-XEngine/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Virtual Shadow Maps (VSMs) is the new shadow mapping method used in Unreal Engine 5. I implemented a <strong>simplified virtual shadow maps</strong> in my <strong>personal game engine</strong>. Here is a brief introduction from the official unreal engine 5 documentation:</p><blockquote><p>Virtual Shadow Maps have been developed with the following goals:</p><ul><li>Significantly increase shadow resolution to match highly detailed Nanite geometry</li><li>Plausible soft shadows with reasonable, controllable performance costs</li><li>Provide a simple solution that works by default with limited amounts of adjustment needed</li><li>Replace the many Stationary Light shadowing techniques with a single, unified path</li></ul><p>Conceptually, virtual shadow maps are just very <strong>high-resolution</strong> shadow maps. In their current implementation, they have a <strong>virtual resolution</strong> of 16k x 16k pixels. <strong>Clipmaps</strong> are used to increase resolution further for Directional Lights. To keep performance high at reasonable memory cost, VSMs split the &gt;shadow map into tiles (or Pages) that are 128x128 each. Pages are allocated and rendered only as needed to shade <strong>on-screen pixels</strong> based on an analysis of the depth buffer. The pages are <strong>cached</strong> between frames unless they are invalidated by moving objects or light, which further improves performance.</p></blockquote><p>According to the Unreal Engine VSMs documentation, VSMs have four key features: virtual high-resolution texture, clipmaps, only shade on-screen pixels and page cache. We have implemented the four features listed above in the simplified virtual shadow map project. Here is the low-level architecture of our simplified VSMs:</p><p align="center">    <img src="/resource/vsm_project/image/low_level_architecture.png" width="70%" height="70%"></p><p>In XEngine’s simplified virtual shadow map, each directional light has a clip map with 3 levels: clip map level 6, clip map level 7 and clip map level 8. In addition, the maximum clip map level consists of 8 x 8 tiles, with the next clip map level having twice the number of tiles as the previous clip map level. The total tile number is 1344 (32 x 32 + 16 x 16 + 8 x 8), which corresponds to 8K x 8K virtual texture size. Each tile have the same physical size with 256 x 256 pixels. The physical tile pool’s size is 2K x 2K.</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>Note: To achieve the <strong>highest possible performance</strong>, it is recommended that combining the virtual shadow map with a <strong>Nanite-like</strong> technique which divides the mesh into clusters. Otherwise, <strong>fine-grained tile splitting</strong> could result in significant increases in the draw call and the mesh face number.</p><p align="center">    <img src="/resource/vsm_project/image/renderdoc.png" width="64%" height="64%"></p><p>Simplified VSMs classify the tiles into different states based on the scene depth and the mesh bound box. It contains four tile states: shaded, not visible, cache miss and newly added tile state. VSMs performs different action for each tile with its tile state, such as update the physical tile content, allocate or remove the tile in the physical tile pool. Next, cull and build the mesh draw command for those tiles that need to be updated in the current frame. Finally, dispatch a set of indirect draw commands and compute the shadow mask using the shadow depth map rendered by indirect draw:</p><p align="center">    <img src="/resource/vsm_project/image/pass_overview.png" width="64%" height="64%"></p><h1 id="Mark-Tile-State"><a href="#Mark-Tile-State" class="headerlink" title="Mark Tile State"></a>Mark Tile State</h1><h2 id="Mark-Tiles-Used"><a href="#Mark-Tiles-Used" class="headerlink" title="Mark Tiles Used"></a>Mark Tiles Used</h2><p>Only the tiles that affect objects in the camera view are processed by VSMs. In order to achieve this goal, VSMs analyze the scene depth buffer by convert the pixels from camera projection space to shadow view space to find which tile this pixel corresponds to. Moreover, VSMs calculate the clip map level this pixel belongs to based on its distance from world space to the camera. As shown in the following image, the green blocks are marked as used tiles in VSMs, while the red blocks are not used.</p><p align="center">    <img src="/resource/vsm_project/image/vsm_tile_mark_drawio.png" width="50%" height="50%"></p><p>Simplified VSMs have 3 clip map levels. The ranges of each mip level are 2^(6 + 1) ,2^(7 + 1)  and 2^(8 + 1). The first level is 6, which means that the pixels distance to the camera ranging from 0 to 2^6 are belong to this level. Based on the mip level, shadow space UV, and mip size, we can determine which tile this pixel belongs to.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> Distance = <span class="hljs-built_in">length</span>(WorldCameraPosition - WorldPosition.xyz);<br><span class="hljs-type">float</span> Log2Distance = <span class="hljs-built_in">log2</span>(Distance + <span class="hljs-number">1</span>);<br> <br><span class="hljs-type">int</span> MipLevel = <span class="hljs-built_in">clamp</span>(Log2Distance - VSM_CLIPMAP_MIN_LEVEL, <span class="hljs-number">0</span>, VSM_MIP_NUM - <span class="hljs-number">1</span>);<br>uint2 VSMTileIndex = <span class="hljs-built_in">uint2</span>(UVOut * MipLevelSize[MipLevel]);<br><br><span class="hljs-type">int</span> DestTileInfoIndex = MipLevelOffset[MipLevel] + VSMTileIndex.y * MipLevelSize[MipLevel] + VSMTileIndex.x;<br><br>VirtualShadowMapTileState[DestTileInfoIndex] = TILE_STATE_USED;<br></code></pre></td></tr></table></figure><p>Here is a visualization of the mip level for the scene. The Mip Levels 6 &#x2F; 7 &#x2F; 8 correspond to the colors red, green, and blue, respectively. </p><p align="center">    <img src="/resource/vsm_project/image/vsm_tile_mark_visualize.png" width="80%" height="80%"></p><h2 id="Mark-Cache-Miss-Tiles"><a href="#Mark-Cache-Miss-Tiles" class="headerlink" title="Mark Cache Miss Tiles"></a>Mark Cache Miss Tiles</h2><p>VSMs only update the tiles that have changed compared to previous frame. This reduces the number of draw calls since we can reuse the previous frame data in the cached virtual shadow map texture. To find all of the tiles that changed in this frame, simplified VSMs project the bound boxes of the dynamic objects into the shadow view space. Following that, the VSM iterates and marks all tiles within these bound boxes projected range. The VSMs only mark tiles as cache misses for <strong>those tiles that were rendered in this frame</strong>. All of the mip levels covered are conservatively marked as cache miss. In the following gif image, we can see that the cache missed tile with yellow color is updated every frame:</p><p align="center">    <img src="/resource/vsm_project/gif/tile_cache_miss.gif" width="80%" height="80%"></p><h1 id="Update-Tile-Action"><a href="#Update-Tile-Action" class="headerlink" title="Update Tile Action"></a>Update Tile Action</h1><p>In the tile action update pass, VSMs compare the current tile state with the previous frame’s tile state. A ping-pong buffer is used to store the previous’s tile state buffer and tile table buffer. The tile table buffer stores the index to the physical tile texture.</p><p align="center">    <img src="/resource/vsm_project/image/update_tile_action.png" width="50%" height="50%"></p><p>Newly added tiles in this frame will allocate a new physical tile and update the shadow rendering. For cached tiles, we only update the tile shadow rendering. There is no need to allocate an extra physical tile for the cached tile. We reuse the cached tile by assign it with the index copyed from the corresponding position in the previoues tile table.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> bTileUsed = (TileState == TILE_STATE_USED);<br><span class="hljs-type">bool</span> bPreTileUsed = (PreTileState == TILE_STATE_USED);<br><span class="hljs-type">bool</span> bNewTile = (TileState == TILE_STATE_USED) &amp;&amp; (PreTileState == TILE_STATE_UNUSED);<br><span class="hljs-type">bool</span> bCacheMissTile = (CacheMissAction == TILE_STATE_CACHE_MISS) &amp;&amp; (PreTileState == TILE_STATE_USED);<br><span class="hljs-type">bool</span> bTileRemove = (TileState == TILE_STATE_UNUSED) &amp;&amp; (PreTileState == TILE_STATE_USED);<br><span class="hljs-type">bool</span> bTileActionCached = (bPreTileUsed) &amp;&amp; (bTileUsed) &amp;&amp; (!bCacheMissTile);<br><span class="hljs-type">bool</span> bTileActionNeedRemove = bTileRemove;<br><br>uint TileAction = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span>(bTileActionCached)<br>&#123;<br>    VirtualShadowMapTileTable[GlobalTileIndex] = VirtualShadowMapPreTileTable[GlobalTileIndex];<br>    TileAction = TILE_ACTION_CACHED;<br>&#125;<br><br><span class="hljs-keyword">if</span>(bCacheMissTile)<br>&#123;<br>    VirtualShadowMapTileTable[GlobalTileIndex] = VirtualShadowMapPreTileTable[GlobalTileIndex];<br>    TileAction = TILE_ACTION_NEED_UPDATE;       <br>&#125;<br><br><span class="hljs-keyword">if</span>(bNewTile)<br>&#123;<br>    TileAction = TILE_ACTION_NEED_ALLOCATE | TILE_ACTION_NEED_UPDATE;<br>&#125;<br><br><span class="hljs-keyword">if</span>(bTileActionNeedRemove)<br>&#123;<br>    TileAction = TILE_ACTION_NEED_REMOVE;<br>&#125;<br><br>VirtualShadowMapTileAction[GlobalTileIndex] = TileAction;<br></code></pre></td></tr></table></figure><h1 id="Physical-Tile-Management"><a href="#Physical-Tile-Management" class="headerlink" title="Physical Tile Management"></a>Physical Tile Management</h1><p>VSMs maintain a list of available physical tiles. An extra counter buffer records the free list header node. The physical tile manager allocates a free tile from the free tile list when the tile action equals TILE_ACTION_NEED_ALLOCATE and assigns the tile index to the corresponding position of the current frame virtual tile table when the tile action equals TILE_ACTION_NEED_ALLOCATE. The physical tile manager will obtain the released tile index from the previous frame tile table and push it to the back of the free tile list if the tile action is TILE_ACTION_NEED_REMOVE.</p><p align="center">    <img src="/resource/vsm_project/image/physical_tile_manage.png" width="80%" height="80%"></p><p>We move the counter forward or backward by InterlockedAdd instruction. The tile realse and tile allocate action are performed in separate compute pass. VSMs in UE5 maintain a LRU list in the physical tile manager. For simplicity, we release the tile buffer immediately after the tiles are marked as TILE_ACTION_NEED_REMOVE.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(VirtualShadowMapAction &amp; TILE_ACTION_NEED_ALLOCATE)<br>&#123;<br>    uint FreeListIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">InterlockedAdd</span>(VirtualShadowMapFreeListStart[<span class="hljs-number">0</span>],<span class="hljs-number">1</span>,FreeListIndex);<br>    <span class="hljs-keyword">if</span>(FreeListIndex &lt; VSM_TEX_PHYSICAL_WH * VSM_TEX_PHYSICAL_WH)<br>    &#123;<br>        VirtualShadowMapTileTable[GlobalTileIndex] = VirtualShadowMapFreeTileList[FreeListIndex];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(VirtualShadowMapAction &amp; TILE_ACTION_NEED_REMOVE)<br>&#123;<br>    <span class="hljs-type">int</span> FreeListIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">InterlockedAdd</span>(VirtualShadowMapFreeListStart[<span class="hljs-number">0</span>],<span class="hljs-number">-1</span>,FreeListIndex);<br>    <span class="hljs-keyword">if</span>(FreeListIndex &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        uint RemoveTileIndex = VirtualShadowMapPreTileTable[GlobalTileIndex];<br>        VirtualShadowMapFreeTileList[FreeListIndex - <span class="hljs-number">1</span>] = RemoveTileIndex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>When rotating the camera, we can see that the free tiles (red blocks in the top-right corner) are changed:</p><p align="center">    <img src="/resource/vsm_project/gif/physical_tile_allocation.gif" width="64%" height="64%"></p><h1 id="Cull-And-Build-The-Shadow-Draw-Command"><a href="#Cull-And-Build-The-Shadow-Draw-Command" class="headerlink" title="Cull And Build The Shadow Draw Command"></a>Cull And Build The Shadow Draw Command</h1><h2 id="Allocate-The-Shadow-Commands"><a href="#Allocate-The-Shadow-Commands" class="headerlink" title="Allocate The Shadow Commands"></a>Allocate The Shadow Commands</h2><p>VSMs build the command on the GPU and render the shadow map by indirect draw command. Here is the indirect command layout specified on the application side: constant buffer view for per-object transform information, tile info cbv, vertex buffer view, index buffer view and indirect argument desc.</p><p align="center">    <img src="/resource/vsm_project/image/indirect_cmd_layout.png" width="50%" height="50%"></p><p>After that, we allocate the command data on the application side. It contains the GPU address of the buffer, information about the vertex buffer and index buffer, as well as information about the object mesh. In the final step, initialize the scene command buffer with the data allocated above and create an empty culled command buffer with the same size as the scene command buffer. The culled command buffer is a collection of commands used in shadow map rendering after GPU culling.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;XRHICommandData&gt; RHICmdData;<br>RHICmdData.<span class="hljs-built_in">resize</span>(RenderGeos.<span class="hljs-built_in">size</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; RenderGeos.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">auto</span>&amp; it = RenderGeos[i];<br>RHICmdData[i].CBVs.<span class="hljs-built_in">push_back</span>(it-&gt;<span class="hljs-built_in">GetAndUpdatePerObjectVertexCBuffer</span>().<span class="hljs-built_in">get</span>());<br>RHICmdData[i].CBVs.<span class="hljs-built_in">push_back</span>(VirtualShadowMapResource.LightSubProjectMatrix.<span class="hljs-built_in">get</span>());<br>RHICmdData[i].CBVs.<span class="hljs-built_in">push_back</span>(VirtualShadowMapResource.LightSubProjectMatrix.<span class="hljs-built_in">get</span>());<br><br><span class="hljs-keyword">auto</span> VertexBufferPtr = it-&gt;<span class="hljs-built_in">GetRHIVertexBuffer</span>();<br><span class="hljs-keyword">auto</span> IndexBufferPtr = it-&gt;<span class="hljs-built_in">GetRHIIndexBuffer</span>();<br>RHICmdData[i].VB = VertexBufferPtr.<span class="hljs-built_in">get</span>();<br>RHICmdData[i].IB = IndexBufferPtr.<span class="hljs-built_in">get</span>();<br>RHICmdData[i].IndexCountPerInstance = it-&gt;<span class="hljs-built_in">GetIndexCount</span>();<br>RHICmdData[i].InstanceCount = <span class="hljs-number">1</span>;<br>RHICmdData[i].StartIndexLocation = <span class="hljs-number">0</span>;<br>RHICmdData[i].BaseVertexLocation = <span class="hljs-number">0</span>;<br>RHICmdData[i].StartInstanceLocation = <span class="hljs-number">0</span>;<br>&#125;<br><br>uint32 OutCmdDataSize;<br><span class="hljs-type">void</span>* DataPtrret = <span class="hljs-built_in">RHIGetCommandDataPtr</span>(RHICmdData, OutCmdDataSize);<br></code></pre></td></tr></table></figure><h2 id="Build-Indirect-Shadow-Command"><a href="#Build-Indirect-Shadow-Command" class="headerlink" title="Build Indirect Shadow Command"></a>Build Indirect Shadow Command</h2><p>For each tile, we dispatch 50 threads to process the mesh batch. Each mesh batch has 1 &#x2F; 50 mesh draw commands. Simplified VSMs cull the mesh draw command from the mesh bounding box. We project the box into the shadow view space, and push the command to the output command queue by InterLockedAdd when the mesh is not culled by the tile.</p><p align="center">    <img src="/resource/vsm_project/image/build_shadow_command.png" width="75%" height="75%"></p><h2 id="GPU-“Pointer”"><a href="#GPU-“Pointer”" class="headerlink" title="GPU “Pointer”"></a>GPU “Pointer”</h2><p>It is necessary to create a bridge between the indirect draw command and the virtual tile table in order to obtain tile information. UE5’s VSMs use InstanceID to index the virtual tile table. The solution requires recording an extra InstanceOffset variable for each mesh, since the StartInstanceLocation cannot be obtained from the vertex shader if the shading language is beyond SM 6.8. In Simplified VSMs, we use <strong>“GPU Pointer”</strong> to point the GPU address of the tile information buffer.</p><p align="center">    <img src="/resource/vsm_project/image/gpu_pointer.png" width="75%" height="75%"></p><p>For each tile, simplified VSMs generate information including a view-proj matrix, mip level, and tile indexes. We can calculate the GPU address of each tile with the tile index and the base GPU address recorded on the application side.</p><p>Another problem is that the GPU pointer is 64 bits in size, and HLSL does not support additions of 64 bits. Therefore, it is necessary to implement a custom 64 bit addition for the GPU pointer:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UINT64</span><br>&#123;<br>    uint LowAddress;<br>    uint HighAddress;<br>&#125;;<br><br><span class="hljs-function">UINT64 <span class="hljs-title">UINT64_ADD</span><span class="hljs-params">(UINT64 InValue , uint InAdd)</span></span><br><span class="hljs-function"></span>&#123;<br>    UINT64 Ret = InValue;<br>    uint C= InValue.LowAddress + InAdd;<br>    <span class="hljs-type">bool</span> OverFlow = (C &lt; InValue.HighAddress) || (C &lt; InAdd);<br>    <span class="hljs-keyword">if</span>(OverFlow)<br>    &#123;<br>        Ret.HighAddress += <span class="hljs-number">1</span>;<br>    &#125;<br>    Ret.LowAddress = C;<br>    <span class="hljs-keyword">return</span> Ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>A tile’s GPU address is simply the sum of the tile offset and the base address.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint2 TileIndexMin = <span class="hljs-built_in">uint2</span>( UVMin * MipLevelSize[MipLevel]);<br>uint2 TileIndexMax = <span class="hljs-built_in">uint2</span>( UVMax * MipLevelSize[MipLevel]);<br><br><span class="hljs-keyword">if</span>(TileIndexMin.x &lt;= MipTileIndexXY.x &amp;&amp; TileIndexMin.y &lt;= MipTileIndexXY.y &amp;&amp; TileIndexMax.x &gt;= MipTileIndexXY.x &amp;&amp; TileIndexMax.y &gt;= MipTileIndexXY.y)<br>&#123;<br>    uint PointerOffset = GlobalTileIndex * ( <span class="hljs-number">4</span> * <span class="hljs-number">4</span> * <span class="hljs-number">4</span> + <span class="hljs-number">4</span> * <span class="hljs-number">4</span>); <span class="hljs-comment">// float4x4 + uint4</span><br>    ShadowIndirectCommand InputCommand = InputCommands[Index];<br>    InputCommand.CbGlobalShadowViewProjectAddressVS = <span class="hljs-built_in">UINT64_ADD</span>(GPUStartAddress,PointerOffset);<br>    InputCommand.CbGlobalShadowViewProjectAddressPS = InputCommand.CbGlobalShadowViewProjectAddressVS;<br>    InputCommand.StartInstanceLocation = GlobalTileIndex;<br>    <br>    uint OriginalValue = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">InterlockedAdd</span>(CommandCounterBuffer[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, OriginalValue);<br>    OutputCommands[OriginalValue] = InputCommand;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Shadow-Map-Rendering"><a href="#Shadow-Map-Rendering" class="headerlink" title="Shadow Map Rendering"></a>Shadow Map Rendering</h1><p>After all pre-requirements have been met, shadow map rendering is an easy task-just clear the physical tiles that need to be updated and dispatch an indirect draw pass.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RHICmdList.<span class="hljs-built_in">RHIExecuteIndirect</span>(VirtualShadowMapResource.RHIShadowCommandSignature.<span class="hljs-built_in">get</span>(), RenderGeos.<span class="hljs-built_in">size</span>() * <span class="hljs-number">16</span>,<br>VirtualShadowMapResource.VirtualShadowMapCommnadBufferCulled.<span class="hljs-built_in">GetBuffer</span>().<span class="hljs-built_in">get</span>(), <span class="hljs-number">0</span>,<br>VirtualShadowMapResource.VirtualShadowMapCommnadCounter.<span class="hljs-built_in">GetBuffer</span>().<span class="hljs-built_in">get</span>(), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>By calculating the MIP level based on the world position and calculating the virtual table index based on the GPU pointer, we can determine destination pixel writen position.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint TableIndex = MipLevelOffset[MipLevel] + VirtualTableIndexY * MipLevelSize[MipLevel] + VirtualTableIndexX;<br>uint TileInfo = VirtualShadowMapTileTable[TableIndex];<br>uint PhysicalTileIndexX = (TileInfo &gt;&gt;  <span class="hljs-number">0</span>) &amp; <span class="hljs-number">0xFFFF</span>;<br>uint PhysicalTileIndexY = (TileInfo &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFFFF</span>;<br><br>float2 IndexXY = <span class="hljs-built_in">uint2</span>(PhysicalTileIndexX, PhysicalTileIndexY) * VSM_TILE_TEX_PHYSICAL_SIZE;<br>float2 WritePos = IndexXY + PositionIn.xy;<br><span class="hljs-type">float</span> FixedPointDepth = <span class="hljs-built_in">float</span>(PositionIn.z) * <span class="hljs-built_in">uint</span>(<span class="hljs-number">0xFFFFFFFF</span>);<br>uint UintDepth = FixedPointDepth;<br><br><span class="hljs-built_in">InterlockedMax</span>(PhysicalShadowDepthTexture[<span class="hljs-built_in">uint2</span>(WritePos)],UintDepth);<br></code></pre></td></tr></table></figure><p>Here is the visualization of the physical shadow depth texture:</p><p align="center">    <img src="/resource/vsm_project/image/sub_tile.png" width="64%" height="64%"></p><p align="center">    <img src="/resource/vsm_project/image/physical_tile_visualize.png" width="64%" height="64%"></p><h1 id="Generate-The-Shadow-Mask-Texture"><a href="#Generate-The-Shadow-Mask-Texture" class="headerlink" title="Generate The Shadow Mask Texture"></a>Generate The Shadow Mask Texture</h1><p>By calculating the virtual table index from the pixel position, calculating the physical shadow depth position from the table index, and comparing the result to the pixel’s shadow space depth, we can finally determine whether this pixel is shadowed.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> Total = <span class="hljs-number">0.0f</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>    Total += <span class="hljs-built_in">ComputeShadowFactor</span>(UVShadowSpace + UVOffset[i] * MipLevelVirtualTextureSize[MipLevel], ObjectShadowDepth,Bias, MipLevel);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">ComputeShadowFactor</span><span class="hljs-params">(float2 UVShadowSpace ,uint ObjectShadowDepth, uint Bias, uint MipLevel)</span></span><br><span class="hljs-function"></span>&#123;<br>    uint2 VSMTileIndex = <span class="hljs-built_in">uint2</span>(UVShadowSpace * MipLevelSize[MipLevel]);<br>    <span class="hljs-type">int</span> TableIndex = MipLevelOffset[MipLevel] + VSMTileIndex.y * MipLevelSize[MipLevel] + VSMTileIndex.x;<br>    uint TileInfo = VirtualShadowMapTileTable[TableIndex];<br>    uint PhysicalTileIndexX = (TileInfo &gt;&gt;  <span class="hljs-number">0</span>) &amp; <span class="hljs-number">0xFFFF</span>;<br>    uint PhysicalTileIndexY = (TileInfo &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFFFF</span>;<br><br>    float2 IndexXY = <span class="hljs-built_in">uint2</span>(PhysicalTileIndexX, PhysicalTileIndexY) * VSM_TILE_TEX_PHYSICAL_SIZE;<br>    float2 SubTileIndex = (<span class="hljs-built_in">float2</span>(UVShadowSpace * MipLevelSize[MipLevel]) - VSMTileIndex) * VSM_TILE_TEX_PHYSICAL_SIZE;<br>    float2 ReadPos = IndexXY + SubTileIndex;<br><br>    uint ShadowDepth = PhysicalShadowDepthTexture[<span class="hljs-built_in">uint2</span>(ReadPos)].x;<br><br>    <span class="hljs-keyword">if</span>((ObjectShadowDepth + Bias ) &lt; ShadowDepth) <br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1.0f</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p align="center">    <img src="/resource/vsm_project/image/scene_depth.png" width="64%" height="64%"></p><p align="center">    <img src="/resource/vsm_project/image/shadow_mask.png" width="64%" height="64%"></p><p align="center">    <img src="/resource/vsm_project/gif/final_result_visualize.gif" width="64%" height="64%"></p><p><a href="https://github.com/ShawnTSH1229/XEngine"><u><strong>source code can be found here.</strong></u></a></p>]]></content>
    
    
    <categories>
      
      <category>My Projects</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>

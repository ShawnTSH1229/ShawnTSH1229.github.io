

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Shawn Tang">
  <meta name="keywords" content="">
  
    <meta name="description" content="IntroductionThis is a simplified Unreal Lumen GI implementation (SimLumen) based on Unreal’s Lumen GI. We have implemented most of Unreal Lumen’s features. To perform fast ray tracing, SimLumen builds">
<meta property="og:type" content="article">
<meta property="og:title" content="Simplified Lumen GI In MiniEngine">
<meta property="og:url" content="http://example.com/2024/05/18/Simplified-Lumen-GI-In-MiniEngine/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="IntroductionThis is a simplified Unreal Lumen GI implementation (SimLumen) based on Unreal’s Lumen GI. We have implemented most of Unreal Lumen’s features. To perform fast ray tracing, SimLumen builds">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/resource/simlumen/image/oct_result.png">
<meta property="article:published_time" content="2024-05-18T05:47:44.000Z">
<meta property="article:modified_time" content="2024-06-17T15:21:24.302Z">
<meta property="article:author" content="Shawn Tang">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/resource/simlumen/image/oct_result.png">
  
  
  
  <title>Simplified Lumen GI In MiniEngine - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":10},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ShawnTSH1229</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Simplified Lumen GI In MiniEngine"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-18 13:47" pubdate>
          May 18, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          2.4k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          21 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Simplified Lumen GI In MiniEngine</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This is a simplified Unreal Lumen GI implementation (<strong>SimLumen</strong>) based on <strong>Unreal’s Lumen GI</strong>. We have implemented <strong>most</strong> of Unreal Lumen’s features.</p>
<p>To perform fast ray tracing, SimLumen builds the <strong>mesh SDFs</strong> offline using the <strong>embree</strong> library. We also precompute a <strong>global low resolution SDF</strong> of the whole scene, which is used in surface cache ray tracing and screen probe voxel ray tracing.</p>
<p>SimLumen builds <strong>mesh cards</strong> offline in order to capture <strong>material attributes</strong> (normal, albedo) at run time. Mesh cards store the capture direction as well as the camera capture frustum. Since our meshes in the test example are simple and most are boxes, we generate only 6 cards for each mesh. Each direction corresponds a mesh card. At run time, SimLumen captures the mesh attributes, and copies them into a <strong>global surface cache material attributes atlas</strong>.</p>
<p>The surface cache describes the <strong>lighting of the scene</strong>. It contains 5 parts: <strong>surface cache material attributes</strong>, <strong>surface cache direct lighting</strong>, <strong>surface cache indirect lighting</strong>, <strong>surface cache combined final lighting</strong> and <strong>voxelized scene lighting</strong>.</p>
<p>With the global surface cache material attributes (normal, albedo and depth), SimLumen computes the direct lighting for each pixel in the surface cache atlas.</p>
<p>What’s more, we have implemented <strong>infinity</strong> bounce lighting similar to Unreal Lumen. At first, we <strong>voxelize</strong> the scene. Each voxel has 6 directions. For each direction, we perform a mesh SDF trace and store the <strong>hit mesh index and hit distance</strong> in the <strong>voxel visibility buffer</strong>. Then, we <strong>inject</strong> the surface cache final lighting into the voxel if the voxel hit a mesh.</p>
<p>With the voxelized lighting, we compute the <strong>surface cache indirect lighting</strong> in the surface cache Atlas space. Firstly, SimLumen places probes every <strong>4x4 pixels</strong> in the Atlas space. In the next step, we trace the ray to the voxelized scene via global SDF and sample the radiance within the voxel. In order to denoise the trace result, SimLumen <strong>filters</strong> the radiance atlas and converts them into <strong>spherical harmonics</strong>. By integrating the probes around the pixel, we obtained surface cache indirect lighting.</p>
<p>The surface cache final lighting is computed by <strong>combining surface direct and indirect lighting</strong>.</p>
<p>As we have SDF to trace the scene quickly as well as surface cache that describes the scene lighting, we are able to proform the <strong>screen space probe trace</strong>.</p>
<p>SimLumen uses <strong>importance sampling</strong> to reduce the trace noisy. The PDF of the sampling function contains two parts: <strong>BRDF PDF</strong> and <strong>lighting PDF</strong>. The BRDF PDF is stored in <strong>spherical harmonic</strong> form, and we project the pixel BRDF PDF around the probe into spherical harmonics if the PDF is <strong>not rejected</strong> by the plane depth weight.  We use the <strong>previous frame’s</strong> screen radiance result to estimate the lighting PDF by <strong>reprojecting</strong> the probe into the previous screen space, since we do not have information about the lighting source in the current frame. To improve performance, SimLumen employs <strong>structured importance sampling</strong> by reassigning the unimportant samples to those with a higher PDF.</p>
<p>Each probe traces 64 rays to the scene. SimLumen implements a <strong>hybrid GI</strong> similar to Unreal Lumen. The probes whose distance from the camera is less than 100 meters trace the scene by <strong>mesh SDF</strong> and sample the radiance from the <strong>surface cache atlas</strong>. Other probes use <strong>Global SDF</strong> to trace the scene and sample the radiance from the <strong>voxel lighting</strong>.</p>
<p>After that, we perform two additional passes to denoise the results. In the first pass, we <strong>filter</strong> the radiance with a uniform weight. Then, in the second pass, we convert the radiance into <strong>spherical harmonics</strong> and transform the SH into boardered <strong>octchedron form</strong>. This is usefull in hardware <strong>bilinear sampling</strong> in the following pass.</p>
<p>We finally obtained the final indirect lighting by integrating the probes around the current screen pixel and sampling the <strong>octchedron form SH</strong> by a linear sampler.</p>
<h1 id="Fast-Ray-Tracing"><a href="#Fast-Ray-Tracing" class="headerlink" title="Fast Ray Tracing"></a>Fast Ray Tracing</h1><p>SimLumen uses signed distance fields to trace the ray with the mesh. SDF is a uniform mesh representation. What’s more, it is differentiable, which means we can calculate the normal at the ray hit position. SimLumen precomputes the mesh SDF and the scene global SDF. GI nearby camera employs mesh SDF to accelerate ray-mesh intersection. Global SDF is used in distant GI and surface cache indirect lighting calculation.</p>
<h2 id="Build-Mesh-SDF-Offline"><a href="#Build-Mesh-SDF-Offline" class="headerlink" title="Build Mesh SDF Offline"></a>Build Mesh SDF Offline</h2><p>The mesh SDF volume has different size based on the mesh bounding box. To pack these mesh SDF into a single 3D texture, we split the volume into bricks. Brick size is the same for mesh SDFs.</p>
<p align="center">
    <img src="/resource/simlumen/image/build_mesh_sdf.drawio.png" srcset="/img/loading.gif" lazyload width="60%" height="60%">
</p>

<p>SimLumen use Embree to calculate the mesh SDF, which is the same as Unreal does. For each voxel, we traces 512 ray samples to intersect with the mesh and finds the closest hit position between these samples. A voxel is considered within the mesh if more than 25% of the 512 ray samples hit the triangle backface. We take the negative value of the closest hit distance.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (hit_num &gt; <span class="hljs-number">0</span> &amp;&amp; hit_back_num &gt; <span class="hljs-number">0.25f</span> * samples0.<span class="hljs-built_in">size</span>())<br>&#123;<br>	min_distance *= <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Then, scale and quantify the closest distance to uint8 format, and store the result into brick sdf data.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> scaled_min_distance = min_distance / max_distance;<span class="hljs-comment">// -1-&gt;1</span><br><span class="hljs-type">float</span> clamed_min_distance = Math::<span class="hljs-built_in">Clamp</span>(scaled_min_distance * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//0 - 1</span><br><span class="hljs-type">uint8_t</span> normalized_min_distance = <span class="hljs-built_in">uint8_t</span>(<span class="hljs-built_in">int32_t</span>(clamed_min_distance * <span class="hljs-number">255.0f</span> + <span class="hljs-number">0.5</span>));<br><br><span class="hljs-type">int</span> brick_index = brick_index_z * volume_brick_num_y * volume_brick_num_x + brick_index_y * volume_brick_num_x + brick_index_x;<br>volumeData.distance_filed_volume[brick_index].m_brick_data[brick_vol_idx_x][brick_vol_idx_y][brick_vol_idx_z] = normalized_min_distance;<br></code></pre></td></tr></table></figure>

<h2 id="Trace-Mesh-SDF"><a href="#Trace-Mesh-SDF" class="headerlink" title="Trace Mesh SDF"></a>Trace Mesh SDF</h2><p>At runtime, we copy and upload each mesh’s brick texture to the global mesh SDF brick texture and record the brick texture offset. We can find any SDF value at a given position in the mesh volume for each mesh by global brick texture and brick offset.</p>
<p align="center">
    <img src="/resource/simlumen/image/build_scene_mesh_sdf.png" srcset="/img/loading.gif" lazyload width="80%" height="80%">
</p>

<p>The GI nearby camera uses mesh SDF to trace rays. In this case, we calculate the possible meshes that can be intersected in the ray tracing direction. Then, we perform SDF tracing for each mesh and find the closest hit position.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[loop]<br><span class="hljs-keyword">for</span>(uint mesh_idx = <span class="hljs-number">0</span>; mesh_idx &lt; scene_mesh_sdf_num; mesh_idx++)<br>&#123;<br>    <span class="hljs-built_in">RayTraceSingleMeshSDF</span>(world_position, ray_direction, <span class="hljs-number">1000</span>, mesh_idx, trace_result);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>At first, SimNanite transform the ray from the world position into sdf volume position. If the ray intersects the volume bound box, we trace the ray from the intersection position. When the sphere trace step is over 64 or the closest distance in the sample position is closer than on voxel size, it means that we hit the mesh surface and should stop the sphere trace.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float2 volume_space_intersection_times = <span class="hljs-built_in">LineBoxIntersect</span>(volume_ray_start, volume_ray_end, volume_min_pos, volume_max_pos);<br><br>......<br>volume_space_intersection_times *= volume_max_trace_distance;<br><br><span class="hljs-keyword">if</span>((volume_space_intersection_times.x &lt; volume_space_intersection_times.y) &amp;&amp; (volume_space_intersection_times.x &lt; trace_result.hit_distance))<br>&#123;<br>    <span class="hljs-type">float</span> <span class="hljs-type">sample_ray_t</span> = volume_space_intersection_times.x;<br><br>    uint max_step = <span class="hljs-number">64</span>;<br>    <span class="hljs-type">bool</span> bhit = <span class="hljs-literal">false</span>;<br>    uint step_idx = <span class="hljs-number">0</span>;<br><br>    [loop]<br>    <span class="hljs-keyword">for</span>( ; step_idx &lt; max_step; step_idx++)<br>    &#123;<br>        float3 sample_volume_position = volume_ray_start + volume_ray_direction * <span class="hljs-type">sample_ray_t</span>;<br>        <span class="hljs-type">float</span> distance_filed = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(sample_volume_position, mesh_sdf_info);<br>        <span class="hljs-type">float</span> min_hit_distance = mesh_sdf_info.volume_brick_size * <span class="hljs-number">0.125</span> * <span class="hljs-number">1.0</span>; <span class="hljs-comment">// 1 voxel</span><br><br>        <span class="hljs-keyword">if</span>(distance_filed &lt; min_hit_distance)<br>        &#123;<br>            bhit = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">sample_ray_t</span> = <span class="hljs-built_in">clamp</span>(<span class="hljs-type">sample_ray_t</span> + distance_filed - min_hit_distance, volume_space_intersection_times.x, volume_space_intersection_times.y);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-type">sample_ray_t</span> += distance_filed;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-type">sample_ray_t</span> &gt; volume_space_intersection_times.y + min_hit_distance)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(step_idx == max_step)<br>    &#123;<br>        bhit = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(bhit &amp;&amp; <span class="hljs-type">sample_ray_t</span> &lt; trace_result.hit_distance)<br>    &#123;<br>        trace_result.is_hit = <span class="hljs-literal">true</span>;   <br>        trace_result.hit_distance = <span class="hljs-type">sample_ray_t</span>;<br>        trace_result.hit_mesh_index = object_index;<br>        trace_result.hit_mesh_sdf_card_index = mesh_sdf_info.mesh_card_start_index;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="SDF-Normal"><a href="#SDF-Normal" class="headerlink" title="SDF Normal"></a>SDF Normal</h2><p>We can calculate the normal at any sample position by calculating the closest distance gradient of the voxels around it.</p>
<p align="center">
    <img src="/resource/simlumen/image/sdf_normal.png" srcset="/img/loading.gif" lazyload width="70%" height="70%">
</p>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">float3 <span class="hljs-title">CalculateMeshSDFGradient</span><span class="hljs-params">(float3 sample_volume_position, SMeshSDFInfo mesh_sdf_info)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> voxel_offset = mesh_sdf_info.volume_brick_size * <span class="hljs-number">0.125</span>;<br><br>    <span class="hljs-type">float</span> R = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x + voxel_offset, sample_volume_position.y, sample_volume_position.z),mesh_sdf_info);<br>    <span class="hljs-type">float</span> L = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x - voxel_offset, sample_volume_position.y, sample_volume_position.z),mesh_sdf_info);<br><br>    <span class="hljs-type">float</span> F = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x, sample_volume_position.y + voxel_offset, sample_volume_position.z),mesh_sdf_info);<br>    <span class="hljs-type">float</span> B = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x, sample_volume_position.y - voxel_offset, sample_volume_position.z),mesh_sdf_info);<br><br>    <span class="hljs-type">float</span> U = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x, sample_volume_position.y, sample_volume_position.z + voxel_offset),mesh_sdf_info);<br>    <span class="hljs-type">float</span> D = <span class="hljs-built_in">SampleDistanceFieldBrickTexture</span>(<span class="hljs-built_in">float3</span>(sample_volume_position.x, sample_volume_position.y, sample_volume_position.z - voxel_offset),mesh_sdf_info);<br><br>    float3 gradiance = <span class="hljs-built_in">float3</span>(R - L, F - B, U - D);<br>	<span class="hljs-keyword">return</span> gradiance;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Below is a SDF ray-tracing visualization.  In this example, the ray-tracing direction for each cube is determined by its offset from the center cube. RGB colors represent the hit position’s normal. X is represented by red color, Y by green color, and Z by blue color.</p>
<p align="center">
    <img src="/resource/simlumen/image/sdf_normal_visualize.png" srcset="/img/loading.gif" lazyload width="80%" height="80%">
</p>


<h2 id="Global-SDF"><a href="#Global-SDF" class="headerlink" title="Global SDF"></a>Global SDF</h2><p>The global signed distance field is a low resolution SDF of the whole scene. We precompute the global SDF offline. Global SDF differs from scene mesh SDF in that the scene mesh SDF is stored in brick textures with fixed z-dimensions, whereas global SDF is stored in a size-scalable volume texture based on the scene bounding box.</p>
<h1 id="Surface-Cache"><a href="#Surface-Cache" class="headerlink" title="Surface Cache"></a>Surface Cache</h1><p>The mesh SDF trace allows us to determine the hit position of a ray, however it does not provide information regarding the material attributes (albedo, normal, etc.) at the hit position. Unreal Lumen uses mesh cards to capture these material attributs runtime. </p>
<p>Mesh cars describe the material attributes capture infomation. It can be generated offline. However, material attributes capture must be performed at runtime, since occlusion between scene meshes can’t be determined offline.</p>
<h2 id="SimLumen-Card-Generation"><a href="#SimLumen-Card-Generation" class="headerlink" title="SimLumen Card Generation"></a>SimLumen Card Generation</h2><p><strong>In Unreal, a mesh may have many mesh cards depend on mesh complexity.</strong> SimLumen simplifies mesh card generation: generates a fixed number mesh card (6 direction) based on the mesh bounding box.  </p>
<p align="center">
    <img src="/resource/simlumen/image/mesh_card.png" srcset="/img/loading.gif" lazyload width="40%" height="40%">
</p>

<p>We calculate the capture position and direction from the bounding box directly. The mesh card depth is determined by software raytracing. For each texel in the mesh card, we trace a ray in the mesh card direction, calculate the ray-mesh intersection and find the furthest intersection distance.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> max_depth = <span class="hljs-number">2.0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x_idx = <span class="hljs-number">0</span>; x_idx &lt; <span class="hljs-number">128</span>; x_idx++)<br>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y_idx = <span class="hljs-number">0</span>; y_idx &lt; <span class="hljs-number">128</span>; y_idx++)<br>	&#123;<br>		XMFLOAT3 trace_position = palne_start_trace_pos;<br>		<span class="hljs-built_in">AddFloatComponent</span>(trace_position, dimension_x, (x_idx + <span class="hljs-number">0.5</span>) * x_stride);<br>		<span class="hljs-built_in">AddFloatComponent</span>(trace_position, dimension_y, (y_idx + <span class="hljs-number">0.5</span>) * y_stride);<br><br>		RTCRayHit embree_ray;<br>		......<br>		<span class="hljs-built_in">rtcIntersect1</span>(m_rt_scene, &amp;embree_ray, &amp;args);<br><br>		<span class="hljs-keyword">if</span> ((embree_ray.ray.tfar != <span class="hljs-number">1e30</span>f) &amp;&amp; embree_ray.hit.geomID != RTC_INVALID_GEOMETRY_ID &amp;&amp; embree_ray.hit.primID != RTC_INVALID_GEOMETRY_ID)<br>		&#123;<br>			<span class="hljs-function">Math::Vector3 <span class="hljs-title">hit_normal</span><span class="hljs-params">(embree_ray.hit.Ng_x, embree_ray.hit.Ng_y, embree_ray.hit.Ng_z)</span></span>;<br>			hit_normal = Math::<span class="hljs-built_in">Normalize</span>(hit_normal);<br>			<span class="hljs-type">float</span> dot_value = Math::<span class="hljs-built_in">Dot</span>(trace_dir, hit_normal);<br><br>			<span class="hljs-keyword">if</span> (dot_value &lt; <span class="hljs-number">0</span> &amp;&amp; max_depth &lt; embree_ray.ray.tfar)<br>			&#123;<br>				max_depth = embree_ray.ray.tfar;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br>XMFLOAT3 points[<span class="hljs-number">4</span>];<br>points[<span class="hljs-number">0</span>] = palne_start_trace_pos;<br>points[<span class="hljs-number">1</span>] = plane_end_trace_pos;<br><br>points[<span class="hljs-number">2</span>] = palne_start_trace_pos;<br>points[<span class="hljs-number">2</span>].x += trace_dir.x * max_depth;<br>points[<span class="hljs-number">2</span>].y += trace_dir.y * max_depth;<br>points[<span class="hljs-number">2</span>].z += trace_dir.z * max_depth;<br><br>points[<span class="hljs-number">3</span>] = plane_end_trace_pos;<br>points[<span class="hljs-number">3</span>].x += trace_dir.x * max_depth;<br>points[<span class="hljs-number">3</span>].y += trace_dir.y * max_depth;<br>points[<span class="hljs-number">3</span>].z += trace_dir.z * max_depth;<br><br>Math::BoundingBox RetBound;<br>Math::BoundingBox::<span class="hljs-built_in">CreateFromPoints</span>(RetBound, <span class="hljs-number">4</span>, points, <span class="hljs-built_in">sizeof</span>(XMFLOAT3));<br><span class="hljs-keyword">return</span> RetBound;<br></code></pre></td></tr></table></figure>

<h2 id="Material-Attributes-Capture"><a href="#Material-Attributes-Capture" class="headerlink" title="Material Attributes Capture"></a>Material Attributes Capture</h2><p>SimLumen captures the mesh card at runtime. After the mesh card capture is completed, we copy these mesh card attribute textures into a global card atlas.</p>
<p align="center">
    <img src="/resource/simlumen/image/mat_attributes_alebedo.png" srcset="/img/loading.gif" lazyload width="35%" height="35%">
</p>
<p align="center">
    <img src="/resource/simlumen/image/mat_attributes_normal.png" srcset="/img/loading.gif" lazyload width="35%" height="35%">
</p>

<p>Below is a visualization of the mesh card’s normal and albedo for a scene:</p>
<p align="center">
    <img src="/resource/simlumen/image/scene_attributes_alebedo.png" srcset="/img/loading.gif" lazyload width="50%" height="50%">
</p>
<p align="center">
    <img src="/resource/simlumen/image/scene_attributes_normal.png" srcset="/img/loading.gif" lazyload width="50%" height="50%">
</p>

<h2 id="Surface-Cache-Lighting"><a href="#Surface-Cache-Lighting" class="headerlink" title="Surface Cache Lighting"></a>Surface Cache Lighting</h2><p>Unreal Lumen has implemented an <strong>infinity bounce</strong> lighting by the combination of the surface cache lighting and voxel lighting. Here is the surface cache flow graph:</p>
<p>Step 1: Calculate direct lighting with surface cache attributes (albedo &#x2F; normal).</p>
<p>Step 2: Combine direct lighting and indirect lighting together. In the first frame, direct lighting results in black, since no light has been injected into the scene voxel.</p>
<p>Step 3: Inject the combined light into the scene voxel.</p>
<p>Step 4: Calculate indirect lighting used in the next frame.</p>
<p align="center">
    <img src="/resource/simlumen/image/surface_cache_lighting_flow.png" srcset="/img/loading.gif" lazyload width="75%" height="75%">
</p>

<h2 id="Surface-Cache-Direct-Lighting"><a href="#Surface-Cache-Direct-Lighting" class="headerlink" title="Surface Cache Direct Lighting"></a>Surface Cache Direct Lighting</h2><p>The world position of a mesh card pixel is calculated by the card rotation matrix and card depth. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 local_position;<br>local_position.xy = (card_uv * (<span class="hljs-number">2.0f</span>) - <span class="hljs-number">1.0f</span>) * card_info.rotated_extents.xy;<br>local_position.z = -(depth * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0f</span>)  * card_info.rotated_extents.z;<br>float3 rotate_back_pos = <span class="hljs-built_in">mul</span>((float3x3)card_info.rotate_back_matrix, local_position);<br>rotate_back_pos += card_info.bound_center;;<br></code></pre></td></tr></table></figure>

<p>After that, SimLumen transforms the world position into shadow space in order to determine whether the pixel is inside or outside the shadow.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> shadow = <span class="hljs-number">0.0</span>;<br>&#123;<br>    float4 shadow_screen_pos = <span class="hljs-built_in">mul</span>(ShadowViewProjMatrix, <span class="hljs-built_in">float4</span>(card_data.world_position,<span class="hljs-number">1.0</span>));<br>    float2 shadow_uv = shadow_screen_pos.xy;<br>    shadow_uv = shadow_uv * <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">-0.5</span>) + <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);<br>    float2 shadow_pixel_pos = shadow_uv.xy * <span class="hljs-number">2048</span>;<br><br>    <span class="hljs-type">float</span> shadow_depth_value = shadow_depth_buffer.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(shadow_pixel_pos.xy,<span class="hljs-number">0</span>)).x;;<br>    shadow = ((shadow_screen_pos.z + <span class="hljs-number">0.0005</span>) &lt; shadow_depth_value ) ? <span class="hljs-number">0.0</span> :<span class="hljs-number">1.0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>We calculate the direct lighting for each light source and accumulate them if the scene has many light sources.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 directional_lighting = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#123;<br>    float3 light_direction = SunDirection;<br>    <span class="hljs-type">float</span> NoL = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(light_direction, card_data.world_normal));<br>    directional_lighting = SunIntensity * NoL * card_data.albedo * shadow;<br>&#125;<br><br>float3 point_lighting = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#123;<br>    float3 point_light_direction = point_light_world_pos - card_data.world_position;<br>    float3 light_dist = <span class="hljs-built_in">length</span>(point_light_direction);<br>    <span class="hljs-type">float</span> attenuation = <span class="hljs-built_in">saturate</span>((point_light_radius - light_dist) / point_light_radius);   <br>    <span class="hljs-type">float</span> NoL = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(<span class="hljs-built_in">normalize</span>(point_light_direction), card_data.world_normal));<br>    point_lighting = NoL * card_data.albedo * attenuation * attenuation;<br>&#125;<br>surface_cache_direct_lighting[<span class="hljs-built_in">int2</span>(pixel_pos.xy)] = <span class="hljs-built_in">float4</span>(point_lighting + directional_lighting, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure>

<p>surface cache direct lighting visualization:</p>
<p align="center">
    <img src="/resource/simlumen/image/scache_direct_lighting.png" srcset="/img/loading.gif" lazyload width="64%" height="64%">
</p>

<h2 id="Voxel-Visibility-Buffer"><a href="#Voxel-Visibility-Buffer" class="headerlink" title="Voxel Visibility Buffer"></a>Voxel Visibility Buffer</h2><p>Voxel visibility buffer stores the hit mesh index and hit distance in x&#x2F;y&#x2F;z direction. As a persistent data, it is only updated when the meshes’ positions change. SDF traces are performed for each voxel along the xyz direction for meshes that are possibly intersected with its center. If the ray from the voxel center along the x&#x2F;y&#x2F;z direction hit a mesh, we store the mesh index in the voxel. This will be used in the next light injection pass.</p>
<p align="center">
    <img src="/resource/simlumen/image/voxel_vis_info.png" srcset="/img/loading.gif" lazyload width="60%" height="60%">
</p>

<h2 id="Lighting-Injection"><a href="#Lighting-Injection" class="headerlink" title="Lighting Injection"></a>Lighting Injection</h2><p>We can obtain the intersection mesh and intersection position directly from the voxel visibility buffer. After that, we transform the hit world position into mesh card space location and calculate the final light atlas UV. The final light is the combination of the direct light and indirect light. However, the indirect lighting remains black until the second frame as it is dependent on voxel illumination.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint direction_idx = group_idx.y;<br>SVoxelVisibilityInfo voxel_vis_info = scene_voxel_visibility_buffer[voxel_index_1d];<br><span class="hljs-type">int</span> mesh_index = voxel_vis_info.voxel_vis_info[direction_idx].mesh_index;<br><span class="hljs-keyword">if</span>(mesh_index != <span class="hljs-number">-1</span>)<br>&#123;<br>    SMeshSDFInfo mesh_info = scene_sdf_infos[mesh_index];<br>    uint card_index = direction_idx; <br>    uint global_card_index = mesh_info.mesh_card_start_index + card_index;<br><br>    SCardInfo card_info = scene_card_infos[global_card_index];<br><br>    <span class="hljs-type">float</span> hit_distance = voxel_vis_info.voxel_vis_info[direction_idx].hit_distance;<br>    float3 light_direction = voxel_light_direction[direction_idx];<br>    float3 hit_world_pos = voxel_world_pos + light_direction * hit_distance;<br><br>    float2 uv = <span class="hljs-built_in">GetCardUVFromWorldPos</span>(card_info, hit_world_pos);<br><br>    uint2 card_index_xy = <span class="hljs-built_in">uint2</span>((global_card_index % card_num_xy), (global_card_index / card_num_xy));<br>    uint2 pixel_pos = card_index_xy * <span class="hljs-number">128</span> + <span class="hljs-built_in">float2</span>(uv * <span class="hljs-number">128</span>);<br>    pixel_pos.y = SURFACE_CACHE_TEX_SIZE - pixel_pos.y;<br>    float3 final_lighting = final_lighting_tex.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(pixel_pos,<span class="hljs-number">0</span>)).xyz;<br><br>    scene_voxel_lighting[voxel_index_1d].final_lighting[direction_idx] = final_lighting;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>voxel lighting visualization:</p>
<p align="center">
    <img src="/resource/simlumen/image/voxel_lighting_visualize.png" srcset="/img/loading.gif" lazyload width="60%" height="60%">
</p>

<h2 id="Surface-Cache-Indirect-Lighting"><a href="#Surface-Cache-Indirect-Lighting" class="headerlink" title="Surface Cache Indirect Lighting"></a>Surface Cache Indirect Lighting</h2><p>The first step is to calculate the radiance of the current surface cache pixel using global SDF, filter, and store the radiance in a radiance atlas. We then convert radiance into SH, which allows us to perform probe interpolation to reduce lighting noise.<br>The irradiance in a unit area is the integral of the f(x) over the half sphere:</p>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><mi>L</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>⋅</mo><mi>i</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">E(p) = \int_{\Omega}L(p,i)max(0,n\cdot i )\mathrm{d}i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">i</span></span></span></span><br>
<p>F(x) can be split into two parts: the lighting function and the diffuse transfer function:</p>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>H</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">E(p) = \int_{\Omega}L(i)\cdot H(i)\mathrm{d}i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">i</span></span></span></span><br>
<p>L(i) is reconstructed from the spherical harmonic by SH factors and biasis function:</p>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>≈</mo><mi mathvariant="normal">Σ</mi><msub><mi>l</mi><mi>k</mi></msub><msub><mi>B</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(i) \approx \Sigma l_{k}B_{k}(i) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span><br>
<p>We project the radiance into the basis function to get the SH factors in Convert SH pass:</p>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mi>k</mi></msub><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mi>B</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mi mathvariant="normal">d</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">l_{k} = \int_{\Omega}L(i)B(i)\mathrm{d}i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1225em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathrm">d</span><span class="mord mathnormal">i</span></span></span></span><br>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(<span class="hljs-built_in">SHBasisFunction</span>(world_ray), trace_irradiance / pdf));<br></code></pre></td></tr></table></figure>

<p>If we project both the illumination and transfer functions into SH coefficients then orthogonality guarantees that the integral of the function’s products is the same as the dot product of their coefficients:</p>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><msup><mi>n</mi><mn>2</mn></msup></msubsup><msub><mi>l</mi><mi>k</mi></msub><msub><mi>h</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">E(p) = \Sigma_{k=0}^{n^{2}} l_{k}h_{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.27em;vertical-align:-0.2831em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9869em;"><span style="top:-2.4169em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>⋅</mo><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(i) = max(0,n\cdot l) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span><br>
<p>The irradiance of a pixel is calculated in the integrate pass:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FTwoBandSHVector diffuse_transfer_sh = <span class="hljs-built_in">CalcDiffuseTransferSH</span>(card_data.world_normal, <span class="hljs-number">1.0f</span>);<br>float3 texel_irradiance = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">float3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>), <span class="hljs-built_in">DotSH</span>(irradiance_sh, diffuse_transfer_sh));<br></code></pre></td></tr></table></figure>


<p align="center">
    <img src="/resource/simlumen/image/scache_indirect_lighting.png" srcset="/img/loading.gif" lazyload width="40%" height="40%">
</p>

<h3 id="Radiosity-Trace"><a href="#Radiosity-Trace" class="headerlink" title="Radiosity Trace"></a>Radiosity Trace</h3><p>SimLumen split the atlas space surface cache into 8x8 tiles. Each tile place 2x2 probes. </p>
<p align="center">
    <img src="/resource/simlumen/image/scache_radiosity_trace_probe.png" srcset="/img/loading.gif" lazyload width="30%" height="30%">
</p>

<p>Each probe performs 16 ray tracings in the hemisphere direction.</p>
<p align="center">
    <img src="/resource/simlumen/image/radiosity_probe_ray.png" srcset="/img/loading.gif" lazyload width="30%" height="30%">
</p>

<p>To accelerate the speed of convergence of the integrate, the probe center is jittered according to the tile index and the frame index.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint2 probe_jitter = <span class="hljs-built_in">GetProbeJitter</span>(indirect_lighting_temporal_index);<br></code></pre></td></tr></table></figure>

<p>For each direction, we trace a ray from the probe center and find the world space hit position by global SDF.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 world_ray;<br><span class="hljs-type">float</span> pdf;<br><span class="hljs-built_in">GetRadiosityRay</span>(tile_idx, sub_tile_pos, card_data.world_normal, world_ray, pdf);<br><br>SGloablSDFHitResult hit_result = (SGloablSDFHitResult)<span class="hljs-number">0</span>;<br><span class="hljs-built_in">TraceGlobalSDF</span>(card_data.world_position + card_data.world_normal * gloabl_sdf_voxel_size * <span class="hljs-number">2.0</span>, world_ray, hit_result);<br></code></pre></td></tr></table></figure>
<p>Finally, fetch the voxel lighting at the hit position and accumulate the weighted lighting results in the x&#x2F;y&#x2F;z direction.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint voxel_index_1d = <span class="hljs-built_in">GetVoxelIndexFromWorldPos</span>(hit_world_position);<br><br>SVoxelLighting voxel_lighting = scene_voxel_lighting[voxel_index_1d];<br>float3 voxel_lighting_x = voxel_lighting.final_lighting[x_dir];<br>float3 voxel_lighting_y = voxel_lighting.final_lighting[y_dir];<br>float3 voxel_lighting_z = voxel_lighting.final_lighting[z_dir];<br><br><span class="hljs-type">float</span> weight_x = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(world_ray, voxel_light_direction[x_dir]));<br><span class="hljs-type">float</span> weight_y = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(world_ray, voxel_light_direction[y_dir]));<br><span class="hljs-type">float</span> weight_z = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(world_ray, voxel_light_direction[z_dir]));<br><br>radiance += voxel_lighting_x * weight_x;<br>radiance += voxel_lighting_y * weight_y;<br>radiance += voxel_lighting_z * weight_z;<br><br>radiance /= (weight_x + weight_y + weight_z);<br></code></pre></td></tr></table></figure>

<p>radiance trace result:</p>
<p align="center">
    <img src="/resource/simlumen/image/scache_radiosity_atlas.png" srcset="/img/loading.gif" lazyload width="60%" height="60%">
</p>

<p>radiance trace visualization:</p>
<p align="center">
    <img src="/resource/simlumen/image/scache_radiosity_vis.png" srcset="/img/loading.gif" lazyload width="60%" height="60%">
</p>

<h3 id="Radiosity-Filter"><a href="#Radiosity-Filter" class="headerlink" title="Radiosity Filter"></a>Radiosity Filter</h3><p>In this pass, SimLumen filters the radiance atlas to reduce the noise. We sample the radiance around the current texel and accumulate weighted samples. Radiance sample weights in Unreal Lumen are dependent upon a number of factors, including the texel’s World space plane and the distance between the planes.</p>
<p>filtered radiance atlas:</p>
<p align="center">
    <img src="/resource/simlumen/image/scache_radiosity_atlas_filtered.png" srcset="/img/loading.gif" lazyload width="60%" height="60%">
</p>

<h3 id="Convert-To-SH"><a href="#Convert-To-SH" class="headerlink" title="Convert To SH"></a>Convert To SH</h3><p>Radiance atlas results are still noisy after filtering, since we only have 16 samples per probe. We solve this problem by converting the tile radiance into two bands SH, which allows us to interpolate the probes more easily. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(uint trace_idx_x = <span class="hljs-number">0</span>; trace_idx_x &lt; SURFACE_CACHE_PROBE_TEXELS_SIZE; trace_idx_x++)<br>&#123;<br>    <span class="hljs-keyword">for</span>(uint trace_idx_y = <span class="hljs-number">0</span>; trace_idx_y &lt; SURFACE_CACHE_PROBE_TEXELS_SIZE; trace_idx_y++)<br>    &#123;<br>        ......<br>        float3 trace_irradiance = trace_radiance_atlas.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(pixel_atlas_pos.xy, <span class="hljs-number">0</span>)).xyz;<br>        irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(<span class="hljs-built_in">SHBasisFunction</span>(world_ray), trace_irradiance / pdf));<br>		num_valid_sample += <span class="hljs-number">1.0f</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (num_valid_sample &gt; <span class="hljs-number">0</span>)<br>&#123;<br>	irradiance_sh = <span class="hljs-built_in">MulSH</span>(irradiance_sh, <span class="hljs-number">1.0f</span> / num_valid_sample);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Radiosity-Integrate"><a href="#Radiosity-Integrate" class="headerlink" title="Radiosity Integrate"></a>Radiosity Integrate</h3><p>Finally, sample the probes around the current pixel and calculate the weights based on the atlas position. Then, accumulate the SH weights and weighted SH, calculate the basis function using the current pixel’s world normal, and dot product the basis function with the SH result.  By dividing it by the total sum of SH weights, we get the final radiance value for the current pixel.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FTwoBandSHVectorRGB irradiance_sh = (FTwoBandSHVectorRGB)<span class="hljs-number">0</span>;<br><br>FTwoBandSHVectorRGB sub_irradiance_sh00 = <span class="hljs-built_in">GetRadiosityProbeSH</span>(ProbeCoord00);<br>FTwoBandSHVectorRGB sub_irradiance_sh01 = <span class="hljs-built_in">GetRadiosityProbeSH</span>(ProbeCoord01);<br>FTwoBandSHVectorRGB sub_irradiance_sh10 = <span class="hljs-built_in">GetRadiosityProbeSH</span>(ProbeCoord10);<br>FTwoBandSHVectorRGB sub_irradiance_sh11 = <span class="hljs-built_in">GetRadiosityProbeSH</span>(ProbeCoord11);<br><br>irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(sub_irradiance_sh00, weights.x));<br>irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(sub_irradiance_sh01, weights.y));<br>irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(sub_irradiance_sh10, weights.z));<br>irradiance_sh = <span class="hljs-built_in">AddSH</span>(irradiance_sh, <span class="hljs-built_in">MulSH</span>(sub_irradiance_sh11, weights.w));<br><br>uint card_index_1d = card_idx_2d.y * SURFACE_CACHE_CARD_NUM_XY + card_idx_2d.x;<br>SCardInfo card_info = scene_card_infos[card_index_1d];<br>SCardData card_data = <span class="hljs-built_in">GetSurfaceCardData</span>(card_info, <span class="hljs-built_in">float2</span>(<span class="hljs-built_in">uint2</span>(thread_index.xy % <span class="hljs-number">128u</span>)) / <span class="hljs-number">128.0f</span>, pixel_atlas_pos.xy);<br>FTwoBandSHVector diffuse_transfer_sh = <span class="hljs-built_in">CalcDiffuseTransferSH</span>(card_data.world_normal, <span class="hljs-number">1.0f</span>);<br><br>float3 texel_irradiance = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">float3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>), <span class="hljs-built_in">DotSH</span>(irradiance_sh, diffuse_transfer_sh));<br>irtexel_radiance = texel_irradiance / (weights.x + weights.y + weights.z + weights.w);<br></code></pre></td></tr></table></figure>

<p>surface cache indirect lighting visualization:</p>
<p align="center">
    <img src="/resource/simlumen/image/indirect_lighting_vis.png" srcset="/img/loading.gif" lazyload width="60%" height="60%">
</p>

<p>surface cache combined lighting visualization:</p>
<p align="center">
    <img src="/resource/simlumen/image/combined_lighting_vis.png" srcset="/img/loading.gif" lazyload width="60%" height="60%">
</p>

<h1 id="Final-Gather"><a href="#Final-Gather" class="headerlink" title="Final Gather"></a>Final Gather</h1><p>We place the probe in screen space for each 8x8 pixels and use octchedron mapping to map the screen coordinates into spherical coordinates. Each probe trace 64 rays into the scene.</p>
<h2 id="Importance-Sampling"><a href="#Importance-Sampling" class="headerlink" title="Importance Sampling"></a>Importance Sampling</h2><p>It’s too noisy if we employ uniform sampling rather than importance sampling.<br>without importance sampling Vs with importance sampling:</p>
<p align="center">
    <img src="/resource/simlumen/image/is_vs_no_is.png" srcset="/img/loading.gif" lazyload width="60%" height="60%">
</p>

<p>What we do in the importance sampling part is searching the rays that orientates to the lighting source and world normal. That is to say, we peroform importance sampling for BRDF(fs) term and input radiance(Li) term:</p>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>N</mi></mfrac><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mfrac><mrow><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><msub><mi>f</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>l</mi><mo>−</mo><mo>&gt;</mo><mi>v</mi><mo stretchy="false">)</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>θ</mi><mi>l</mi><mo stretchy="false">)</mo></mrow><msub><mi>P</mi><mi>k</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{N}\Sigma_{k=1}^{N}\frac{L_{i}(l)f_{s}(l-&gt;v)cos(\theta l)}{P_{k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4609em;vertical-align:-0.4509em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.4169em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.1076em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mtight">−</span><span class="mrel mtight">&gt;</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span><span class="mord mathnormal mtight">cos</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">θl</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4509em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>

<h3 id="BRDF-PDF"><a href="#BRDF-PDF" class="headerlink" title="BRDF PDF"></a>BRDF PDF</h3><p>In this step, SimLumen generate the three band sphere harmonic factors for the BRDF function. We sample the screen pixels around the screen probe and compute the influence weight on the probe. If the weight is over the threshold, convert the BRDF to SH and accumulate the SH. Then write the result to the BRDF SH buffer.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 pixel_world_position = <span class="hljs-built_in">GetWorldPosByDepth</span>(thread_depth, piexl_tex_uv);<br>float3 probe_world_position = <span class="hljs-built_in">GetWorldPosByDepth</span>(probe_depth, ss_probe_atlas_pos / global_thread_size);<br><br>float4 pixel_world_plane = <span class="hljs-built_in">float4</span>(thread_world_normal, <span class="hljs-built_in">dot</span>(thread_world_normal,pixel_world_position));<br><span class="hljs-type">float</span> plane_distance = <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">dot</span>(<span class="hljs-built_in">float4</span>(probe_world_position, <span class="hljs-number">-1</span>), pixel_world_plane));<br><br><span class="hljs-type">float</span> probe_view_dist = <span class="hljs-built_in">length</span>(probe_world_position - CameraPos);<br><span class="hljs-type">float</span> relative_depth_diff = plane_distance / probe_view_dist;<br><span class="hljs-type">float</span> depth_weight = <span class="hljs-built_in">exp2</span>(<span class="hljs-number">-10000.0f</span> * (relative_depth_diff * relative_depth_diff));<br><span class="hljs-keyword">if</span>(depth_weight &gt; <span class="hljs-number">0.1f</span>)<br>&#123;<br>    uint write_index;<br>    <span class="hljs-built_in">InterlockedAdd</span>(group_num_sh, <span class="hljs-number">1</span>, write_index);<br><br>    FThreeBandSHVector brdf = <span class="hljs-built_in">CalcDiffuseTransferSH3</span>(thread_world_normal, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-built_in">WriteGroupSharedSH</span>(brdf, write_index);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>The pixel normal may be located in a different plane from the probe. Therefore, we compute the plane weight for the given pixel and reject the pixel if the depth weight is over the threshold. Then, store the results of those valid pixels in a <strong>group shared</strong> array.</p>
<p align="center">
    <img src="/resource/simlumen/image/brdf_depth_weight.png" srcset="/img/loading.gif" lazyload width="60%" height="60%">
</p>

<p>After that, perform a parallel reduction to accumulate these SH factors.</p>
<p align="center">
    <img src="/resource/simlumen/image/acc_brdf_pdf.png" srcset="/img/loading.gif" lazyload width="60%" height="60%">
</p>

<p>Finally, the first nine threads store the 9 SH factors in output BRDF SH buffer.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (thread_index &lt; <span class="hljs-number">9</span> &amp;&amp; group_num_sh &gt; <span class="hljs-number">0</span>)<br>&#123;<br>    uint write_index = (ss_probe_idx_xy.y * screen_probe_size_x + ss_probe_idx_xy.x) * <span class="hljs-number">9</span> + thread_index;<br>    <span class="hljs-type">float</span> normalize_weight = <span class="hljs-number">1.0f</span> / (<span class="hljs-type">float</span>)(group_num_sh);<br>    brdf_pdf_sh[write_index] = pdf_sh[offset][thread_index] * normalize_weight;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>brdf pdf visualization:</p>
<p align="center">
    <img src="/resource/simlumen/image/brdf_pdf_vis.png" srcset="/img/loading.gif" lazyload width="60%" height="60%">
</p>

<h3 id="Lighting-PDF"><a href="#Lighting-PDF" class="headerlink" title="Lighting PDF"></a>Lighting PDF</h3><p>The light source direction in the current frame is unknown. In order to search the light direction, we assume lighting changes slightly and reuse the previous frame’s lighting result.</p>
<p align="center">
    <img src="/resource/simlumen/image/ss_light_is.png" srcset="/img/loading.gif" lazyload width="60%" height="60%">
</p>

<p>Then, reproject the probe into the previous frame screen position and find the corresponding direction texel.</p>
<p>Calculate the lighting pdf based on its luminance.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> float2 global_thread_size = <span class="hljs-built_in">float2</span>(is_pdf_thread_size_x,is_pdf_thread_size_y);<br>float3 probe_world_position = gbuffer_c.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(ss_probe_atlas_pos.xy,<span class="hljs-number">0</span>)).xyz;<br><br>float4 pre_view_pos = <span class="hljs-built_in">mul</span>(PreViewProjMatrix,<span class="hljs-built_in">float4</span>(probe_world_position, <span class="hljs-number">1.0</span>));<br>float2 pre_view_screen_pos = (<span class="hljs-built_in">float2</span>(pre_view_pos.xy / pre_view_pos.w) * <span class="hljs-number">0.5</span> + <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>));<br>pre_view_screen_pos.y = (<span class="hljs-number">1.0</span> - pre_view_screen_pos.y);<br>pre_view_screen_pos = pre_view_screen_pos * global_thread_size;<br>uint2 pre_probe_pos = <span class="hljs-built_in">uint2</span>(pre_view_screen_pos) / <span class="hljs-built_in">uint2</span>(PROBE_SIZE_2D,PROBE_SIZE_2D);<br>uint2 pre_texel_pos = pre_probe_pos * <span class="hljs-built_in">uint2</span>(PROBE_SIZE_2D,PROBE_SIZE_2D) + group_thread_idx.xy;<br><br>lighting = sspace_composited_radiance.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(pre_texel_pos.xy,<span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure>

<p>lighting importance sampling pdf visualization:</p>
<p align="center">
    <img src="/resource/simlumen/image/lighting_is_pdf_vis.png" srcset="/img/loading.gif" lazyload width="60%" height="60%">
</p>

<h3 id="Structured-Importance-Sampling"><a href="#Structured-Importance-Sampling" class="headerlink" title="Structured Importance Sampling"></a>Structured Importance Sampling</h3><p>Unreal Lumen adopted a new mechanism called structured importance sampling to reassign the not important samples to those importance directions.</p>
<p>The first step is to calculate the PDF of probe 8x8 pixels. We can obtain the world ray direction by pixel’s uv in the group based on the equi area spherical mapping algorithm. The BRDF PDF in this direction can be calculated by the BRDF PDF SH computed in the last pass.</p>
<p align="center">
    <img src="/resource/simlumen/image/struct_id_cull.png" srcset="/img/loading.gif" lazyload width="70%" height="70%">
</p>


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// brdf pdf</span><br>FThreeBandSHVector brdf;<br>brdf.V0.x = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">0</span>];<br>brdf.V0.y = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">1</span>];<br>brdf.V0.z = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">2</span>];<br>brdf.V0.w = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">3</span>];<br>brdf.V1.x = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">4</span>];<br>brdf.V1.y = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">5</span>];<br>brdf.V1.z = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">6</span>];<br>brdf.V1.w = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">7</span>];<br>brdf.V2.x = brdf_pdf_sh[sh_base_idx + <span class="hljs-number">8</span>];<br><br>float2 probe_uv = (group_thread_idx.xy + <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5f</span>,<span class="hljs-number">0.5f</span>)) / PROBE_SIZE_2D;<br>float3 world_cone_direction = <span class="hljs-built_in">EquiAreaSphericalMapping</span>(probe_uv);<br><br>FThreeBandSHVector direction_sh = <span class="hljs-built_in">SHBasisFunction3</span>(world_cone_direction);<br><span class="hljs-type">float</span> pdf = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">DotSH3</span>(brdf, direction_sh), <span class="hljs-number">0</span>);<br><br><span class="hljs-type">float</span> light_pdf = light_pdf_tex.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(dispatch_thread_idx.xy,<span class="hljs-number">0</span>));<br><span class="hljs-type">bool</span> is_pdf_no_culled_by_brdf = pdf &gt;= MIN_PDF_TRACE;<br><br><span class="hljs-type">float</span> light_pdf_scaled = light_pdf * PROBE_SIZE_2D * PROBE_SIZE_2D;<br>pdf *= light_pdf_scaled;<br><span class="hljs-keyword">if</span>(is_pdf_no_culled_by_brdf)<br>&#123;<br>    pdf = <span class="hljs-built_in">max</span>(pdf, MIN_PDF_TRACE);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Perform a GPU sort from low to high to find those ray directions that need refinement.</p>
<p align="center">
    <img src="/resource/simlumen/image/struct_is_flow.png" srcset="/img/loading.gif" lazyload width="50%" height="50%">
</p>

<p>We refine the rays in groups of three. If the maximum PDF among the three rays is less than the minimum PDF threshold, these samples are discarded and refinement is performed. The ray refinement is similar to the mip map. Double the coordinates, compute the local coordinates based on the ray indexes (0,1), (1,1), and (1,0), respectively. Coordinate (0,0) is the position of the corresponding ray to the refine group.</p>
<p align="center">
    <img src="/resource/simlumen/image/struct_is_0.png" srcset="/img/loading.gif" lazyload width="65%" height="65%">
</p>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint merge_thread_idx = thread_idx % <span class="hljs-number">3</span>;<br>uint merge_idx = thread_idx / <span class="hljs-number">3</span>;<br>uint ray_idx_to_refine = <span class="hljs-built_in">max</span>((<span class="hljs-type">int</span>)PROBE_SIZE_2D * PROBE_SIZE_2D - (<span class="hljs-type">int</span>)merge_idx - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>uint ray_idx_to_merge = merge_idx * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span>(ray_idx_to_merge &lt; ray_idx_to_refine)<br>&#123;<br>    uint2 ray_tex_coord_to_merge;<br>	uint ray_level_to_merge;<br>	<span class="hljs-type">float</span> ray_pdf_to_merge;<br>	<span class="hljs-built_in">UnpackRaySortInfo</span>(RaysToRefine[sort_offset + ray_idx_to_merge], ray_tex_coord_to_merge, ray_level_to_merge, ray_pdf_to_merge);<br><br>    <span class="hljs-keyword">if</span>(ray_pdf_to_merge &lt; MIN_PDF_TRACE)<br>    &#123;<br>        uint2 origin_ray_tex_coord;<br>        uint original_ray_level;<br>        uint original_pdf;<br>        <span class="hljs-built_in">UnpackRaySortInfo</span>(RaysToRefine[sort_offset + ray_idx_to_refine], origin_ray_tex_coord, original_ray_level, original_pdf);<br><br>        RaysToRefine[sort_offset + thread_idx] = <span class="hljs-built_in">PackRaySortInfo</span>(origin_ray_tex_coord * <span class="hljs-number">2</span> + <span class="hljs-built_in">uint2</span>((merge_thread_idx + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>, (merge_thread_idx + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>), original_ray_level - <span class="hljs-number">1</span>, <span class="hljs-number">0.0f</span>);<br><br>		<span class="hljs-keyword">if</span> (merge_idx == <span class="hljs-number">0</span>)<br>		&#123;<br>			<span class="hljs-built_in">InterlockedAdd</span>(num_rays_to_subdivide, <span class="hljs-number">1</span>);<br>		&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Screen-Space-Probe-Trace"><a href="#Screen-Space-Probe-Trace" class="headerlink" title="Screen Space Probe Trace"></a>Screen Space Probe Trace</h2><p>Unreal Lumen is a hybird global illumination solution consisting four GI methods: SSGI, Mesh SDF trace, global SDF trace and cube map. Unreal Lumen performs screen space GI first by sampling the previous scene color. When the SSGI fails to hit, Unreal Lumen performs a mesh SDF trace and samples the surface cache final lighting atlas. Mesh SDF trace is only performed on probes near the camera (positions in 40m radius around the camera). For those further probes, Unreal Lumen performs Global SDF trace and samples the scene voxel lighting. If all of these methods fail, Unreal Lumen falls back to sample the cube map.</p>
<p>In SimLumen, we only perform <strong>two trace methods</strong>: sampling the <strong>surface cache final lighting</strong> by mesh SDF trace and sampling the <strong>scene voxel lighting</strong> by global SDF trace. </p>
<p align="center">
    <img src="/resource/simlumen/image/hybrid_gi.png" srcset="/img/loading.gif" lazyload width="65%" height="65%">
</p>

<h3 id="Screen-Space-Probe-Mesh-SDF-Trace"><a href="#Screen-Space-Probe-Mesh-SDF-Trace" class="headerlink" title="Screen Space Probe Mesh SDF Trace"></a>Screen Space Probe Mesh SDF Trace</h3><p>We perform mesh SDF trace if the probe’s distance to the camera is less than 100m.</p>
<p>Sample 64 directions for each screen space probe. The sample direction is obtained from structured importance sampling table. This table stores the ray coordinates. The refined ray’s coordinates (mip 0) range from (0,0) to (16,16), and the other ray’s coordinates (mip 1) range from (0,0) to (8,8). Divide the ray coordinates by the mip size and transform them into range (0,1). We can obtain the mapped direction by EquiAreaSphericalMapping with mapped UV.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetScreenProbeTexelRay</span><span class="hljs-params">(uint2 buffer_idx, inout float3 ray_direction)</span></span><br><span class="hljs-function"></span>&#123;<br>    uint packed_ray_info = structed_is_indirect_table.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(buffer_idx.xy,<span class="hljs-number">0</span>));<br><br>    uint2 texel_coord;<br>    uint level;<br>    <span class="hljs-built_in">UnpackRayInfo</span>(packed_ray_info, texel_coord, level);<br><br>    uint mip_size = <span class="hljs-number">16</span> &gt;&gt; level;<br>    <span class="hljs-type">float</span> inv_mip_size = <span class="hljs-number">1.0f</span> / <span class="hljs-built_in">float</span>(mip_size);<br><br>    float2 probe_uv = (texel_coord + <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>)) * inv_mip_size;<br>    ray_direction = <span class="hljs-built_in">EquiAreaSphericalMapping</span>(probe_uv);<br>    ray_direction = <span class="hljs-built_in">normalize</span>(ray_direction);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Then trace the scene mesh SDFs that are around the current probe in the world space.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[loop]<br><span class="hljs-keyword">for</span>(uint mesh_idx = <span class="hljs-number">0</span>; mesh_idx &lt; SCENE_SDF_NUM; mesh_idx++)<br>&#123;<br>    SMeshSDFInfo mesh_sdf_info = scene_sdf_infos[mesh_idx];<br>    <span class="hljs-type">float</span> trace_bais = mesh_sdf_info.volume_brick_size * <span class="hljs-number">0.125</span> * <span class="hljs-number">2.0</span>; <span class="hljs-comment">//2 voxel</span><br>    <span class="hljs-built_in">RayTraceSingleMeshSDF</span>(probe_world_position + world_normal * trace_bais, ray_direction, <span class="hljs-number">1000</span>, mesh_idx, trace_result);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Calculate the hit world position if the ray hits the scene SDFs. Then, sample the surface cache card based on the world position. Unreal Lumen samples the surface cache cards <strong>three times</strong> based on it’s ray directions and the normal in the hit position. Considering our meshes are not too complex, SimLumen only <strong>samples once</strong> based on the <strong>maximum ray direction</strong>.</p>
<p>The surface cache card index is calculated from the mesh card start index and the card direction offset index.</p>
<p>With the mesh card index, we can get the surface cache atlas UV and sample the final lighting.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 hit_world_position = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>);<br><span class="hljs-keyword">if</span>(trace_result.is_hit)<br>&#123;<br>    SMeshSDFInfo mesh_sdf_info = scene_sdf_infos[trace_result.hit_mesh_index];<br><br>    <span class="hljs-type">float</span> trace_bais = mesh_sdf_info.volume_brick_size * <span class="hljs-number">0.125</span> * <span class="hljs-number">2.0</span>; <span class="hljs-comment">//2 voxel</span><br>    hit_world_position = probe_world_position + world_normal * trace_bais + ray_direction * trace_result.hit_distance;<br>    <br>    <span class="hljs-type">float</span> max_ray_dir = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-type">int</span> max_dir_card_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(ray_direction.x) &gt; max_ray_dir)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(ray_direction.x &gt; <span class="hljs-number">0</span>)&#123;max_dir_card_idx = <span class="hljs-number">5</span>;&#125;<br>        <span class="hljs-keyword">else</span>&#123;max_dir_card_idx = <span class="hljs-number">4</span>;&#125;;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(ray_direction.y) &gt; max_ray_dir)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(ray_direction.y &gt; <span class="hljs-number">0</span>)&#123;max_dir_card_idx = <span class="hljs-number">3</span>;&#125;<br>        <span class="hljs-keyword">else</span>&#123;max_dir_card_idx = <span class="hljs-number">2</span>;&#125;;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(ray_direction.z) &gt; max_ray_dir)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(ray_direction.z &gt; <span class="hljs-number">0</span>)&#123;max_dir_card_idx = <span class="hljs-number">1</span>;&#125;<br>        <span class="hljs-keyword">else</span>&#123;max_dir_card_idx = <span class="hljs-number">0</span>;&#125;;<br>    &#125;<br><br>    uint card_index = mesh_sdf_info.mesh_card_start_index + max_dir_card_idx;<br>    <br>    SCardInfo card_info = scene_card_infos[card_index];<br>    float2 card_uv = <span class="hljs-built_in">GetCardUVFromWorldPos</span>(card_info, hit_world_position);<br>    <br>    uint2 card_index_xy = <span class="hljs-built_in">uint2</span>((card_index % card_num_xy), (card_index / card_num_xy));<br>    uint2 pixel_pos = card_index_xy * <span class="hljs-number">128</span> + <span class="hljs-built_in">float2</span>(card_uv * <span class="hljs-number">128</span>);<br>    pixel_pos.y = SURFACE_CACHE_TEX_SIZE - pixel_pos.y;<br>    <br>    float3 lighting = surface_cache_final_lighting.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(pixel_pos,<span class="hljs-number">0</span>)).xyz;<br>    trace_radiance = lighting;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    trace_radiance = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>); <span class="hljs-comment">//hack sky light</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>surface cache sample result:</p>
<p align="center">
    <img src="/resource/simlumen/image/mesh_sdf_trace_result.png" srcset="/img/loading.gif" lazyload width="85%" height="85%">
</p>

<h3 id="Screen-Space-Probe-Voxel-Trace"><a href="#Screen-Space-Probe-Voxel-Trace" class="headerlink" title="Screen Space Probe Voxel Trace"></a>Screen Space Probe Voxel Trace</h3><p>The probes further than 100m using voxel lighting trace, which is similar to surface cache sampling. There are several differences between them: the probes trace the scene using a low resolution global SDF rather than single mesh SDFs, and they sample voxel lighting rather than surface cache lighting.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SGloablSDFHitResult hit_result = (SGloablSDFHitResult)<span class="hljs-number">0</span>;<br><span class="hljs-built_in">TraceGlobalSDF</span>(probe_world_position + world_normal * gloabl_sdf_voxel_size * <span class="hljs-number">2.0</span>, ray_direction, hit_result);<br></code></pre></td></tr></table></figure>

<p>Voxel lighting is sampled three times based on the ray trace direction. The sample weights are computed by the dot product result between the ray trace direction and voxel face direction.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x_dir = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(ray_direction.x &gt; <span class="hljs-number">0.0</span>) &#123; x_dir = <span class="hljs-number">5</span>;  &#125;<br><span class="hljs-keyword">else</span> &#123; x_dir = <span class="hljs-number">4</span>;  &#125;<br><br><span class="hljs-type">int</span> y_dir = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(ray_direction.y &gt; <span class="hljs-number">0.0</span>) &#123; y_dir = <span class="hljs-number">3</span>;  &#125;<br><span class="hljs-keyword">else</span> &#123; y_dir = <span class="hljs-number">2</span>;  &#125;<br><br><span class="hljs-type">int</span> z_dir = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(ray_direction.z &gt; <span class="hljs-number">0.0</span>) &#123; z_dir = <span class="hljs-number">1</span>;  &#125;<br><span class="hljs-keyword">else</span> &#123; z_dir = <span class="hljs-number">0</span>;  &#125;<br><br><br><span class="hljs-keyword">if</span>(hit_result.bHit)<br>&#123;<br>    float3 hit_world_position =  ray_direction * (hit_result.hit_distance - gloabl_sdf_voxel_size) + probe_world_position + world_normal * gloabl_sdf_voxel_size * <span class="hljs-number">2.0</span>;<br><br>    uint voxel_index_1d = <span class="hljs-built_in">GetVoxelIndexFromWorldPos</span>(hit_world_position);<br>    SVoxelLighting voxel_lighting = scene_voxel_lighting[voxel_index_1d];<br><br>    float3 voxel_lighting_x = voxel_lighting.final_lighting[x_dir];<br>    float3 voxel_lighting_y = voxel_lighting.final_lighting[y_dir];<br>    float3 voxel_lighting_z = voxel_lighting.final_lighting[z_dir];<br><br>    <span class="hljs-type">float</span> weight_x = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(ray_direction, voxel_light_direction[x_dir]));<br>    <span class="hljs-type">float</span> weight_y = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(ray_direction, voxel_light_direction[y_dir]));<br>    <span class="hljs-type">float</span> weight_z = <span class="hljs-built_in">saturate</span>(<span class="hljs-built_in">dot</span>(ray_direction, voxel_light_direction[z_dir]));<br><br>    radiance += (voxel_lighting_x * weight_x);<br>    radiance += (voxel_lighting_y * weight_y);<br>    radiance += (voxel_lighting_z * weight_z);<br><br>    radiance /= (weight_x + weight_y + weight_z);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    radiance = <span class="hljs-built_in">float3</span>(<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.1</span>); <span class="hljs-comment">//hack sky light</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>voxel lighting sampling result:</p>
<p align="center">
    <img src="/resource/simlumen/image/voxel_trace_result.png" srcset="/img/loading.gif" lazyload width="85%" height="85%">
</p>


<h2 id="Traced-Radiance-Composite"><a href="#Traced-Radiance-Composite" class="headerlink" title="Traced Radiance Composite"></a>Traced Radiance Composite</h2><p>Since the samples may be refined, we perform an additional composition pass to accumulate the ray samples. Each comptue group processes one probe ( 8x8 samples).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">groupshared uint shared_accumulator[PROBE_SIZE_2D * PROBE_SIZE_2D][<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure>
<p>The refined ray weighs 1&#x2F;4 and the other ray weighs 1.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">float</span> sample_weight = (<span class="hljs-type">float</span>)<span class="hljs-number">8</span> / mip_size * <span class="hljs-number">8</span> / mip_size; <span class="hljs-comment">// level 0: weight 1/4, level 1: weight 1</span><br>float3 lighting = screen_space_trace_radiance.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(dispatch_thread_idx.xy, <span class="hljs-number">0</span>)).xyz * sample_weight;<br></code></pre></td></tr></table></figure>

<p> We acclumulate the samples in a probe and assign the result to the original unrefined sample position.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint2 remaped_texel_coord = texel_coord * PROBE_SIZE_2D / mip_size;<br>uint remapped_thread_idx = remaped_texel_coord.y * PROBE_SIZE_2D + remaped_texel_coord.x;<br><br>uint3 quantized_lighting = lighting * lighting_quantize_scale;<br><br><span class="hljs-built_in">InterlockedAdd</span>(shared_accumulator[remapped_thread_idx][<span class="hljs-number">0</span>], quantized_lighting.x);<br><span class="hljs-built_in">InterlockedAdd</span>(shared_accumulator[remapped_thread_idx][<span class="hljs-number">1</span>], quantized_lighting.y);<br><span class="hljs-built_in">InterlockedAdd</span>(shared_accumulator[remapped_thread_idx][<span class="hljs-number">2</span>], quantized_lighting.z);<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint thread_index = group_thread_idx.y * PROBE_SIZE_2D + group_thread_idx.x;<br>radiance = <span class="hljs-built_in">float3</span>(shared_accumulator[thread_index][<span class="hljs-number">0</span>], shared_accumulator[thread_index][<span class="hljs-number">1</span>], shared_accumulator[thread_index][<span class="hljs-number">2</span>]) / lighting_quantize_scale;<br></code></pre></td></tr></table></figure>
<p align="center">
    <img src="/resource/simlumen/image/composition.png" srcset="/img/loading.gif" lazyload width="75%" height="75%">
</p>

<p>radiance composition result:</p>
<p align="center">
    <img src="/resource/simlumen/image/composited_result.png" srcset="/img/loading.gif" lazyload width="85%" height="85%">
</p>

<h2 id="Screen-Radiance-Filter"><a href="#Screen-Radiance-Filter" class="headerlink" title="Screen Radiance Filter"></a>Screen Radiance Filter</h2><p>Filter the screen space radiance to denoise the result. Radiance filter weight is a combination of <strong>angle weight and depth weight</strong> in Unreal Lumen. We use a <strong>simple uniform weight</strong> instead of an angle&#x2F;depth weight because our scene is simple and most of the mesh is cubes.</p>
<p align="center">
    <img src="/resource/simlumen/image/radiance_filter.png" srcset="/img/loading.gif" lazyload width="40%" height="40%">
</p>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">float3 total_radiance = screen_space_radiance.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(dispatch_thread_idx.xy, <span class="hljs-number">0</span>)).xyz;<br><span class="hljs-type">float</span> total_weight = <span class="hljs-number">1.0</span>;<br><br>int2 offsets[<span class="hljs-number">4</span>]; offsets[<span class="hljs-number">0</span>] = <span class="hljs-built_in">int2</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>); offsets[<span class="hljs-number">1</span>] = <span class="hljs-built_in">int2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>); offsets[<span class="hljs-number">2</span>] = <span class="hljs-built_in">int2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>); offsets[<span class="hljs-number">3</span>] = <span class="hljs-built_in">int2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span> (uint offset_index = <span class="hljs-number">0</span>; offset_index &lt; <span class="hljs-number">4</span>; offset_index++)<br>&#123;<br>    int2 neighbor_index = offsets[offset_index] * PROBE_SIZE_2D + dispatch_thread_idx.xy;<br>    <span class="hljs-keyword">if</span>((neighbor_index.x &gt;= <span class="hljs-number">0</span>) &amp;&amp; (neighbor_index.x &lt; is_pdf_thread_size_x) &amp;&amp; (neighbor_index.y &gt;= <span class="hljs-number">0</span>) &amp;&amp; (neighbor_index.y &lt; is_pdf_thread_size_y))<br>    &#123;<br>        <span class="hljs-type">float</span> neigh_depth = gbuffer_depth.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(ss_probe_atlas_pos.xy + offsets[offset_index] * PROBE_SIZE_2D, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">if</span>(neigh_depth != <span class="hljs-number">0</span>)<br>        &#123;<br>            total_radiance += screen_space_radiance.<span class="hljs-built_in">Load</span>(<span class="hljs-built_in">int3</span>(dispatch_thread_idx.xy, <span class="hljs-number">0</span>)).xyz;<br>            total_weight += <span class="hljs-number">1.0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>filtered_radiance = total_radiance / total_weight;<br></code></pre></td></tr></table></figure>

<p>filtered radiance result:</p>
<p align="center">
    <img src="/resource/simlumen/image/filtered_radiance.png" srcset="/img/loading.gif" lazyload width="80%" height="80%">
</p>


<h2 id="Convert-To-Oct-SH-Representaion"><a href="#Convert-To-Oct-SH-Representaion" class="headerlink" title="Convert To Oct SH Representaion"></a>Convert To Oct SH Representaion</h2><p>To denoise the radiance result further, we convert the radiance into <strong>shperical harmonic</strong>, which acts as a low-pass filter. After that we transform the SH into <strong>octahedron</strong> representation. The reason we perform this additional pass is to use <strong>hardware bilinear filter</strong> in the next integration pass. In order to avoid sampling the other probe’s result, we add a pixel <strong>board</strong> around the center.</p>
<p align="center">
    <img src="/resource/simlumen/image/radiance_to_oct.png" srcset="/img/loading.gif" lazyload width="35%" height="35%">
</p>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">uint2 texel_coord_with_boarder = <span class="hljs-built_in">OctahedralMapWrapBorder</span>(<span class="hljs-built_in">uint2</span>(write_idx_x, write_idx_y),SCREEN_SPACE_PROBE,<span class="hljs-number">1</span>);<br>float2 probe_texel_center = <span class="hljs-built_in">float2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);<br>float2 probe_uv = (texel_coord_with_boarder + probe_texel_center) / (<span class="hljs-type">float</span>)SCREEN_SPACE_PROBE;<br>float3 texel_direction = <span class="hljs-built_in">EquiAreaSphericalMapping</span>(probe_uv);<br><br>FThreeBandSHVector diffuse_transfer = <span class="hljs-built_in">CalcDiffuseTransferSH3</span>(texel_direction, <span class="hljs-number">1.0f</span>);<br>float3 irradiance = <span class="hljs-number">4.0f</span> * PI * <span class="hljs-built_in">DotSH3</span>(irradiance_sh, diffuse_transfer);<br>screen_space_oct_irradiance[texel_screen_pos] = irradiance;<br></code></pre></td></tr></table></figure>
<p>octahedron spherical  harmonic result:</p>
<p align="center">
    <img src="/resource/simlumen/image/oct_result.png" srcset="/img/loading.gif" lazyload width="70%" height="70%">
</p>

<h2 id="Integrate"><a href="#Integrate" class="headerlink" title="Integrate"></a>Integrate</h2><p>With the boardered octahedron spherical harmonic, we can sample the sh by <strong>hardware bilinear filter</strong>, which denoises the result further.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">float3 <span class="hljs-title">GetScreenProbeIrradiance</span><span class="hljs-params">(uint2 probe_start_pos, float2 irradiance_probe_uv)</span></span><br><span class="hljs-function"></span>&#123;<br>    float2 sub_pos = irradiance_probe_uv * (SCREEN_SPACE_PROBE - <span class="hljs-number">1.0</span>) + <span class="hljs-number">1.0</span>;<br>    float2 texel_uv = (probe_start_pos * SCREEN_SPACE_PROBE + sub_pos) / <span class="hljs-built_in">float2</span>(is_pdf_thread_size_x, is_pdf_thread_size_y);<br>    <span class="hljs-keyword">return</span> screen_space_oct_irradiance.<span class="hljs-built_in">SampleLevel</span>(sampler_linear_clamp,texel_uv,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>For each screen pixel, we sample 5 screen probes and accumulate the samples. After dividing the result by the sum of the weights, we are able to obtain the final result for screen indirect lighting:</p>
<p align="center">
    <img src="/resource/simlumen/image/screen_indirect_lighting_result.png" srcset="/img/loading.gif" lazyload width="70%" height="70%">
</p>

<h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><p>direct lighting only:</p>
<p align="center">
    <img src="/resource/simlumen/image/direct_lighting_only.png" srcset="/img/loading.gif" lazyload width="70%" height="70%">
</p>

<p>with GI:</p>
<p align="center">
    <img src="/resource/simlumen/image/with_gi.png" srcset="/img/loading.gif" lazyload width="70%" height="70%">
</p>

<p><a target="_blank" rel="noopener" href="https://github.com/ShawnTSH1229/SimLumen"><u><strong>Simplified Lumen Source Code</strong></u></a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/My-Projects/" class="category-chain-item">My Projects</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Simplified Lumen GI In MiniEngine</div>
      <div>http://example.com/2024/05/18/Simplified-Lumen-GI-In-MiniEngine/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Shawn Tang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>May 18, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/06/14/GI-Baking-With-Ray-Guiding/" title="GI Baking With Ray Guiding">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">GI Baking With Ray Guiding</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/08/Simplified-Nanite-Virtualized-Geometry-In-MiniEngine/" title="Simplified Nanite In MiniEngine">
                        <span class="hidden-mobile">Simplified Nanite In MiniEngine</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>



<!DOCTYPE html>
<html lang="en" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Shawn Tang">
  <meta name="keywords" content="">
  
    <meta name="description" content="OverviewELF Loader &amp; ParserELF Header &amp; SELFIn computing, the Executable and Linkable Format (ELF, formerly named Extensible Linking Format), is a common standard file format for executable fi">
<meta property="og:type" content="article">
<meta property="og:title" content="How To Develop A PlayStation 4 Emulator(1)">
<meta property="og:url" content="http://example.com/2024/07/05/How-To-Develop-A-PlayStation-4-Emulator(1)/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="OverviewELF Loader &amp; ParserELF Header &amp; SELFIn computing, the Executable and Linkable Format (ELF, formerly named Extensible Linking Format), is a common standard file format for executable fi">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/resource/pset/image/self.png">
<meta property="og:image" content="http://example.com/resource/pset/image/eboot_elf.png">
<meta property="og:image" content="http://example.com/resource/pset/image/libc_elf.png">
<meta property="og:image" content="http://example.com/resource/pset/image/DT_NEEDED.png">
<meta property="og:image" content="http://example.com/resource/pset/image/DT_MODULE.png">
<meta property="og:image" content="http://example.com/resource/pset/image/DT_LIB.png">
<meta property="og:image" content="http://example.com/resource/pset/image/unimplemented_funcs.png">
<meta property="article:published_time" content="2024-07-05T15:15:36.000Z">
<meta property="article:modified_time" content="2024-07-07T13:55:26.158Z">
<meta property="article:author" content="Shawn Tang">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/resource/pset/image/self.png">
  
  
  
  <title>How To Develop A PlayStation 4 Emulator(1) - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":10},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ShawnTSH1229</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="How To Develop A PlayStation 4 Emulator(1)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-05 23:15" pubdate>
          July 5, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          1.9k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          16 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">How To Develop A PlayStation 4 Emulator(1)</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h1 id="ELF-Loader-Parser"><a href="#ELF-Loader-Parser" class="headerlink" title="ELF Loader &amp; Parser"></a>ELF Loader &amp; Parser</h1><h2 id="ELF-Header-SELF"><a href="#ELF-Header-SELF" class="headerlink" title="ELF Header &amp; SELF"></a>ELF Header &amp; SELF</h2><p>In computing, the Executable and Linkable Format (ELF, formerly named Extensible Linking Format), is a common standard file format for executable files, object code, shared libraries, and core dumps. PS4 uses an extended ELF format named SELF (Signed Executable and Linkable Format) to store the executable file. Following is the SELF data layout:</p>
<p align="center">
    <img src="/resource/pset/image/self.png" srcset="/img/loading.gif" lazyload width="45%" height="45%">
</p>

<p>Compared to ELF, SELF has two additional parts. The first part is SELF header. It describes the basic information about the SELF file. What we care about is the <code>Number of Segments</code> part. It indicates the number of the SELF segment structure followed by the SELF header.</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Description</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>4</td>
<td>Magic</td>
<td>4F 15 3D 1D</td>
</tr>
<tr>
<td>0x4</td>
<td>4</td>
<td>Unknown</td>
<td>Always 00 01 01 12</td>
</tr>
<tr>
<td>0x8</td>
<td>1</td>
<td>Category</td>
<td>1 on SELF, 4 on PUP Entry (probably SPP). See [<a target="_blank" rel="noopener" href="https://www.psdevwiki.com/ps3/Certified_File#Category">https://www.psdevwiki.com/ps3/Certified_File#Category</a> PS3&#x2F;PS Vita Category].</td>
</tr>
<tr>
<td>0x9</td>
<td>1</td>
<td>Program Type</td>
<td>First Half denotes version (anything between 0, oldest and F, newest), second Half denotes true type, 4 for Games, 5 for sce_module modules, 6 for Video Apps like Netflix, 8 for System&#x2F;EX Apps&#x2F;Executables, 9 for System&#x2F;EX modules&#x2F;dlls</td>
</tr>
<tr>
<td>0xA</td>
<td>2</td>
<td>Padding</td>
<td></td>
</tr>
<tr>
<td>0xC</td>
<td>2</td>
<td>Header Size</td>
<td></td>
</tr>
<tr>
<td>0xE</td>
<td>2</td>
<td>Signature Size</td>
<td>?Metadata Size?</td>
</tr>
<tr>
<td>0x10</td>
<td>4</td>
<td>File Size</td>
<td>Size of SELF</td>
</tr>
<tr>
<td>0x14</td>
<td>4</td>
<td>Padding</td>
<td></td>
</tr>
<tr>
<td>0x18</td>
<td>2</td>
<td>Number of Segments</td>
<td>1 Kernel, 2 SL and Secure Modules, 4 Kernel ELFs, 6 .selfs, 2 .sdll, 6 .sprx, 6 ShellCore, 6 eboot.bin, 2 sexe</td>
</tr>
<tr>
<td>0x1A</td>
<td>2</td>
<td>Unknown</td>
<td>Always 0x22</td>
</tr>
<tr>
<td>0x1C</td>
<td>4</td>
<td>Padding</td>
<td></td>
</tr>
</tbody></table>
<p>After this, follows the segment structure. I am unable to determine the effect of the segment structure other than to guess. Due to the lack of PS4 documentation, the following content may be incorrect. The SELF segment structure is almost the same as the ELF segment. The difference may be that the data in the SELF segment structure is compressed and encrypted. These parts are used to store the exclusive segment for the PlayStation4.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> flags; <span class="hljs-comment">// 0x130006 / 0x00040F / 0x000006 / 0x110006</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> offset;<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> encrypted_compressed_size;<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> decrypted_decompressed_size;<br>&#125; SEGMENT_TABLE;<br></code></pre></td></tr></table></figure>

<p>The SELF program header is followed by the ELF header. Here is the ELF header information of the <code>eboot.bin</code> and the <code>libc.prx</code>.</p>
<p align="center">
    <img src="/resource/pset/image/eboot_elf.png" srcset="/img/loading.gif" lazyload width="55%" height="55%">
</p>
<p align="center">
    <img src="/resource/pset/image/libc_elf.png" srcset="/img/loading.gif" lazyload width="55%" height="55%">
</p>

<p>Here is the ELF header structure member layout. It describes the basic information of the whole ELF file, such as the object file type, target instruction set architecture, entry point address, program header table and section header table.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">elf64_hdr</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>	e_ident[EI_NIDENT];	<span class="hljs-comment">/* ELF &quot;magic number&quot; */</span><br>    Elf64_Half e_type;<br>    Elf64_Half e_machine;<br>    Elf64_Word e_version;<br>    Elf64_Addr e_entry;		<span class="hljs-comment">/* Entry point virtual address */</span><br>    Elf64_Off e_phoff;		<span class="hljs-comment">/* Program header table file offset */</span><br>    Elf64_Off e_shoff;		<span class="hljs-comment">/* Section header table file offset */</span><br>    Elf64_Word e_flags;<br>    Elf64_Half e_ehsize;<br>    Elf64_Half e_phentsize;<br>    Elf64_Half e_phnum;<br>    Elf64_Half e_shentsize;<br>    Elf64_Half e_shnum;<br>    Elf64_Half e_shstrndx;<br>&#125; Elf64_Ehdr;<br></code></pre></td></tr></table></figure>

<p>The <code>eboot.bin</code> shown on the above is the starup executeble file of the game. The eboot module entry point address is <code>99AC10</code>. It is a virtual address. We will allocate virtual memory and map this virtual address into virtual memory. After that, we can call the entry function to startup the program. Its ELF type is <code>ET_SCE_DYNEXEC</code>. PS4 has five exclusive ELF types:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ET_SCE_EXEC	0xFE00</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ET_SCE_REPLAY_EXEC	0xFE01</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ET_SCE_RELEXEC	0XFE04</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ET_SCE_STUBLIB	0xFE0C</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ET_SCE_DYNEXEC	0xFE10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ET_SCE_DYNAMIC	0xFE18</span><br></code></pre></td></tr></table></figure>

<p>Another ELF file is <code>libc.prx</code>. The <code>prx</code> stands for Playstation Relocatable eXecutable. Its ELF type is <code>ET_SCE_DYNAMIC</code>. We will link this module dynamically at runtime. </p>
<p>We don’t care about SELF information except the SELF segment structure. Those unused information in SELF is discarded. We create the ELF file and fill the segment data with the information contained in the SELF segment structure.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m_module-&gt;m_elfData.<span class="hljs-built_in">resize</span>(segmentsEnd);<br><span class="hljs-built_in">memcpy</span>(m_module-&gt;m_elfData.<span class="hljs-built_in">data</span>(), elf64Header, segmentsStart);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> index = <span class="hljs-number">0</span>; index &lt; numSegments; index++)<br>&#123;<br>	<span class="hljs-keyword">if</span> ((pSegStructureSelfs[index].m_flags &amp; <span class="hljs-built_in">uint64_t</span>(ESegFlags::SF_BFLG)) != <span class="hljs-number">0</span>)<br>	&#123;<br>		<span class="hljs-type">uint32_t</span> flagID = <span class="hljs-built_in">FlagsId</span>(pSegStructureSelfs[index].m_flags);<br>		<span class="hljs-built_in">memcpy</span>(m_module-&gt;m_elfData.<span class="hljs-built_in">data</span>() + elf64ProgramHeader[flagID].p_offset, selfRawData.<span class="hljs-built_in">data</span>() + pSegStructureSelfs[index].m_offsets, pSegStructureSelfs[index].m_encryptedCompressedSize);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><h3 id="Parse-Program-Header"><a href="#Parse-Program-Header" class="headerlink" title="Parse Program Header"></a>Parse Program Header</h3><p>An executable or shared object file’s program header table is an array of structures, each describing a segment or other information the system needs to prepare the program for execution. An object file segment comprises one or more sections, though this fact is transparent to the program header. Whether the file segment holds one or many sections also is immaterial to program loading. Nonetheless, various data must be present for program execution, dynamic linking, and so on. The order and membership of sections within a segment may vary.</p>
<p>program header structure:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>	Elf64_Word	p_type;<br>	Elf64_Word	p_flags;<br>	Elf64_Off	p_offset;<br>	Elf64_Addr	p_vaddr;<br>	Elf64_Addr	p_paddr;<br>	Elf64_Xword	p_filesz;<br>	Elf64_Xword	p_memsz;<br>	Elf64_Xword	p_align;<br>&#125; Elf64_Phdr;<br></code></pre></td></tr></table></figure>
<p>Segment information is described in the program header. We iterate the program header table and obtain segment information:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SPtModuleInfo&amp; moduleInfo = m_module-&gt;m_moduleInfo;<br>elf64_hdr* pElfHdr = (elf64_hdr*)(m_module-&gt;m_elfData.<span class="hljs-built_in">data</span>());<br>elf64_phdr* pElfpHdr = (elf64_phdr*)(pElfHdr + <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> index = <span class="hljs-number">0</span>; index &lt; pElfHdr-&gt;e_phnum; index++)<br>&#123;<br>	<span class="hljs-keyword">switch</span> (pElfpHdr[index].p_type)<br>	&#123;<br>	<span class="hljs-keyword">case</span> PT_NOTE:<br>	<span class="hljs-keyword">case</span> PT_LOAD:<br>	<span class="hljs-keyword">case</span> PT_SCE_RELRO:<br>	<span class="hljs-keyword">case</span> PT_SCE_COMMENT:<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> PT_SCE_PROCPARAM:<br>		moduleInfo.m_nProcParamOffset = pElfpHdr[index].p_paddr;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> PT_INTERP:<br>		moduleInfo.m_pInterProgram = m_module-&gt;m_elfData.<span class="hljs-built_in">data</span>() + pElfpHdr[index].p_offset;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> PT_DYNAMIC:<br>		moduleInfo.m_pDynamicEntry = m_module-&gt;m_elfData.<span class="hljs-built_in">data</span>() + pElfpHdr[index].p_offset;<br>		moduleInfo.m_nDynamicEntryCount = pElfpHdr[index].p_filesz / <span class="hljs-built_in">sizeof</span>(Elf64_Dyn);<br>		<span class="hljs-built_in">PSET_EXIT_AND_LOG_IF</span>(moduleInfo.m_nDynamicEntryCount == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;empty dynamic entry&quot;</span>);<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> PT_SCE_DYNLIBDATA:<br>		moduleInfo.m_pSceDynamicLib.m_pAddress = m_module-&gt;m_elfData.<span class="hljs-built_in">data</span>() + pElfpHdr[index].p_offset;<br>		moduleInfo.m_pSceDynamicLib.m_size = pElfpHdr[index].p_filesz;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">default</span>:<br>		<span class="hljs-built_in">PSET_LOG_INFO</span>(<span class="hljs-string">&quot;unknown program header type&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>We only care about four types of segment: <code>PT_DYNAMIC</code>, <code>PT_SCE_PROCPARAM</code> and <code>PT_SCE_DYNLIBDATA</code>. The first type is the standard ELF segment type. The latter two types are exclusive to the PlayStation4.</p>
<p><code>PT_SCE_PROCPARAM</code>: This field stores the offset of the process parameters. We obtain the process parameters address from the offset. The process parameters comprise the size, the magic number, the entry count and the PS SDK version.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SSceProcParam</span><br>&#123;<br>	<span class="hljs-type">uint64_t</span> m_size;<br>	<span class="hljs-type">char</span> m_magic[<span class="hljs-number">4</span>];<br>	<span class="hljs-type">uint32_t</span> m_entryCount;<br>	<span class="hljs-type">uint64_t</span> m_sdkVersion;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>When the program executes the <code>sceKernelGetProcParam</code> function, we return the process parameters address retrieved from the segment.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SSceProcParam* PSET_SYSV_ABI <span class="hljs-title">Pset_sceKernelGetProcParam</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">PSET_LOG_IMPLEMENTED</span>(<span class="hljs-string">&quot;implemented function: Pset_sceKernelGetProcParam&quot;</span>);<br>	SSceProcParam* retProcParam = (SSceProcParam*)<span class="hljs-built_in">GetElfModuleLoder</span>()-&gt;<span class="hljs-built_in">GetEbootProcParam</span>();<br>	<span class="hljs-built_in">assert</span>(retProcParam != <span class="hljs-literal">nullptr</span>);<br>	<span class="hljs-keyword">return</span> retProcParam;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>PT_DYNAMIC</code>: The array element specifies dynamic linking information.<br><code>PT_SCE_DYNLIBDATA</code>: The dynamic library data.</p>
<h3 id="Parse-Dynamic-Sections"><a href="#Parse-Dynamic-Sections" class="headerlink" title="Parse Dynamic Sections"></a>Parse Dynamic Sections</h3><p>If an object file participates in dynamic linking, its program header table will have an element of type <code>PT_DYNAMIC</code>. This segment contains the <code>.dynamic</code> section. A special symbol, <code>_DYNAMIC</code>, labels the section, which contains an array of the following structures. The <code>_DYNAMIC</code> array corresponds to <code>m_pDynamicEntry</code> obtained in the last step.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>	Elf64_Sxword	d_tag;<br>   	<span class="hljs-keyword">union</span> &#123;<br>   		Elf64_Xword	d_val;<br>   		Elf64_Addr	d_ptr;<br>	&#125; d_un;<br>&#125; Elf64_Dyn;<br><br></code></pre></td></tr></table></figure>
<p>For each object with this type, <code>d_tag</code> controls the interpretation of <code>d_un</code>.<br><code>d_val</code>:  These objects represent integer values with various interpretations.<br><code>d_ptr</code>:  It stores the relative address to the base address. The base address is stored in ‘m_pSceDynamicLib’, which is the segment of <code>PT_SCE_DYNLIBDATA</code> type.</p>
<p>We divided the dynamic sections into two different types. The first type is segments that don’t require access to string tables. The string table (<code>DT_SCE_STRTAB</code>) is a section that contains strings representing the file name, the module name and the library name. Since some dynamic sections depend on the string stable, we access these sections after all of the first types of the section iteration have been finished.</p>
<p>First Iteration:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SPtModuleInfo&amp; moduleInfo = m_module-&gt;m_moduleInfo;<br><span class="hljs-type">uint8_t</span>* baseAddress = (<span class="hljs-type">uint8_t</span>*)moduleInfo.m_pSceDynamicLib.m_pAddress;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> index = <span class="hljs-number">0</span>; index &lt; moduleInfo.m_nDynamicEntryCount; index++)<br>&#123;<br>	Elf64_Dyn&amp; elf64Dyn = ((Elf64_Dyn*)moduleInfo.m_pDynamicEntry)[index];<br>	<span class="hljs-keyword">switch</span> (elf64Dyn.d_tag)<br>	&#123;<br>	<span class="hljs-keyword">case</span> DT_INIT:<br>		moduleInfo.m_nInitOffset = elf64Dyn.d_un.d_ptr;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> DT_SCE_STRTAB:<br>		moduleInfo.m_sceStrTable.m_pAddress = baseAddress + elf64Dyn.d_un.d_ptr;<br>	<span class="hljs-keyword">case</span> DT_SCE_STRSZ:<br>		moduleInfo.m_sceStrTable.m_size = elf64Dyn.d_un.d_val;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> DT_SCE_RELA:<br>		moduleInfo.m_relocationTable.m_pAddress = baseAddress + elf64Dyn.d_un.d_ptr;;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> DT_SCE_RELASZ:<br>		moduleInfo.m_relocationTable.m_size = elf64Dyn.d_un.d_val / <span class="hljs-built_in">sizeof</span>(Elf64_Rela);<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> DT_SCE_JMPREL:<br>		moduleInfo.m_relocationPltTable.m_pAddress = baseAddress + elf64Dyn.d_un.d_ptr;;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> DT_SCE_PLTRELSZ:<br>		moduleInfo.m_relocationPltTable.m_size = elf64Dyn.d_un.d_val / <span class="hljs-built_in">sizeof</span>(Elf64_Rela);<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> DT_SCE_SYMTAB:<br>		moduleInfo.m_symbleTable.m_pAddress = baseAddress + elf64Dyn.d_un.d_ptr;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> DT_SCE_SYMTABSZ:<br>		moduleInfo.m_symbleTable.m_size = elf64Dyn.d_un.d_val;<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>We iterate over the sections that don’t require string tables at first. It contains the following types of sections:</p>
<p><code>DT_INIT</code>: It stores the initialization function offset. We can get the initialization function address from the function offset:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">moduleInfo.m_pInitProc = moduleInfo.m_nInitOffset + (<span class="hljs-type">uint8_t</span>*)moduleInfo.m_mappedMemory.m_pAddress;<br></code></pre></td></tr></table></figure>
<p>The initialization function is executed after all modules have been loaded.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CPtModuleLoader::InitNativeModules</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> index = <span class="hljs-number">0</span>; index &lt; m_nNativeModules; index++)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (m_natveModules[index].m_fileName != <span class="hljs-string">&quot;eboot.bin&quot;</span>)<br>		&#123;<br>			<span class="hljs-keyword">auto</span> initFunc = <span class="hljs-built_in">reinterpret_cast</span>&lt;InitProc&gt;(m_natveModules[index].m_moduleInfo.m_pInitProc);<br>			<span class="hljs-built_in">initFunc</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>DT_SCE_STRTAB</code> <code>DT_SCE_STRSZ</code>: This element holds the string table address and size, as described above. It is a type of section that is exclusive to PS4.</p>
<p><code>DT_SCE_RELA</code>: This element holds the address of a relocation table. Entries in the table have explicit addends, such as <code>Elf32_Rela</code> for the 32-bit file class or <code>Elf64_Rela</code> for the 64-bit file class. An object file may have multiple relocation sections. When building the relocation table for an executable or shared object file, the link editor catenates those sections to form a single table. Although the sections remain independent in the object file, the dynamic linker sees a single table. When the dynamic linker creates the process image for an executable file or adds a shared object to the process image, it reads the relocation table and performs the associated actions.</p>
<p><code>DT_SCE_RELASZ</code>: This element holds the total size, in bytes, of the <code>DT_SCE_RELA</code> relocation table.</p>
<p><code>DT_SCE_JMPREL</code> <code>DT_SCE_PLTRELSZ</code>: Lazy binding (also known as lazy linking or on-demand symbol resolution) is the process by which symbol resolution isn’t done until a symbol is actually used. Functions can be bound on-demand, but data references can’t. All dynamically resolved functions are called via a Procedure Linkage Table (PLT) stub. A PLT stub uses relative addressing, using the Global Offset Table (GOT) to retrieve the offset. The PLT knows where the GOT is, and uses the offset to this table (determined at program linking time) to read the destination function’s address and make a jump to it. <strong>In PSET4, we treat the PLT the same as the relocation table and don’t perform lazy binding.</strong></p>
<p><code>DT_SCE_SYMTAB</code> <code>DT_SCE_SYMTABSZ</code>: This element holds the address of the symbol table, with <code>Elf32_Sym</code> entries for the 32-bit class of files and <code>Elf64_Sym</code> entries for the 64-bit class of files.</p>
<p>Second Iteration:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">uint8_t</span>* sceStrTable = (<span class="hljs-type">uint8_t</span>*)moduleInfo.m_sceStrTable.m_pAddress;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> index = <span class="hljs-number">0</span>; index &lt; moduleInfo.m_nDynamicEntryCount; index++)<br>&#123;<br>	Elf64_Dyn&amp; elf64Dyn = ((Elf64_Dyn*)moduleInfo.m_pDynamicEntry)[index];<br>	<span class="hljs-keyword">switch</span> (elf64Dyn.d_tag)<br>	&#123; <br>	<span class="hljs-keyword">case</span> DT_NEEDED:<br>	&#123;<br>		<span class="hljs-type">char</span>* fileName = (<span class="hljs-type">char</span>*)&amp;sceStrTable[elf64Dyn.d_un.d_ptr];<br>		m_module-&gt;m_neededFiles.<span class="hljs-built_in">push_back</span>(fileName);<br><br>		<span class="hljs-built_in">PSET_LOG_INFO</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;DT_NEEDED:&quot;</span>) + fileName);<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">case</span> DT_SCE_MODULE_INFO:<br>	<span class="hljs-keyword">case</span> DT_SCE_NEEDED_MODULE:<br>	&#123;<br>		SSPtModuleValue moduleValue;<br>		moduleValue.value = elf64Dyn.d_un.d_val;<br>		m_module-&gt;m_id2ModuleNameMap.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">make_pair</span>(moduleValue.id, (<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)(&amp;sceStrTable[moduleValue.name_offset])));<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">case</span> DT_SCE_IMPORT_LIB:<br>	<span class="hljs-keyword">case</span> DT_SCE_EXPORT_LIB:<br>	&#123;<br>		SPtLibraryValue libValue;<br>		libValue.m_value = elf64Dyn.d_un.d_val;<br>		m_module-&gt;m_id2LibraryNameMap.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">make_pair</span>(libValue.id, (<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)(&amp;sceStrTable[libValue.name_offset])));<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">case</span> DT_SCE_ORIGINAL_FILENAME:<br>	&#123;<br>		SPtLibraryValue libValue;<br>		libValue.m_value = elf64Dyn.d_un.d_val;<br>		<span class="hljs-built_in">PSET_LOG_INFO</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;DT_SCE_ORIGINAL_FILENAME:&quot;</span>) + (<span class="hljs-type">char</span>*)&amp;sceStrTable[libValue.name_offset]);<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>After that, we iterate over the sections that require the string table. It contains the following types of sections:</p>
<p><code>DT_NEEDED</code>: This element holds the string table offset of a null-terminated string, giving the name of a needed library. The offset is an index into the table recorded in the <code>DT_SCE_STRTAB</code> code. The dynamic array may contain multiple entries with this type. These entries’ relative order is significant, though their relation to entries of other types is not. Following is the needed libraries of the <code>eBoot</code> module:</p>
<p align="center">
    <img src="/resource/pset/image/DT_NEEDED.png" srcset="/img/loading.gif" lazyload width="55%" height="55%">
</p>

<p><code>DT_SCE_MODULE_INFO</code> <code>DT_SCE_NEEDED_MODULE</code>: These elements store the current module information and the needed module information. Each module contains one or more libraries. Here is the module information of the <code>eBoot</code> module:</p>
<p align="center">
    <img src="/resource/pset/image/DT_MODULE.png" srcset="/img/loading.gif" lazyload width="55%" height="55%">
</p>

<p><code>DT_SCE_IMPORT_LIB</code> <code>DT_SCE_EXPORT_LIB</code>: Those elements hold the import and export libraries. It will be used in the latter dynamic link process.</p>
<p align="center">
    <img src="/resource/pset/image/DT_LIB.png" srcset="/img/loading.gif" lazyload width="55%" height="55%">
</p>

<h2 id="Load-ELF-Module-Into-Memory"><a href="#Load-ELF-Module-Into-Memory" class="headerlink" title="Load ELF Module Into Memory"></a>Load ELF Module Into Memory</h2><p>As we have all segment information, we can load them into memory. Only headers with a type of PT_LOAD or PT_SCE_RELRO describe a loadable segment.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> <span class="hljs-type">const</span>&amp; phdr : m_module-&gt;m_aSegmentHeaders)<br>&#123;<br>	<span class="hljs-keyword">switch</span> (phdr.p_type)<br>	&#123;<br>		<span class="hljs-keyword">case</span> PT_LOAD:<br>		&#123;<br>			<span class="hljs-keyword">if</span> (phdr.p_flags &amp; PF_X)<br>			&#123;<br>				<span class="hljs-built_in">MapSegment</span>(phdr);<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (phdr.p_flags &amp; PF_W)<br>			&#123;<br>				<span class="hljs-built_in">MapSegment</span>(phdr);<br>			&#125;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>		<span class="hljs-keyword">case</span> PT_SCE_RELRO:<br>		&#123;<br>			<span class="hljs-built_in">MapSegment</span>(phdr);<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Load each of the loadable segments. This is performed as follows:</p>
<p>1.Allocate virtual memory for each segment, at the address specified by the p_vaddr member in the program header. The size of the segment in memory is specified by the <code>p_memsz</code> member.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mappedMemory.m_pAddress = (<span class="hljs-type">void</span>*)<span class="hljs-number">0x000000000</span>;<br><span class="hljs-keyword">if</span> (m_module-&gt;m_fileName == <span class="hljs-string">&quot;eboot.bin&quot;</span>)<br>&#123;<br>	mappedMemory.m_pAddress = (<span class="hljs-type">void</span>*)<span class="hljs-number">0x800000000</span>;<br>&#125;<br>mappedMemory.m_pAddress = <span class="hljs-built_in">VirtualAlloc</span>(mappedMemory.m_pAddress, mappedMemory.m_size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br></code></pre></td></tr></table></figure>
<p>2.Copy the segment data from the file offset specified by the p_offset member to the virtual memory address specified by the <code>p_vaddr</code> member. The size of the segment in the file is contained in the p_filesz member. This can be zero.</p>
<p>3.The <code>p_memsz</code> member specifies the size the segment occupies in memory. This can be zero. If the p_filesz and <code>p_memsz</code> members differ, this indicates that the segment is padded with zeros. All bytes in memory between the ending offset of the file size, and the segment’s virtual memory size are to be cleared with zeros.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CPtElfProcessor::MapSegment</span><span class="hljs-params">(Elf64_Phdr <span class="hljs-type">const</span>&amp; hdr)</span></span><br><span class="hljs-function"></span>&#123;<br>	SPtModuleInfo&amp; moduleInfo = m_module-&gt;m_moduleInfo;<br>	<span class="hljs-type">uint8_t</span>* pDstAddr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint8_t</span>*&gt;(<span class="hljs-built_in">AlignUp</span>(<span class="hljs-built_in">size_t</span>(moduleInfo.m_mappedMemory.m_pAddress) + hdr.p_vaddr, hdr.p_align));<br>	<span class="hljs-type">uint8_t</span>* pSrcData = m_module-&gt;m_elfData.<span class="hljs-built_in">data</span>() + hdr.p_offset;<br>	<span class="hljs-built_in">memcpy</span>(pDstAddr, pSrcData, hdr.p_filesz);<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="Dynamic-Link"><a href="#Dynamic-Link" class="headerlink" title="Dynamic Link"></a>Dynamic Link</h1><p>Dynamic linking defers much of the linking process until a program starts running. We have loaded the segment into memory. However, the memory address of the symbols using dynamic link have not been determined. We shall perform dynamic link for those symbols. These symbols are divided into two types.</p>
<p>The symbols of the first type are not visible outside the object file containing their definition. We can relocate after the module is loaded. Other symbols of the second type are visible to all object files being combined. They are relocated after all module loaded.</p>
<h2 id="Local-Symbols-Relocation"><a href="#Local-Symbols-Relocation" class="headerlink" title="Local Symbols Relocation"></a>Local Symbols Relocation</h2><p>The following notations are used for specifying relocations in table:<br><code>A</code>: Represents the addend used to compute the value of the relocatable field.<br><code>B</code>: Represents the base address at which a shared object has been loaded into memory during execution. Generally, a shared object is built with a 0 base virtual address, but the execution address will be different.<br><code>G</code>: Represents the offset into the global offset table at which the relocation entry’s symbol will reside during execution.<br><code>GOT</code>: Represents the address of the global offset table.<br><code>L</code>: Represents the place (section offset or address) of the Procedure Linkage Table entry for a symbol.<br><code>P</code>: Represents the place (section offset or address) of the storage unit being relocated (computed using <code>r_offset</code>).<br><code>S</code>:  Represents the value of the symbol whose index resides in the relocation entry.</p>
<p>The AMD64 ABI architectures uses only <code>Elf64_Rela</code> relocation entries with explicit addends. The <code>r_addend</code> member serves as the relocation addend.<br>Table: Relocation Types</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Field</th>
<th>Calculation</th>
</tr>
</thead>
<tbody><tr>
<td>R_X86_64_NONE</td>
<td>0</td>
<td>none</td>
<td>none</td>
</tr>
<tr>
<td>R_X86_64_64</td>
<td>1</td>
<td>word64</td>
<td>S + A</td>
</tr>
<tr>
<td>R_X86_64_PC32</td>
<td>2</td>
<td>word32</td>
<td>S + A - P</td>
</tr>
<tr>
<td>R_X86_64_GOT32</td>
<td>3</td>
<td>word32</td>
<td>G + A</td>
</tr>
<tr>
<td>R_X86_64_PLT32</td>
<td>4</td>
<td>word32</td>
<td>L + A - P</td>
</tr>
<tr>
<td>R_X86_64_COPY</td>
<td>5</td>
<td>none</td>
<td>none</td>
</tr>
<tr>
<td>R_X86_64_GLOB_DAT</td>
<td>6</td>
<td>word64</td>
<td>S</td>
</tr>
<tr>
<td>R_X86_64_JUMP_SLOT</td>
<td>7</td>
<td>word64</td>
<td>S</td>
</tr>
<tr>
<td>R_X86_64_RELATIVE</td>
<td>8</td>
<td>word64</td>
<td>B + A</td>
</tr>
<tr>
<td>R_X86_64_GOTPCREL</td>
<td>9</td>
<td>word32</td>
<td>G + GOT + A - P</td>
</tr>
<tr>
<td>R_X86_64_32</td>
<td>10</td>
<td>word32</td>
<td>S + A</td>
</tr>
<tr>
<td>R_X86_64_32S</td>
<td>11</td>
<td>word32</td>
<td>S + A</td>
</tr>
<tr>
<td>R_X86_64_16</td>
<td>12</td>
<td>word16</td>
<td>S + A</td>
</tr>
<tr>
<td>R_X86_64_PC16</td>
<td>13</td>
<td>word16</td>
<td>S + A - P</td>
</tr>
<tr>
<td>R_X86_64_8</td>
<td>14</td>
<td>word8</td>
<td>S + A</td>
</tr>
<tr>
<td>R_X86_64_PC8</td>
<td>15</td>
<td>word8</td>
<td>S + A - P</td>
</tr>
<tr>
<td>R_X86_64_DPTMOD64</td>
<td>16</td>
<td>word64</td>
<td></td>
</tr>
<tr>
<td>R_X86_64_DTPOFF64</td>
<td>17</td>
<td>word64</td>
<td></td>
</tr>
<tr>
<td>R_X86_64_TPOFF64</td>
<td>18</td>
<td>word64</td>
<td></td>
</tr>
<tr>
<td>R_X86_64_TLSGD</td>
<td>19</td>
<td>word32</td>
<td></td>
</tr>
<tr>
<td>R_X86_64_TLSLD</td>
<td>20</td>
<td>word32</td>
<td></td>
</tr>
<tr>
<td>R_X86_64_DTPOFF32</td>
<td>21</td>
<td>word32</td>
<td></td>
</tr>
<tr>
<td>R_X86_64_GOTTPOFF</td>
<td>22</td>
<td>word32</td>
<td></td>
</tr>
<tr>
<td>R_X86_64_TPOFF32</td>
<td>23</td>
<td>word32</td>
<td></td>
</tr>
</tbody></table>
<p>Local symbols are not visible outside the object file containing their definition. Local symbols of the same name can exist in multiple files without interfering with each other. Currently, we only process the symbols whose binding type is R_X86_64_RELATIVE. The symbol address in memory for R_X86_64_RELATIVE type is the combination of the base memory address and the addend offset.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SPtModuleInfo&amp; moduleInfo = m_module-&gt;m_moduleInfo;<br><span class="hljs-type">uint8_t</span>* pCodeAddress = (<span class="hljs-type">uint8_t</span>*)moduleInfo.m_mappedMemory.m_pAddress;<br>Elf64_Sym* pSymTable = (Elf64_Sym*)moduleInfo.m_symbleTable.m_pAddress;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> index = <span class="hljs-number">0</span>; index &lt; relaCount; index++)<br>&#123;<br>	Elf64_Rela* pRela = &amp;pReallocateTable[index];<br>	<br>	<span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> nSymIdx = <span class="hljs-built_in">ELF64_R_SYM</span>(pRela-&gt;r_info);<br>	<span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> bindType = <span class="hljs-built_in">ELF64_R_TYPE</span>(pRela-&gt;r_info);<br><br>	Elf64_Sym&amp; symbol = pSymTable[nSymIdx];<br>	<br>	<span class="hljs-type">uint64_t</span> symAddend = pRela-&gt;r_addend;<br>	<span class="hljs-type">int</span> nBinding = <span class="hljs-built_in">ELF64_ST_BIND</span>(symbol.st_info);<br>	<span class="hljs-keyword">if</span> (nBinding == STB_LOCAL)<br>	&#123;<br>		<span class="hljs-type">void</span>* symAddress = <span class="hljs-literal">nullptr</span>;<br>		<span class="hljs-keyword">switch</span> (bindType)<br>		&#123;<br>		<span class="hljs-keyword">case</span> R_X86_64_RELATIVE:<br>		&#123;<br>			symAddress = pCodeAddress + symAddend;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>		<span class="hljs-keyword">default</span>:<br>		&#123;<br>			<span class="hljs-comment">//todo:</span><br>		&#125;<br>		&#125;<br>		<br>		*(<span class="hljs-type">uint64_t</span>*)(pCodeAddress + pRela-&gt;r_offset) = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(symAddress);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>As we mentioned above, we don’t use lazy binding, which means that the PLT relocation table is the same as the common relocation table.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SPtModuleInfo&amp; moduleInfo = m_module-&gt;m_moduleInfo;<br><span class="hljs-built_in">RelocateNativeLocalSymbol</span>((Elf64_Rela*)moduleInfo.m_relocationTable.m_pAddress, moduleInfo.m_relocationTable.m_size);<br><span class="hljs-built_in">RelocateNativeLocalSymbol</span>((Elf64_Rela*)moduleInfo.m_relocationPltTable.m_pAddress, moduleInfo.m_relocationPltTable.m_size);<br></code></pre></td></tr></table></figure>

<h2 id="Export-Symbols"><a href="#Export-Symbols" class="headerlink" title="Export Symbols"></a>Export Symbols</h2><p>For those symbols are visible to all object files being combined, we shall export them and store the relocated symbol memory address into a global address table. There are two types of symbols in them: ‘STB_GLOBAL’ and ‘STB_WEAK’.</p>
<p><code>STB_GLOBAL</code>: Global symbols. These symbols are visible to all object files being combined. One file’s definition of a global symbol will satisfy another file’s undefined reference to the same global symbol.</p>
<p><code>STB_WEAK</code>: Weak symbols. These symbols resemble global symbols, but their definitions have lower precedence.</p>
<p>Each symbol in PS4 has a hash value. We can get the module ID, library ID and NID by decoding the hash value. Then, the module name is retrieved from the global module name map by module ID.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">uint8_t</span>* pCodeAddress = (<span class="hljs-type">uint8_t</span>*)moduleInfo.m_mappedMemory.m_pAddress;<br><span class="hljs-type">uint8_t</span>* pStrTable = (<span class="hljs-type">uint8_t</span>*)moduleInfo.m_sceStrTable.m_pAddress;<br>Elf64_Sym* pSymTable = (Elf64_Sym*)moduleInfo.m_symbleTable.m_pAddress;<br><br><span class="hljs-type">uint32_t</span> nSymbolNum = moduleInfo.m_symbleTable.m_size/ <span class="hljs-built_in">sizeof</span>(Elf64_Sym);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; nSymbolNum; i++)<br>&#123;<br>	<span class="hljs-type">const</span> Elf64_Sym&amp; symbol = pSymTable[i];<br>	<span class="hljs-keyword">auto</span> binding = <span class="hljs-built_in">ELF64_ST_BIND</span>(symbol.st_info);<br>	<span class="hljs-type">char</span>* symName = (<span class="hljs-type">char</span>*)(&amp;pStrTable[symbol.st_name]);<br><br>	<span class="hljs-keyword">if</span> ((binding == STB_GLOBAL || binding == STB_WEAK) &amp;&amp; symbol.st_shndx != SHN_UNDEF)<br>	&#123;<br>		<span class="hljs-type">uint16_t</span> moduleId = <span class="hljs-number">0</span>;<br>		<span class="hljs-type">uint16_t</span> libId = <span class="hljs-number">0</span>;<br>		<span class="hljs-type">uint64_t</span> nid = <span class="hljs-number">0</span>;<br>		CPtDynamicLinker::<span class="hljs-built_in">DecodeSymbol</span>(symName, moduleId, libId, nid);<br>		std::string moduleName;<br>		std::string libName;<br><br>		<span class="hljs-keyword">auto</span> iterModule = m_module-&gt;m_id2ModuleNameMap.<span class="hljs-built_in">find</span>(moduleId);<br>		<span class="hljs-keyword">if</span> (iterModule != m_module-&gt;m_id2ModuleNameMap.<span class="hljs-built_in">end</span>())<br>		&#123;<br>			moduleName = iterModule-&gt;second;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>);<br>		&#125;<br><br>		<span class="hljs-keyword">auto</span> iterLib = m_module-&gt;m_id2LibraryNameMap.<span class="hljs-built_in">find</span>(libId);<br>		<span class="hljs-keyword">if</span> (iterLib != m_module-&gt;m_id2LibraryNameMap.<span class="hljs-built_in">end</span>())<br>		&#123;<br>			libName = iterLib-&gt;second;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>);<br>		&#125;<br>		<span class="hljs-built_in">GetPtDynamicLinker</span>()-&gt;<span class="hljs-built_in">AddNativeModule</span>(moduleName);<br>		<span class="hljs-built_in">GetPtDynamicLinker</span>()-&gt;<span class="hljs-built_in">AddSymbol</span>(moduleName, libName, nid, pCodeAddress + symbol.st_value, <span class="hljs-literal">nullptr</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="PS4-Shared-Library"><a href="#PS4-Shared-Library" class="headerlink" title="PS4 Shared Library"></a>PS4 Shared Library</h2><p>Some shared libraries are exclusive to PlayStation4, such as the libSceGnmDriver library and the libSceAudioOut library. Those libraries can’t be loaded and parsed from the game’s source code, since they are a built-in library in PlayStation4 and there is no need to pack them into the game source code. </p>
<p>However, if a library uses a symbol implemented in the libSceGnmDriver library, where can we find and load the source code on the Windows platform? In addition, where is the symbol’s address in memory? The solution is, write an override library for those PS4 built-in libraries.</p>
<p>The first step is to collect and generate all symbols from the PS4 built-in libraries. Symbol information can be found <a target="_blank" rel="noopener" href="https://github.com/idc/ps4libdoc"><u><strong>here</strong></u></a>. This repository stores built-in symbol information in JSON format. Here is an example:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs json">﻿<span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;shared_object_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;libSceGnmDriver.prx&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;shared_object_names&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;libkernel.prx&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;libSceLibcInternal.prx&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;libSceVideoOut.prx&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;modules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;libSceGnmDriver&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;version_major&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;version_minor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;libraries&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;libSceGnmDebugModuleReset&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;is_export&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;symbols&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">8548889540294976816</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;hex_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;76A3C1BE3155A530&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;encoded_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dqPBvjFVpTA&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sceGnmDebugModuleReset&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;libSceGnmDebugReset&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;is_export&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;symbols&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4959518870559534216</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;hex_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;44D3C022D88C2C88&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;encoded_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;RNPAItiMLIg&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sceGnmDebugReset&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">14178220821813346673</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;hex_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C4C328B7CF3B4171&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;encoded_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xMMot887QXE&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p><code>is_export</code> indicates if that library is exported, if false, it is imported.</p>
<ul>
<li><code>type</code> when not present is <code>Function</code>. Can be <code>Function</code>, <code>Object</code>, <code>TLS</code>, or <code>Unknown11</code> (TBD).</li>
<li><code>name</code> is either not present or is <code>null</code> when the name for the symbol is unknown.</li>
<li><code>hex_id</code> and <code>encoded_id</code> are included for human convenience and are not used by tools.</li>
</ul>
<p>We developed an automation tool to convert the PS4 symbol’s JSON file into C++ source code. It is located at <code>tools\SceModuleGenerator</code>. Here is the part of the <code>sceGnmDriver</code> header after converting. All generated symbols are added a prefix named <code>Pset</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;overridemodule/PsetLibraryCommon.h&quot;</span> </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> PSET_SYSV_ABI <span class="hljs-title">Pset_sceGnmAddEqEvent</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> PSET_SYSV_ABI <span class="hljs-title">Pset_sceGnmAreSubmitsAllowed</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> PSET_SYSV_ABI <span class="hljs-title">Pset_sceGnmBeginWorkload</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> PSET_SYSV_ABI <span class="hljs-title">Pset_sceGnmComputeWaitOnAddress</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> PSET_SYSV_ABI <span class="hljs-title">Pset_sceGnmComputeWaitSemaphore</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> PSET_SYSV_ABI <span class="hljs-title">Pset_sceGnmCreateWorkloadStream</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> PSET_SYSV_ABI <span class="hljs-title">Pset_sceGnmDebuggerGetAddressWatch</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> PSET_SYSV_ABI <span class="hljs-title">Pset_sceGnmDebuggerHaltWavefront</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-comment">//......</span><br></code></pre></td></tr></table></figure>
<p>Following is the <code>sceGnmDriver</code> source code. Currently, these functions will do nothing when invoked except output the log since we haven’t implemented them.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Generated By SceModuleGenerator</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pset_libSceGnmDriver.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> PSET_SYSV_ABI <span class="hljs-title">Pset_sceGnmAddEqEvent</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">PSET_LOG_UNIMPLEMENTED</span>(<span class="hljs-string">&quot;unimplemented function: Pset_sceGnmAddEqEvent&quot;</span>);<br>	<span class="hljs-keyword">return</span> PSET_OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> PSET_SYSV_ABI <span class="hljs-title">Pset_sceGnmAreSubmitsAllowed</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">PSET_LOG_UNIMPLEMENTED</span>(<span class="hljs-string">&quot;unimplemented function: Pset_sceGnmAreSubmitsAllowed&quot;</span>);<br>	<span class="hljs-keyword">return</span> PSET_OK;<br>&#125;<br><br><span class="hljs-comment">//......</span><br></code></pre></td></tr></table></figure>

<p>The next step is to export these symbols into the global symbol address table. Each module comprises one or more libraries. Each library contains a set of function entries.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SPSET_LIB_EXPORT_SYSMBOL</span><br>&#123;<br>	<span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> m_nid;<br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>* m_funcName;<br>	<span class="hljs-type">const</span> <span class="hljs-type">void</span>* m_pFunction;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPSET_LIB_EXPORT_FUNTCTION_END &#123;0,nullptr,nullptr&#125;</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SPSET_EXPORT_LIB</span><br>&#123;<br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>* m_libName;<br>	<span class="hljs-type">const</span> SPSET_LIB_EXPORT_SYSMBOL* m_pFunctionEntries;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPSET_EXPORT_LIB_END &#123;nullptr,nullptr&#125;</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SPSET_EXPORT_MODULE</span><br>&#123;<br>	<span class="hljs-built_in">SPSET_EXPORT_MODULE</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* moduleName, <span class="hljs-type">const</span> SPSET_EXPORT_LIB* pLibraries);<br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>* m_moduleName;<br>	<span class="hljs-type">const</span> SPSET_EXPORT_LIB* m_pLibraries;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>The symbol table is generated automatically using <code>SceModuleGenerator</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> SPSET_LIB_EXPORT_SYSMBOL gSymTable_libSceGnmDriver_libSceGnmDriver[] =<br>&#123;<br> &#123; <span class="hljs-number">0x6F4C729659D563F2</span>,<span class="hljs-string">&quot;Pset_sceGnmAddEqEvent&quot;</span>, (<span class="hljs-type">void</span>*)Pset_sceGnmAddEqEvent &#125;,<br> &#123; <span class="hljs-number">0x6F4F0082D3E51CF8</span>,<span class="hljs-string">&quot;Pset_sceGnmAreSubmitsAllowed&quot;</span>, (<span class="hljs-type">void</span>*)Pset_sceGnmAreSubmitsAllowed &#125;,<br> &#123; <span class="hljs-number">0x8A1C6B6ECA122967</span>,<span class="hljs-string">&quot;Pset_sceGnmBeginWorkload&quot;</span>, (<span class="hljs-type">void</span>*)Pset_sceGnmBeginWorkload &#125;,<br> &#123; <span class="hljs-number">0x7DFACD40EB21A30B</span>,<span class="hljs-string">&quot;Pset_sceGnmComputeWaitOnAddress&quot;</span>, (<span class="hljs-type">void</span>*)Pset_sceGnmComputeWaitOnAddress &#125;,<br> &#123; <span class="hljs-number">0x1096A9365DBEA605</span>,<span class="hljs-string">&quot;Pset_sceGnmComputeWaitSemaphore&quot;</span>, (<span class="hljs-type">void</span>*)Pset_sceGnmComputeWaitSemaphore &#125;,<br> &#123; <span class="hljs-number">0xE6E7409BEE9BA158</span>,<span class="hljs-string">&quot;Pset_sceGnmCreateWorkloadStream&quot;</span>, (<span class="hljs-type">void</span>*)Pset_sceGnmCreateWorkloadStream &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>
<p>It contains three parts:<br><code>m_nid</code>: The Nid is an unique value for each symbol. It’s the key of the symbol in global symbol map. The symbol address is retrieved by the Nid during the relocation process.<br><code>m_funcName</code>: Symbol name.<br><code>m_pFunction</code>: Symbol address.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> SPSET_EXPORT_LIB gLibTable_libSceGnmDriver[] =<br>&#123;<br> &#123;<span class="hljs-string">&quot;libSceGnmDriver&quot;</span>, gSymTable_libSceGnmDriver_libSceGnmDriver &#125;,<br> &#123;<span class="hljs-string">&quot;libSceGnmDebugModuleReset&quot;</span>, gSymTable_libSceGnmDebugModuleReset_libSceGnmDriver &#125;,<br> &#123;<span class="hljs-string">&quot;libSceGnmDebugReset&quot;</span>, gSymTable_libSceGnmDebugReset_libSceGnmDriver &#125;,<br> &#123;<span class="hljs-string">&quot;libSceGnmDriverCompat&quot;</span>, gSymTable_libSceGnmDriverCompat_libSceGnmDriver &#125;,<br> &#123;<span class="hljs-string">&quot;libSceGnmDriverResourceRegistration&quot;</span>, gSymTable_libSceGnmDriverResourceRegistration_libSceGnmDriver &#125;,<br> &#123;<span class="hljs-string">&quot;libSceGnmWaitFreeSubmit&quot;</span>, gSymTable_libSceGnmWaitFreeSubmit_libSceGnmDriver &#125;,<br> SPSET_EXPORT_LIB_END<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Dynamic linker exports the module <strong>before</strong> loading and parsing the ELF file. The modules are exported into the global symbol address table.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> SPSET_EXPORT_MODULE <span class="hljs-title">gExportModule_libSceGnmDriver</span><span class="hljs-params">(<span class="hljs-string">&quot;libSceGnmDriver&quot;</span>, gLibTable_libSceGnmDriver)</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SPSET_EXPORT_MODULE::<span class="hljs-built_in">SPSET_EXPORT_MODULE</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* moduleName, <span class="hljs-type">const</span> SPSET_EXPORT_LIB* pLibraries)<br>&#123;<br>	<span class="hljs-built_in">GetPtDynamicLinker</span>()-&gt;<span class="hljs-built_in">InitializeOverrideModule</span>(moduleName, pLibraries);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Relocate-Global-Symbols"><a href="#Relocate-Global-Symbols" class="headerlink" title="Relocate Global Symbols"></a>Relocate Global Symbols</h2><p>All symbols have been loaded. The symbols from the game library are loaded during ELF parsing. PS4 built-in library symbols are loaded during emulator initialization. The next step is to relocate the symbols retrieved from the game ELF file and replaced it with the address in the memory.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SPtModuleInfo&amp; moduleInfo = nativeModule.<span class="hljs-built_in">GetModuleInfo</span>();<br><span class="hljs-type">uint8_t</span>* pCodeAddress = (<span class="hljs-type">uint8_t</span>*)moduleInfo.m_mappedMemory.m_pAddress;<br><span class="hljs-type">uint8_t</span>* pStrTable = (<span class="hljs-type">uint8_t</span>*)moduleInfo.m_sceStrTable.m_pAddress;<br>Elf64_Sym* pSymTable = (Elf64_Sym*)moduleInfo.m_symbleTable.m_pAddress;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> index = <span class="hljs-number">0</span>; index &lt; relaCount; index++)<br>&#123;<br>	Elf64_Rela* pRela = &amp;pReallocateTable[index];<br>	<span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> nSymIdx = <span class="hljs-built_in">ELF64_R_SYM</span>(pRela-&gt;r_info);<br><br>	Elf64_Sym&amp; symbol = pSymTable[nSymIdx];<br>	<span class="hljs-keyword">auto</span> nBinding = <span class="hljs-built_in">ELF64_ST_BIND</span>(symbol.st_info);<br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pEncodedName = (<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)&amp;pStrTable[symbol.st_name];<br><br>	<span class="hljs-keyword">if</span> (nBinding == STB_GLOBAL || nBinding == STB_WEAK)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsEncodedSymbol</span>(pEncodedName))<br>		&#123;<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		<span class="hljs-type">uint64_t</span> decodedNid = <span class="hljs-number">0</span>;<br>		<span class="hljs-type">uint16_t</span> decodedModuleId = <span class="hljs-number">0</span>;<br>		<span class="hljs-type">uint16_t</span> decodedLibId = <span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">DecodeSymbol</span>(pEncodedName, decodedModuleId, decodedLibId, decodedNid);<br><br>		std::string libName;<br>		std::string moduleName;<br>		nativeModule.<span class="hljs-built_in">GetLibAndModuleName</span>(decodedLibId, decodedModuleId, libName, moduleName);<br><br>		std::string reDirlibName = libName;<br>		std::string reDirmoduleName = moduleName;<br><br>		<span class="hljs-type">const</span> <span class="hljs-type">void</span>* symAddress = <span class="hljs-built_in">GetSymbolAddress</span>(reDirmoduleName, reDirlibName, decodedNid);<br>		<span class="hljs-keyword">if</span> (symAddress)<br>		&#123;<br>			*(<span class="hljs-type">uint64_t</span>*)(pCodeAddress + pRela-&gt;r_offset) = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(symAddress);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>It contains the following steps:</p>
<p>1.Obtain the Nid, module ID and library ID by decoding the symbol name.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">DecodeSymbol</span>(pEncodedName, decodedModuleId, decodedLibId, decodedNid);<br></code></pre></td></tr></table></figure>
<p>2.Retrieve the library name and the module name by module ID and library ID.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">nativeModule.<span class="hljs-built_in">GetLibAndModuleName</span>(decodedLibId, decodedModuleId, libName, moduleName);<br></code></pre></td></tr></table></figure>
<p>3.Get the symbol address in memory by the Nid, module name and library name</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">void</span>* symAddress = <span class="hljs-built_in">GetSymbolAddress</span>(reDirmoduleName, reDirlibName, decodedNid);<br></code></pre></td></tr></table></figure>
<p>4.Relocate the symbol address</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*(<span class="hljs-type">uint64_t</span>*)(pCodeAddress + pRela-&gt;r_offset) = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(symAddress);<br></code></pre></td></tr></table></figure>
<h1 id="Run-The-Emulator"><a href="#Run-The-Emulator" class="headerlink" title="Run The Emulator"></a>Run The Emulator</h1><p>We are now able to run the emulator once the program has been loaded. Create a new thread to run the game program.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">pthread_t</span> retTid;<br><span class="hljs-type">pthread_attr_t</span> attr;<br><span class="hljs-built_in">pthread_attr_init</span>(&amp;attr);<br><span class="hljs-built_in">pthread_attr_setstacksize</span>(&amp;attr, defaultStackSize); <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> get stack size from program parameters</span><br><span class="hljs-type">int</span> retRes = <span class="hljs-built_in">pthread_create</span>(&amp;retTid, &amp;attr, CPsetThread::RunThreadFunction, <span class="hljs-keyword">this</span>);<br><span class="hljs-built_in">PSET_EXIT_AND_LOG_IF</span>(retRes != <span class="hljs-number">0</span>, <span class="hljs-string">&quot;pthread create faild&quot;</span>);<br><span class="hljs-built_in">pthread_attr_destroy</span>(&amp;attr);<br><span class="hljs-built_in">pthread_join</span>(retTid, <span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure>

<p>The Executable and Linkable Format is standardized as an adaptable file format in the System V ABI. We shall invoke the main function in sysv_abi’s calling convention.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* PSET_SYSV_ABI <span class="hljs-title">CPsetThread::SysABIMainFuncttion</span><span class="hljs-params">(<span class="hljs-type">void</span>* args)</span></span><br><span class="hljs-function"></span>&#123;<br>	CPsetThread* psetThread = (CPsetThread*)args;<br>	((PsetMainFunction)psetThread-&gt;m_pMainFunction)(&amp;psetThread-&gt;m_psetMainArg, CPsetThread::DefaultExitFunction);<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>The System V Application Binary Interface is a set of specifications that detail calling conventions, object file formats, executable file formats, dynamic linking semantics, and much more for systems that complies with the X&#x2F;Open Common Application Environment Specification and the System V Interface Definition. It is today the standard ABI used by the major Unix operating systems such as Linux, the BSD systems, and many others. The Executable and Linkable Format (ELF) is part of the System V ABI.</p>
<p>The entry function needs an additional parameter that indicates the startup module name:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SPsetMainArgs</span><br>&#123;<br>	<span class="hljs-type">uint64_t</span>    m_argc = <span class="hljs-number">1</span>;<br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>* m_argv[<span class="hljs-number">1</span>] = &#123; <span class="hljs-string">&quot;eboot.bin&quot;</span> &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Although the emulator compiles and runs successfully, we didn’t get the expected results:</p>
<p align="center">
    <img src="/resource/pset/image/unimplemented_funcs.png" srcset="/img/loading.gif" lazyload width="85%" height="85%">
</p>

<p>All output logs are “unimplemented functions: xxxxxx”, since we haven’t implemented them. In the <a target="_blank" rel="noopener" href="https://github.com/idc/ps4libdoc"><u><strong>next blog</strong></u></a>, we will implement these functions in the PS4 built-in shared library.  </p>
<p><a target="_blank" rel="noopener" href="https://github.com/ShawnTSH1229/VkRtInCryEngine"><u><strong>TODO:TODO:PS4 Emulator Source Code</strong></u></a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>How To Develop A PlayStation 4 Emulator(1)</div>
      <div>http://example.com/2024/07/05/How-To-Develop-A-PlayStation-4-Emulator(1)/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Shawn Tang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>July 5, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/07/07/How-To-Develop-A-PlayStation-4-Emulator-2/" title="How To Develop A PlayStation 4 Emulator(2)">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">How To Develop A PlayStation 4 Emulator(2)</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/06/30/Bindless-Vulkan-Ray-Tracing-In-Cry-Engine/" title="Bindless Vulkan Ray Tracing In Cry Engine">
                        <span class="hidden-mobile">Bindless Vulkan Ray Tracing In Cry Engine</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>

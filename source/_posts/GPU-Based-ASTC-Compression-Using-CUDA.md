---
title: GPU Based ASTC Compression Using CUDA
date: 2024-06-18 19:33:47
tags:
---

# CPU Based Implementation

## Bounded Integer Sequence Encoding

ASTC uses BISE to encode color end points and color weights. We introduce BISE first since it is the basis of the ASTC compression algorithm.

Both the weight data and the endpoint color data are variable width, and are specified using a sequence of integer values. The range of each value in a sequence (e.g. a color weight) is constrained.

Since it is often the case that the most efficient range for these values is not a power of two, each value sequence is encoded using a technique known as "integer sequence encoding". This allows efficient, hardware-friendly packing and unpacking of values with non-power-of-two ranges.

In a sequence, each value has an identical range. The range is specified in one of the following forms:

<p align="center">
    <img src="/resource/cuda_astc/image/range_form.png" width="50%" height="50%">
</p>

There are 21 quant methods in ASTC, including 6 quints quant form, 7 trits quant form and 8 bits quant form.

<p align="center">
    <img src="/resource/cuda_astc/image/range_table.png" width="40%" height="40%">
</p>

For example, assume we have 3 integer values: 30, 50 and 70. The minimum range of quant formats among these values is Quant_80. The binary formats of these values are: 001 1110(30), 011 0010(50) and 100 0110(70). The total bits size before quantization is 21 = 7 * 3.

The binary format of value 80 is 101 0000. We split it into two parts, the higher parts 101 and lower parts 0000. The possible values of the higher parts are from 000 to 101, whose total number is 5, so Quant 80 is a quints form.

The higher parts of 30, 50 and 70 are [001, 011, 100]. In the Quant 80 method, the total possible number is 5, so the number of possible combinations of [001, 011, 100] is 5x5x5 = 125. We can precompute these possible values into a table and use the 7 bit value to index the table. The result is a 2 bit saving for these integers.

Higher parts [001, 011, 100] equal to [1,3,4]. Using index [1][3][4] to search the below quints table, we get the compressed value:11, which is 1011 in binary format. The compressed result is [000 1011](higher parts),[1110],[0010],[0110](lower parts) with size 19.

<p align="center">
    <img src="/resource/cuda_astc/image/quints_table.png" width="60%" height="60%">
</p>


## Generate Block Mode
ASTC uses 10 bits to store block modes, which means it has 2^10(2048) kind of possible choices. Given an ASTC compression format, some block modes may be invalid. For example, ASTC 4x4 compression format will never use a block mode with 6x6 texel weights. So we search for valid block modes and store the results in a global block mode table. In order to reduce the computation cost of block mode search, arm-astc reordered the block modes so that the better block mode has a higher priority.

Search block mode from 000000000(0) to 1111111111(2048).
```cpp
for (unsigned int i = 0; i < 2048; i++)
{
    // ......
}
```

The Block Mode field specifies the width, height and depth of the grid of weights, what range of values they use, and whether dual weight planes are present.
 
For 2D blocks, the Block Mode field is laid out as follows:
<p align="center">
    <img src="/resource/cuda_astc/image/block_mode.png" width="65%" height="65%">
</p>

The **D** bit is set to indicate dual-plane mode.

The **A/B** bits indicate the block weight size.

The weight ranges are encoded using a 3 bit value **R(R0,R1 and R2)**, which is interpreted together with a precision bit **H**, as follows:
<p align="center">
    <img src="/resource/cuda_astc/image/weight_range.png" width="65%" height="65%">
</p>

Decode the R,H,D, weight sizes x and y from the bits.

```cpp
uint8_t R0 = (block_mode >> 4) & 1;
uint8_t H = (block_mode >> 9) & 1;
uint8_t D = (block_mode >> 10) & 1;
uint8_t A = (block_mode >> 5) & 0x3;

x_weights = xxxxxx;
y_weights = xxxxxx;
```

Skip the block mode if the qunat weight size is larger than the compression block size.

```cpp
if (!valid || (x_weights > x_texels) || (y_weights > y_texels))
{
	continue;
}
```

<p align="center">
    <img src="/resource/cuda_astc/image/valid_block_mode.png" width="65%" height="65%">
</p>

## Compute Ideal Color And Weights

### Color Encoding

Each compressed block stores the end-point colors for a gradient, and an interpolation weight for each texel which defines the texel's location along that gradient. During decompression the color value for each texel is generated by interpolating between the two end-point colors, based on the per-texel weight.

We sum up the relative colors in the positive R, G, and B directions and calculate the sum of direction lengths.

<p align="center">
    <img src="/resource/cuda_astc/image/color_gradient.png" width="65%" height="65%">
</p>

#### Endpoints Computation

Compute the mean color value and the main color direction first. There are many main direction calculation method. We use max accumulation pixel direction as the main direction, which is the same as the arm-astc implementation. We sum up the relative colors in the positive R, G, and B directions and calculate the sum of direction lengths.

```cpp
	float4 sum_xp(0.0);
	float4 sum_yp(0.0);
	float4 sum_zp(0.0);
	float4 sum_wp(0.0);

	for (unsigned int i = 0; i < blk.texel_count; i++)
	{
		float4 texel_datum = make_float4(blk.data_r[i], blk.data_g[i], blk.data_b[i], blk.data_a[i]);
		texel_datum = texel_datum - blk.data_mean;

		sum_xp += (texel_datum.x > 0) ? texel_datum : make_float4(0);
		sum_yp += (texel_datum.y > 0) ? texel_datum : make_float4(0);
		sum_zp += (texel_datum.z > 0) ? texel_datum : make_float4(0);
		sum_wp += (texel_datum.w > 0) ? texel_datum : make_float4(0);
	}

	float prod_xp = dot(sum_xp, sum_xp);
	float prod_yp = dot(sum_yp, sum_yp);
	float prod_zp = dot(sum_zp, sum_zp);
	float prod_wp = dot(sum_wp, sum_wp);
```

Use the maximum sum direction as the main direction

```cpp
	float4 best_vector = sum_xp;
	float best_sum = prod_xp;

	if (prod_yp > best_sum)
	{
		best_vector = sum_yp;
		best_sum = prod_yp;
	}

	if (prod_zp > best_sum)
	{
		best_vector = sum_zp;
		best_sum = prod_zp;
	}

	if (prod_wp > best_sum)
	{
		best_vector = sum_wp;
		best_sum = prod_wp;
	}

	dir = best_vector;
```

#### Interpolation Weight Computation

Project the color into the main direction for each texel and find the minimum and maximum projected value by the way.

```cpp
line4 line{ blk.data_mean, length_dir < 1e-10 ? normalize(make_float4(1.0)) : normalize(dir) };

for (unsigned int j = 0; j < blk.texel_count; j++)
{
	float4 point(blk.data_r[j], blk.data_g[j], blk.data_b[j], blk.data_a[j]);
	float param = dot(point - line.a, line.b);

	ei.weights[j] = param;

	lowparam = fmin(param, lowparam);
	highparam = fmax(param, highparam);
}
```
Calculate the end points based on the min/max projected color.

```cpp
ei.ep.endpt0 = line.a + line.b * lowparam;
ei.ep.endpt1 = line.a + line.b * highparam;
```

Normalize the weight range into 0 to 1:
```cpp
float length = highparam - lowparam;
float scale = 1.0f / length;

for (unsigned int j = 0; j < blk.texel_count; j++)
{
	float idx = (ei.weights[j] - lowparam) * scale;
	idx = clamp(idx, 0.0, 1.0);
	ei.weights[j] = idx;
}
```

before color projection:
<p align="center">
    <img src="/resource/cuda_astc/image/before_color_projection.png" width="30%" height="30%">
</p>

after color projection:
<p align="center">
    <img src="/resource/cuda_astc/image/after_color_projection.png" width="30%" height="30%">
</p>

## Compute Quant Error

### Compute Weight Quant Error

Compute the quant errors for each candidate block mode. Get the Quant method from the block mode and quantize the weights. After that, unquant the result by look up the precomputed quant map table. It should be noticed that the maximum color weight Quant method is Quant 32 and the maximum color end points Quant method is Quant 256.

<p align="center">
    <img src="/resource/cuda_astc/image/weight_quant_error.png" width="60%" height="60%">
</p>

Accumulate the weight quantization error for the texel weights in the block.

```cpp
float error_summa = 0;
for (unsigned int i = 0; i < bsd.texel_count; i++)
{
	// Load the weight set directly, without interpolation
	float current_values = weight_quant_uvalue[i];

	// Compute the error between the computed value and the ideal weight
	float actual_values = eai.weights[i];
	float diff = current_values - actual_values;

	float error = diff * diff;
	error_summa += error;
}
return error_summa;
```
weights quant error result:
<p align="center">
    <img src="/resource/cuda_astc/image/weight_quant_error_result.png" width="60%" height="60%">
</p>

## Search Candidate EndPoint

The next step is to search for the best K candidate end point format as we have the quant error of each block mode.

### CEM

CEM is the color endpoint mode field, which determines how the Color Endpoint Data is encoded. Here is the CEM layout for single-partition block layout:

<p align="center">
    <img src="/resource/cuda_astc/image/cem_layout.png" width="60%" height="60%">
</p>

In single-partition mode, the Color Endpoint Mode (CEM) field stores one of 16 possible values. Each of these specifies how many raw data values are encoded, and how to convert these raw values into two RGBA color endpoints. They can be summarized as follows:

<p align="center">
    <img src="/resource/cuda_astc/image/16cems.png" width="60%" height="60%">
</p>

ASTC has 16 color end point modes. To store the end points, Modes 0 to 3 use two integers, Modes 4 to 7 use four integers, Modes 7 to 11 use six integers, and Modes 12 to 15 use eight integers. In our implementation, we only support six modes: mode 0, mode 4, mode 6, mode 8, mode 10 and mode 12.

Decode the different LDR endpoint modes as follows:

1.Mode 0  LDR Luminance, direct:
```cpp
e0=(v0,v0,v0,0xFF); 
e1=(v1,v1,v1,0xFF);
```

2.Mode 4  LDR Luminance+Alpha,direct:
```cpp
e0=(v0,v0,v0,v2);
e1=(v1,v1,v1,v3);
```

3.Mode 6  LDR RGB, base+scale
```cpp
e0=(v0*v3>>8,v1*v3>>8,v2*v3>>8, 0xFF);
e1=(v0,v1,v2,0xFF);
```

4.Mode 8  LDR RGB, Direct
```cpp
s0= v0+v2+v4; 
s1= v1+v3+v5;
if (s1>=s0)
{
	e0=(v0,v2,v4,0xFF);
    e1=(v1,v3,v5,0xFF); 
}
else 
{ 
	e0=blue_contract(v1,v3,v5,0xFF);
    e1=blue_contract(v0,v2,v4,0xFF); 
}
```
5.Mode 10 LDR RGB, base+scale plus two A
```cpp
e0=(v0*v3>>8,v1*v3>>8,v2*v3>>8, v4);
e1=(v0,v1,v2, v5)
```

6.Mode 12 LDR RGBA, direct
```cpp
s0= v0+v2+v4; s1= v1+v3+v5;
if (s1>=s0)
{
	e0=(v0,v2,v4,v6);
    e1=(v1,v3,v5,v7); 
}
else 
{
	e0=blue_contract(v1,v3,v5,v7);
    e1=blue_contract(v0,v2,v4,v6); 
}
```
Then, we estimate the error of each end point mode. Color end point modes can be classified into 3 types: luminance representation, scale representation and RGB representation. In astc-enc, the error estimation of luminance representation is the sum of the distances to vector normalize(lumi,lumin,lumin) = float3(0.57,0.57,0.57). Scale representation error estimation is the sum of the distance to vector normalize(EndPointA + EndPointB).
```cpp
	samec_rgb_lines.a = make_float4(0);
	samec_rgb_lines.b = normalize_safe(avg);

	float val = 0.577350258827209473f;
	luminance_plines.amod = make_float4(0);
	luminance_plines.bs = make_float4(val, val, val, 0.0f);
```
Calculate and accumulate the scale and luminance error of each texel:
```cpp
// Compute same chroma error - no "amod", its always zero
param = data_r * samec_bs0+ data_g * samec_bs1 + data_b * samec_bs2;

dist0 = (param * samec_bs0) - data_r;
dist1 = (param * samec_bs1) - data_g;
dist2 = (param * samec_bs2) - data_b;

error = dist0 * dist0 + dist1 * dist1 + dist2 * dist2;

samec_err += error;

// Compute luma error - no "amod", its always zero
param = data_r * l_bs0 + data_g * l_bs1 + data_b * l_bs2;

dist0 = (param * l_bs0) - data_r;
dist1 = (param * l_bs1) - data_g;
dist2 = (param * l_bs2) - data_b;

error = dist0 * dist0 + dist1 * dist1 + dist2 * dist2;

l_err += error;
```

The endpoint encoding uses 21 quant levels and 4 kinds of integer numbers, resulting in a total candidate format count of 21 * 4. For each quant level, we choose the endpoint format for each kind of integer number.

The error estimation contains six parts: baseline quant error, base quant error RGB, base quant error RGBA, scale error, luminance error, drop alpha error.

1.Baseline quant error is precomputed in a look up table and indexed by quant level.
```cpp
__constant__ float baseline_quant_error[21 - QUANT_6]{
	(65536.0f * 65536.0f / 18.0f) / (5 * 5),
	(65536.0f * 65536.0f / 18.0f) / (7 * 7),
	(65536.0f * 65536.0f / 18.0f) / (9 * 9),
	(65536.0f * 65536.0f / 18.0f) / (11 * 11),
	(65536.0f * 65536.0f / 18.0f) / (15 * 15),
	(65536.0f * 65536.0f / 18.0f) / (19 * 19),
	(65536.0f * 65536.0f / 18.0f) / (23 * 23),
	(65536.0f * 65536.0f / 18.0f) / (31 * 31),
	(65536.0f * 65536.0f / 18.0f) / (39 * 39),
	(65536.0f * 65536.0f / 18.0f) / (47 * 47),
	(65536.0f * 65536.0f / 18.0f) / (63 * 63),
	(65536.0f * 65536.0f / 18.0f) / (79 * 79),
	(65536.0f * 65536.0f / 18.0f) / (95 * 95),
	(65536.0f * 65536.0f / 18.0f) / (127 * 127),
	(65536.0f * 65536.0f / 18.0f) / (159 * 159),
	(65536.0f * 65536.0f / 18.0f) / (191 * 191),
	(65536.0f * 65536.0f / 18.0f) / (255 * 255)
};
```
2.In our implementation, the base quant error of each channel is the same.  In astc-enc, the error of each channel can be adjusted by the user.

```cpp
float base_quant_error_rgb = 3 * blk.texel_count;
float base_quant_error_a = 1 * blk.texel_count;
float base_quant_error_rgba = base_quant_error_rgb + base_quant_error_a;
```
3.Scale error, luminance error and drop alpha error are computed in the previous step.

4.The final error for each endpoint format is the combination of the above errors.

Take the example of computing the error for the endpoint format encoded by 4 integers using the quant method 7.

The error of mode <RGB base + scale> calculation formula is as follows:
rgbs_alpha_error = base quant error **rgba** * baseline quant error of quant method 7 + **rgb scale** error

The error of mode <RGB direct> calculation formula:
full_ldr_rgb_error = base quant error **rgb** * baseline quant error of quant method 7 + **alpha drop** error

Select the format with the minimum error:
```cpp
if (rgbs_alpha_error < full_ldr_rgb_error)
{
	best_error[i][2] = rgbs_alpha_error;
	format_of_choice[i][2] = FMT_RGB_SCALE_ALPHA;
}
else
{
	best_error[i][2] = full_ldr_rgb_error;
	format_of_choice[i][2] = FMT_RGB;
}
```




## Find The Actually Best Mode

# GPU Based Implementation

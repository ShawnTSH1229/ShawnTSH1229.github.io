---
title: GPU Based ASTC Compression Using CUDA
date: 2024-06-18 19:33:47
tags:
---

# CPU Based Implementation

## Bounded Integer Sequence Encoding

ASTC uses BISE to encode color end points and color weights. We introduce BISE first since it is the basis of the ASTC compression algorithm.

Both the weight data and the endpoint color data are variable width, and are specified using a sequence of integer values. The range of each value in a sequence (e.g. a color weight) is constrained.

Since it is often the case that the most efficient range for these values is not a power of two, each value sequence is encoded using a technique known as "integer sequence encoding". This allows efficient, hardware-friendly packing and unpacking of values with non-power-of-two ranges.

In a sequence, each value has an identical range. The range is specified in one of the following forms:

<p align="center">
    <img src="/resource/cuda_astc/image/range_form.png" width="50%" height="50%">
</p>

There are 21 quant methods in ASTC, including 6 quints quant form, 7 trits quant form and 8 bits quant form.

<p align="center">
    <img src="/resource/cuda_astc/image/range_table.png" width="40%" height="40%">
</p>

For example, assume we have 3 integer values: 30, 50 and 70. The minimum range of quant formats among these values is Quant_80. The binary formats of these values are: 001 1110(30), 011 0010(50) and 100 0110(70). The total bits size before quantization is 21 = 7 * 3.

The binary format of value 80 is 101 0000. We split it into two parts, the higher parts 101 and lower parts 0000. The possible values of the higher parts are from 000 to 101, whose total number is 5, so Quant 80 is a quints form.

The higher parts of 30, 50 and 70 are [001, 011, 100]. In the Quant 80 method, the total possible number is 5, so the number of possible combinations of [001, 011, 100] is 5x5x5 = 125. We can precompute these possible values into a table and use the 7 bit value to index the table. The result is a 2 bit saving for these integers.

Higher parts [001, 011, 100] equal to [1,3,4]. Using index [1][3][4] to search the below quints table, we get the compressed value:11, which is 1011 in binary format. The compressed result is [000 1011](higher parts),[1110],[0010],[0110](lower parts) with size 19.

<p align="center">
    <img src="/resource/cuda_astc/image/quints_table.png" width="60%" height="60%">
</p>


## Generate Block Mode
ASTC uses 10 bits to store block modes, which means it has 2^10(2048) kind of possible choices. Given an ASTC compression format, some block modes may be invalid. For example, ASTC 4x4 compression format will never use a block mode with 6x6 texel weights. So we search for valid block modes and store the results in a global block mode table. In order to reduce the computation cost of block mode search, arm-astc reordered the block modes so that the better block mode has a higher priority.

Search block mode from 000000000(0) to 1111111111(2048).
```cpp
for (unsigned int i = 0; i < 2048; i++)
{
    // ......
}
```

The Block Mode field specifies the width, height and depth of the grid of weights, what range of values they use, and whether dual weight planes are present.
 
For 2D blocks, the Block Mode field is laid out as follows:
<p align="center">
    <img src="/resource/cuda_astc/image/block_mode.png" width="65%" height="65%">
</p>

The **D** bit is set to indicate dual-plane mode.

The **A/B** bits indicate the block weight size.

The weight ranges are encoded using a 3 bit value **R(R0,R1 and R2)**, which is interpreted together with a precision bit **H**, as follows:
<p align="center">
    <img src="/resource/cuda_astc/image/weight_range.png" width="65%" height="65%">
</p>

Decode the R,H,D, weight sizes x and y from the bits.

```cpp
uint8_t R0 = (block_mode >> 4) & 1;
uint8_t H = (block_mode >> 9) & 1;
uint8_t D = (block_mode >> 10) & 1;
uint8_t A = (block_mode >> 5) & 0x3;

x_weights = xxxxxx;
y_weights = xxxxxx;
```

Skip the block mode if the qunat weight size is larger than the compression block size.

```cpp
if (!valid || (x_weights > x_texels) || (y_weights > y_texels))
{
	continue;
}
```

<p align="center">
    <img src="/resource/cuda_astc/image/valid_block_mode.png" width="65%" height="65%">
</p>

## Compute Ideal Color And Weights

### Color Encoding

Each compressed block stores the end-point colors for a gradient, and an interpolation weight for each texel which defines the texel's location along that gradient. During decompression the color value for each texel is generated by interpolating between the two end-point colors, based on the per-texel weight.

We sum up the relative colors in the positive R, G, and B directions and calculate the sum of direction lengths.

<p align="center">
    <img src="/resource/cuda_astc/image/color_gradient.png" width="65%" height="65%">
</p>

#### Endpoints Computation

Compute the mean color value and the main color direction first. There are many main direction calculation method. We use max accumulation pixel direction as the main direction, which is the same as the arm-astc implementation. We sum up the relative colors in the positive R, G, and B directions and calculate the sum of direction lengths.

```cpp
	float4 sum_xp(0.0);
	float4 sum_yp(0.0);
	float4 sum_zp(0.0);
	float4 sum_wp(0.0);

	for (unsigned int i = 0; i < blk.texel_count; i++)
	{
		float4 texel_datum = make_float4(blk.data_r[i], blk.data_g[i], blk.data_b[i], blk.data_a[i]);
		texel_datum = texel_datum - blk.data_mean;

		sum_xp += (texel_datum.x > 0) ? texel_datum : make_float4(0);
		sum_yp += (texel_datum.y > 0) ? texel_datum : make_float4(0);
		sum_zp += (texel_datum.z > 0) ? texel_datum : make_float4(0);
		sum_wp += (texel_datum.w > 0) ? texel_datum : make_float4(0);
	}

	float prod_xp = dot(sum_xp, sum_xp);
	float prod_yp = dot(sum_yp, sum_yp);
	float prod_zp = dot(sum_zp, sum_zp);
	float prod_wp = dot(sum_wp, sum_wp);
```

Use the maximum sum direction as the main direction

```cpp
	float4 best_vector = sum_xp;
	float best_sum = prod_xp;

	if (prod_yp > best_sum)
	{
		best_vector = sum_yp;
		best_sum = prod_yp;
	}

	if (prod_zp > best_sum)
	{
		best_vector = sum_zp;
		best_sum = prod_zp;
	}

	if (prod_wp > best_sum)
	{
		best_vector = sum_wp;
		best_sum = prod_wp;
	}

	dir = best_vector;
```

#### Interpolation Weight Computation

Project the color into the main direction for each texel and find the minimum and maximum projected value by the way.

```cpp
line4 line{ blk.data_mean, length_dir < 1e-10 ? normalize(make_float4(1.0)) : normalize(dir) };

for (unsigned int j = 0; j < blk.texel_count; j++)
{
	float4 point(blk.data_r[j], blk.data_g[j], blk.data_b[j], blk.data_a[j]);
	float param = dot(point - line.a, line.b);

	ei.weights[j] = param;

	lowparam = fmin(param, lowparam);
	highparam = fmax(param, highparam);
}
```
Calculate the end points based on the min/max projected color.

```cpp
ei.ep.endpt0 = line.a + line.b * lowparam;
ei.ep.endpt1 = line.a + line.b * highparam;
```

Normalize the weight range into 0 to 1:
```cpp
float length = highparam - lowparam;
float scale = 1.0f / length;

for (unsigned int j = 0; j < blk.texel_count; j++)
{
	float idx = (ei.weights[j] - lowparam) * scale;
	idx = clamp(idx, 0.0, 1.0);
	ei.weights[j] = idx;
}
```

before color projection:
<p align="center">
    <img src="/resource/cuda_astc/image/before_color_projection.png" width="30%" height="30%">
</p>

after color projection:
<p align="center">
    <img src="/resource/cuda_astc/image/after_color_projection.png" width="30%" height="30%">
</p>

## Compute Quant Error

### Compute Weight Quant Error

Compute the quant errors for each candidate block mode.


weight_quant_error.png





It should be noticed that the maximum color weight Quant method is Quant 32 and the maximum color end points Quant method is Quant 256.

## Search Candidate EndPoint
## Find The Actually Best Mode

# GPU Based Implementation
